<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>jQuery中的AJAX</title>
    <link href="/2022/08/16/jQuery%E4%B8%AD%E7%9A%84AJAX/"/>
    <url>/2022/08/16/jQuery%E4%B8%AD%E7%9A%84AJAX/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作jQuery</title>
    <link href="/2022/08/16/%E6%93%8D%E4%BD%9CjQuery/"/>
    <url>/2022/08/16/%E6%93%8D%E4%BD%9CjQuery/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="监听文档加载"><a href="#监听文档加载" class="headerlink" title="监听文档加载"></a>监听文档加载</h3><ul><li>只用掌握一种</li><li>这个是当文档加载完成时执行里面的函数</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>  var <span class="hljs-variable">$doc</span> =  $(document)<br><span class="hljs-regexp">//</span>  <span class="hljs-regexp">//</span> 方式 <span class="hljs-number">1</span>:监听文档完全解析完成<br><span class="hljs-regexp">//</span>  <span class="hljs-variable">$doc</span>.ready(<span class="hljs-keyword">function</span>() &#123;<br><span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&#x27;doc ready&#x27;</span>)<br><span class="hljs-regexp">//</span>  &#125;)<br><br> <span class="hljs-regexp">//</span> 方式 <span class="hljs-number">2</span>:监听文档完全解析完成<br><span class="hljs-regexp">//</span> jQuery(<span class="hljs-string">&#x27;document&#x27;</span>).ready(<span class="hljs-keyword">function</span>()&#123;<br><span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&#x27;doc ready&#x27;</span>)<br><span class="hljs-regexp">//</span> &#125;)<br><br> <span class="hljs-regexp">//</span> 方式 <span class="hljs-number">3</span>:监听文档完全解析完成<br><span class="hljs-regexp">//</span> $().ready(<span class="hljs-keyword">function</span>()&#123;<br><span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&#x27;doc ready&#x27;</span>)<br><span class="hljs-regexp">//</span> &#125;)<br><br> <span class="hljs-regexp">//</span> 方式 <span class="hljs-number">4</span>:监听文档完全解析完成<br><span class="hljs-regexp">//</span> $(<span class="hljs-keyword">function</span>() &#123;<br><span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&#x27;doc ready&#x27;</span>)<br><span class="hljs-regexp">//</span> &#125;)<br></code></pre></td></tr></table></figure><h3 id="jQuery与其它库的变量名冲突"><a href="#jQuery与其它库的变量名冲突" class="headerlink" title="jQuery与其它库的变量名冲突"></a><strong>jQuery</strong>与其它库的变量名冲突</h3><ul><li><strong>和 jQuery库一样，</strong>许多JavaScript库也会使用 $ 作为函数名或变量名。<ul><li>在 jQuery 中，$ 是jQuery的别名。</li><li>如果我们在使用jQuery库之前，其它库已经使用了 $ 函数或者变量，这时就会出现冲突的情况。</li><li>这时我们可以通过调用jQuery中的noConflict函数来解决冲突问题。</li><li>jQuery在初始化前会先备份一下全局其它库的jQuery和$变量，调用noConflict函数只是恢复之前备份的jQuery和$变量。</li></ul></li></ul><h4 id="jQuery的选择器-Selectors"><a href="#jQuery的选择器-Selectors" class="headerlink" title="jQuery的选择器**(Selectors)**"></a><strong>jQuery</strong>的选择器**(Selectors)**</h4><ul><li><strong>jQuery</strong>函数支持大部分的CSS选择器，语法：jQuery（’字符串格式的选择器’）<ul><li>1.通用选择器（*）</li><li>2.基本选择器（id, class, 元素）</li><li>3.属性选择器（ [attr] , [atrr&#x3D;”value ”] ）</li><li>4.后代选择器（div &gt; span, div span）</li><li>5.兄弟选择器（div + span , div ~ span）</li><li>6.交集选择器（div.container） </li><li>7.伪类选择器（:nth-child()，:nth-of-type()，:not()， 但不支持状态伪类 :hover, :focus…）</li><li>8.内容选择器（:empty，:has(selector)）, empty指选中的元素没有子元素或文本； has指选中的元素是否存在某个子元素</li><li>9.可见选择器（:visible, :hidden）</li><li>10.jQuery扩展选择器：（:eq(), :odd, :even, :first, :last ）</li></ul></li></ul><h4 id="jQuery对文本的操作"><a href="#jQuery对文本的操作" class="headerlink" title="jQuery对文本的操作"></a><strong>jQuery</strong>对文本的操作</h4><ul><li><p>.text()、.text(text)</p><ul><li>获取匹配到元素集合中每个元素组合的文本内容，包括它们的后代，或设置匹配到元素的文本内容。</li><li>相当与原生元素的textContent属性。</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$(<span class="hljs-string">&#x27;ul li&#x27;</span>).<span class="hljs-built_in">text</span>(<span class="hljs-string">&#x27;我是li&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>.html()<strong>、</strong>html(htmlString)</strong></p><ul><li>获取匹配到元素集合中第一个元素的HTML内容，包括它们的后代，或设置每个匹配元素的 HTML 内容。</li><li>相当与原生元素的innerHTML属性。</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery">$(<span class="hljs-string">&#x27;ul li&#x27;</span>).html(`<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是p元素<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是一个span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>`)<br></code></pre></td></tr></table></figure></li><li><p>.val()、.val(value)</p><ul><li>获取匹配到元素集合中第一个元素的当前值 或 设置每个匹配到元素的值。</li><li>该.val()方法主要用于获取input,select和等表单元素的值。</li><li>相当与获取原生元素的value属性。</li></ul></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$(<span class="hljs-string">&#x27;.login&#x27;</span>).click(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( $(<span class="hljs-string">&#x27;.user&#x27;</span>).val() )<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( $(<span class="hljs-string">&#x27;.password&#x27;</span>).val() )<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识jQuery</title>
    <link href="/2022/08/16/jQuery/"/>
    <url>/2022/08/16/jQuery/</url>
    
    <content type="html"><![CDATA[<h2 id="What’s-it"><a href="#What’s-it" class="headerlink" title="What’s it"></a>What’s it</h2><h4 id="是一个快速、小型且功能丰富的-JavaScript-库，官网对jQuery的描述："><a href="#是一个快速、小型且功能丰富的-JavaScript-库，官网对jQuery的描述：" class="headerlink" title="是一个快速、小型且功能丰富的 JavaScript 库，官网对jQuery的描述："></a><strong>是一个</strong>快速、小型且功能丰富的 JavaScript 库，官网对jQuery的描述：</h4><ul><li>使HTML文档遍历、操作、事件处理、动画和 Ajax 之类的事情变得更加简单。</li><li>具有易于使用的 API，可在多种浏览器中使用。</li><li>jQuery 结合多功能性和可扩展性，改变了数百万人编写 JavaScript 的方式。</li></ul><h4 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h4><ul><li><strong><a href="https://jquery.com/">https://jquery.com/</a></strong></li></ul><h4 id="源码下载地址"><a href="#源码下载地址" class="headerlink" title="源码下载地址"></a>源码下载地址</h4><ul><li><a href="https://code.jquery.com/jquery-3.6.0.js">https://code.jquery.com/jquery-3.6.0.js</a></li></ul><h2 id="库-library-和框架-framework-的概念"><a href="#库-library-和框架-framework-的概念" class="headerlink" title="库(library)和框架(framework)的概念"></a>库(library)和框架(framework)的概念</h2><ul><li><strong>随着</strong>JavaScript<strong>的普及，以及越来越多人使用</strong>JavaScript<strong>来构建网站和应用程序</strong><ul><li>JavaScript社区认识到代码中存在非常多相同的逻辑是可复用的。</li><li>因此社区就开始对这些相同的逻辑的代码封装到一个JavaScript文件中。</li><li>这个封装好的JavaScript文件就可称为JavaScript库或JavaScript框架。</li></ul></li><li><strong>库</strong>(library)<ul><li>JavaScript库是一个预先编写好并实现了一些特定功能的代码片段的集合。</li><li>一个库中会包含许多的函数、变量等，可根据需求引入到项目中使用。</li><li>一些常见的库有jQuery、Day.js、Lodash和React等</li></ul></li><li><strong>框架（framework）</strong><ul><li>JavaScript框架是一个完整的工具集，可帮助塑造和组织您的网站或应用程序。</li><li>提供一个结构来构建整个应用程序，开发人员可以在结构的规则内更安全、更高效地工作。</li><li>一些更常见的框架有：Bootstrap、Angular、Vue、Next.js等。</li></ul></li></ul><h2 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>易于学习：相对于其它的前端框架，jQuery 更易于学习，它支持 JavaScript 的编码风格。</p></li><li><p>少写多做（Write less, do more）</p><ul><li>jQuery提供了丰富的功能(DOM操作、过滤器、事件、动画、Ajax等)。</li><li>可以编写更少可读的代码来提高开发人员的工作效率。</li></ul><p>优秀的 API 文档：jQuery 提供了优秀的在线 API 文档。</p><p>跨浏览器支持：提供出色的跨浏览器支持 (IE9+)，无需编写额外代码。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>jQuery代码库一直在增长（自 jQuery 1.5 起超过 200KB）</li><li>不支持组件化开发</li><li>jQuery 更适合DOM操作，当涉及到开发复杂的项目时，jQuery能力有限。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS网络请求封装</title>
    <link href="/2022/08/15/JS%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/"/>
    <url>/2022/08/15/JS%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="系统课的"><a href="#系统课的" class="headerlink" title="系统课的"></a>系统课的</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 练习hyajax -&gt; axios</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hyajax</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">  url,</span><br><span class="hljs-params">  method = <span class="hljs-string">&quot;get&quot;</span>,</span><br><span class="hljs-params">  data = &#123;&#125;,</span><br><span class="hljs-params">  headers = &#123;&#125;, // token</span><br><span class="hljs-params">  success,</span><br><span class="hljs-params">  failure</span><br><span class="hljs-params">&#125; = &#123;&#125;</span>) &#123;  <span class="hljs-comment">//= &#123;&#125;是为了默认值？ 默认对象，解构</span><br>  <span class="hljs-comment">// 1.创建对象</span><br>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><br>  <span class="hljs-comment">// 2.监听数据</span><br>  xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>      success &amp;&amp; <span class="hljs-title function_">success</span>(xhr.<span class="hljs-property">response</span>)  <span class="hljs-comment">//&amp;&amp;防止没有传入success参数</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      failure &amp;&amp; <span class="hljs-title function_">failure</span>(&#123; <span class="hljs-attr">status</span>: xhr.<span class="hljs-property">status</span>, <span class="hljs-attr">message</span>: xhr.<span class="hljs-property">statusText</span> &#125;)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 3.设置类型</span><br>  xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>  <span class="hljs-comment">//一般都要转json格式，因为好解析</span><br><br>  <span class="hljs-comment">// 4.open方法</span><br>  <span class="hljs-keyword">if</span> (method.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&quot;GET&quot;</span>) &#123;  <span class="hljs-comment">//防止调用者用小写的get</span><br>    <span class="hljs-keyword">const</span> queryStrings = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> data) &#123;<br>      queryStrings.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;data[key]&#125;</span>`</span>)<br>    &#125;<br>    url = url + <span class="hljs-string">&quot;?&quot;</span> + queryStrings.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&amp;&quot;</span>)<br>    xhr.<span class="hljs-title function_">open</span>(method, url)<br>    xhr.<span class="hljs-title function_">send</span>()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    xhr.<span class="hljs-title function_">open</span>(method, url)<br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data))<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> xhr<br>&#125;<br><br><span class="hljs-comment">// 调用者</span><br><span class="hljs-title function_">hyajax</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://123.207.32.32:1888/02_param/get&quot;</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>  &#125;,<br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res:&quot;</span>, res)<br>  &#125;,<br>  <span class="hljs-attr">failure</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-comment">// alert(err.message)</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>因为函数的形参太多了，所以给参数设置默认值。</p></li><li><p>XMLHttpRequest是ajax的网络请求类方法</p></li><li><p>然后编写监听函数，要判断是否请求成功，所以要进行状态判定。当成功时执行success函数，为了防止调用者没有传入success函数，所以要判断</p></li><li><p>记得把获得的类型转换成json</p></li><li><p>接下来就是调用open方法，但是使用get和用post他们传入的参数格式不一样。所以也要加个判断。？？什么格式不一样？？</p><ul><li>调用者在使用get方法时，可能将data放在对象中的data里面，而不是放在url里，所以要拼接</li></ul></li><li><p>判断完open后就要调用sent来完成网络请求</p></li><li><p>最后将其返回就完成了</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS发送网络请求</title>
    <link href="/2022/08/15/JS%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <url>/2022/08/15/JS%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="AJAX发送请求"><a href="#AJAX发送请求" class="headerlink" title="AJAX发送请求"></a>AJAX发送请求</h2><ul><li>AJAX 是异步的 JavaScript 和 XML（Asynchronous JavaScript And XML）<ul><li>它可以使用 JSON，XML，HTML 和 text 文本等格式发送和接收数据；</li></ul></li></ul><h4 id="如何来完成AJAX请求呢？"><a href="#如何来完成AJAX请求呢？" class="headerlink" title="如何来完成AJAX请求呢？"></a>如何来完成AJAX请求呢？</h4><ul><li> 第一步：创建网络请求的AJAX对象（使用XMLHttpRequest）</li><li> 第二步：监听XMLHttpRequest对象状态的变化，或者监听onload事件（请求完成时触发）； </li><li> 第三步：配置网络请求（通过open方法）； </li><li> 第四步：发送send网络请求；</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>.创建XMLHttpRequest对象<br> const xhr = new XMLHttpRequest()<br><br> <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>.监听状态的改变(宏任务)<br> xhr.onreadystatechange = <span class="hljs-keyword">function</span>() &#123;<br>   <span class="hljs-regexp">//</span> console.log(xhr.response)<br>   <span class="hljs-keyword">if</span> (xhr.readyState !== XMLHttpRequest.DONE) return  <span class="hljs-regexp">//</span>XMLHttpRequest共有四个状态不判断的话会进行四次<br><br>   <span class="hljs-regexp">//</span> 将字符串转成JSON对象(js对象)<br>   const resJSON = JSON.parse(xhr.response)<br>   const banners = resJSON.data.banner.list<br>   console.log(banners)<br> &#125;<br><br> <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>.配置请求open<br> <span class="hljs-regexp">//</span> method: 请求的方式(get<span class="hljs-regexp">/post/</span><span class="hljs-keyword">delete</span><span class="hljs-regexp">/put/</span>patch...)<br> <span class="hljs-regexp">//</span> url: 请求的地址<br> xhr.open(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>)<br><br> <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>.发送请求(浏览器帮助发送对应请求)<br> xhr.send()<br><br></code></pre></td></tr></table></figure><h4 id="XMLHttpRequest的state（状态）"><a href="#XMLHttpRequest的state（状态）" class="headerlink" title="XMLHttpRequest的state（状态）"></a>XMLHttpRequest的state（状态）</h4><ul><li>事实上，我们在一次网络请求中看到状态发生了很多次变化，这是因为对于一次请求来说包括如下的状态：</li></ul><p><img src="C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\XMLstate.png"></p><ul><li><p>发送同步请求：</p><ul><li>将open的第三个参数设置为false</li></ul></li></ul><h3 id="XMLHttpRequest其他事件监听"><a href="#XMLHttpRequest其他事件监听" class="headerlink" title="XMLHttpRequest其他事件监听"></a>XMLHttpRequest其他事件监听</h3><h5 id="除了onreadystatechange还有其他的事件可以监听"><a href="#除了onreadystatechange还有其他的事件可以监听" class="headerlink" title="除了onreadystatechange还有其他的事件可以监听"></a>除了onreadystatechange还有其他的事件可以监听</h5><ul><li> loadstart：请求开始。 </li><li> progress： 一个响应数据包到达，此时整个 response body 都在 response 中。 </li><li> abort：调用 xhr.abort() 取消了请求。 </li><li> error：发生连接错误，例如，域错误。不会发生诸如 404 这类的 HTTP 错误。 </li><li> load：请求成功完成。 </li><li> timeout：由于请求超时而取消了该请求（仅发生在设置了 timeout 的情况下）。</li><li> loadend：在 load，error，timeout 或 abort 之后触发。</li></ul><h4 id="HTTP响应的状态status"><a href="#HTTP响应的状态status" class="headerlink" title="HTTP响应的状态status"></a>HTTP响应的状态status</h4><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\HTTP code.png)</p><h4 id="GET-x2F-POST请求传递参数"><a href="#GET-x2F-POST请求传递参数" class="headerlink" title="GET&#x2F;POST请求传递参数"></a>GET&#x2F;POST请求传递参数</h4><ul><li>方式一：GET请求的query参数</li><li>方式二：POST请求 x-www-form-urlencoded 格式  </li><li>方式三：POST请求 FormData 格式  </li><li>方式四：POST请求 JSON 格式</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>.传递参数方式一: get -&gt; query<br><span class="hljs-regexp">//</span> xhr.open(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;http://123.207.32.32:1888/02_param/get?name=why&amp;age=18&amp;address=广州市&quot;</span>)<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>.传递参数方式二: post -&gt; urlencoded<br><span class="hljs-regexp">//</span> xhr.open(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;http://123.207.32.32:1888/02_param/posturl&quot;</span>)<br><span class="hljs-regexp">//</span> <span class="hljs-regexp">//</span> 发送请求(请求体body)<br><span class="hljs-regexp">//</span> xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>)<br><span class="hljs-regexp">//</span> xhr.send(<span class="hljs-string">&quot;name=why&amp;age=18&amp;address=广州市&quot;</span>)<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span>.传递参数方式三: post -&gt; formdata<br><span class="hljs-regexp">//</span> xhr.open(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;http://123.207.32.32:1888/02_param/postform&quot;</span>)<br><span class="hljs-regexp">//</span> <span class="hljs-regexp">//</span> formElement对象转成FormData对象<br><span class="hljs-regexp">//</span> const formData = new FormData(formEl)<br><span class="hljs-regexp">//</span> xhr.send(formData)<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">4</span>.传递参数方式四: post -&gt; json<br>xhr.open(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;http://123.207.32.32:1888/02_param/postjson&quot;</span>)<br>xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>xhr.send(JSON.stringify(&#123;name: <span class="hljs-string">&quot;why&quot;</span>, age: <span class="hljs-number">18</span>, height: <span class="hljs-number">1.88</span>&#125;))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS网络请求协议</title>
    <link href="/2022/08/14/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/08/14/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h2><ul><li><p>什么是HTTP呢？我们来看一下维基百科的解释</p><ul><li>超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议；</li><li> HTTP是万维网的数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法；</li><li> 通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识；</li></ul></li><li><p>HTTP是一个客户端（用户）和服务端（网站）之间请求和响应的标准。</p><ul><li>通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）；<ul><li>✓ 我们称这个客户端为用户代理程序（user agent）；</li></ul></li><li> 响应的服务器上存储着一些资源，比如HTML文件和图像。 </li><li>✓ 我们称这个响应服务器为源服务器（origin server）；</li></ul></li></ul><h2 id="HTTP的组成"><a href="#HTTP的组成" class="headerlink" title="HTTP的组成"></a>HTTP的组成</h2><ul><li>一次HTTP请求主要包括：请求（Request）和响应（Response）</li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\HTTP R.png)</p><h2 id="HTTP的请求方式"><a href="#HTTP的请求方式" class="headerlink" title="HTTP的请求方式"></a>HTTP的请求方式</h2><ul><li><p> GET：GET 方法请求一个指定资源的表示形式，使用 GET 的请求应该只被用于获取数据。</p></li><li><p> HEAD：HEAD 方法请求一个与 GET 请求的响应相同的响应，但没有响应体。 ✓ 比如在准备下载一个文件前，先获取文件的大小，再决定是否进行下载；  POST：POST 方法用于将实体提交到指定的资源。</p></li><li><p> PUT：PUT 方法用请求有效载荷（payload）替换目标资源的所有当前表示；</p></li><li><p> DELETE：DELETE 方法删除指定的资源；</p></li><li><p> PATCH：PATCH 方法用于对资源应部分修改；</p></li><li><p> CONNECT：CONNECT 方法建立一个到目标资源标识的服务器的隧道，通常用在代理服务器，网页开发很少用到。</p></li><li><p> TRACE：TRACE 方法沿着到目标资源的路径执行一个消息环回测试。</p></li><li><p>一般都是GET和HEAD方法</p></li></ul><h2 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h2><h3 id="content-type是这次请求携带的数据的类型："><a href="#content-type是这次请求携带的数据的类型：" class="headerlink" title="content-type是这次请求携带的数据的类型："></a>content-type是这次请求携带的数据的类型：</h3><ul><li> application&#x2F;x-www-form-urlencoded：表示数据被编码成以 ‘&amp;’ 分隔的键 - 值对，同时以 ‘&#x3D;’ 分隔键和值 </li><li> application&#x2F;json：表示是一个json类型； </li><li> text&#x2F;plain：表示是文本类型； </li><li> application&#x2F;xml：表示是xml类型；</li><li> multipart&#x2F;form-data：表示是上传文件；</li></ul><h3 id="content-length：文件的大小长度"><a href="#content-length：文件的大小长度" class="headerlink" title="content-length：文件的大小长度"></a>content-length：文件的大小长度</h3><h2 id="HTTP请求头响应状态码"><a href="#HTTP请求头响应状态码" class="headerlink" title="HTTP请求头响应状态码"></a>HTTP请求头响应状态码</h2><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\HTTP code.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前后端分离</title>
    <link href="/2022/08/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    <url>/2022/08/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="◼-早期的网页都是通过后端渲染来完成的：服务器端渲染（SSR，server-side-render）："><a href="#◼-早期的网页都是通过后端渲染来完成的：服务器端渲染（SSR，server-side-render）：" class="headerlink" title="◼ 早期的网页都是通过后端渲染来完成的：服务器端渲染（SSR，server side render）："></a>◼ 早期的网页都是通过后端渲染来完成的：服务器端渲染（SSR，server side render）：</h3><ul><li>客户端发出请求 -&gt; 服务端接收请求并返回相应HTML文档 -&gt; 页面刷新，客户端加载新的HTML文档；</li></ul><h3 id="服务器端渲染的缺点："><a href="#服务器端渲染的缺点：" class="headerlink" title="服务器端渲染的缺点："></a>服务器端渲染的缺点：</h3><ul><li>当用户点击页面中的某个按钮向服务器发送请求时，页面本质上只是一些数据发生了变化，而此时服务器却要将重绘的整个页面再返 回给浏览器加载，这显然有悖于程序员的“DRY（ Don‘t repeat yourself ）”原则；</li><li>而且明明只是一些数据的变化却迫使服务器要返回整个HTML文档，这本身也会给网络带宽带来不必要的开销。</li></ul><h3 id="有没有办法在页面数据变动时，只向服务器请求新的数据，并且在阻止页面刷新的情况下，动态的替换页面中展示的数据呢？"><a href="#有没有办法在页面数据变动时，只向服务器请求新的数据，并且在阻止页面刷新的情况下，动态的替换页面中展示的数据呢？" class="headerlink" title="有没有办法在页面数据变动时，只向服务器请求新的数据，并且在阻止页面刷新的情况下，动态的替换页面中展示的数据呢？"></a>有没有办法在页面数据变动时，只向服务器请求新的数据，并且在阻止页面刷新的情况下，动态的替换页面中展示的数据呢？</h3><h3 id="答案正是“AJAX”。"><a href="#答案正是“AJAX”。" class="headerlink" title="答案正是“AJAX”。"></a>答案正是“AJAX”。</h3><h3 id="AJAX是“Asynchronous-JavaScript-And-XML”的缩写-异步的JavaScript和XML-，是一种实现-无页面刷新-获取服务器数据的技术。"><a href="#AJAX是“Asynchronous-JavaScript-And-XML”的缩写-异步的JavaScript和XML-，是一种实现-无页面刷新-获取服务器数据的技术。" class="headerlink" title="AJAX是“Asynchronous JavaScript And XML”的缩写(异步的JavaScript和XML)，是一种实现 无页面刷新 获取服务器数据的技术。"></a>AJAX是“Asynchronous JavaScript And XML”的缩写(异步的JavaScript和XML)，是一种实现 无页面刷新 获取服务器数据的技术。</h3><ul><li> AJAX最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</li></ul><h3 id="你可以使用AJAX最主要的两个特性做下列事："><a href="#你可以使用AJAX最主要的两个特性做下列事：" class="headerlink" title="你可以使用AJAX最主要的两个特性做下列事："></a>你可以使用AJAX最主要的两个特性做下列事：</h3><ul><li>在不重新加载页面的情况下发送请求给服务器；</li><li>接受并使用从服务器发来的数据。</li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Web Render.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>history</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS事件总线</title>
    <link href="/2022/08/14/JS%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
    <url>/2022/08/14/JS%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>负责组件通信的工具</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HYEventBus</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span> = &#123;&#125;<br>  &#125;<br><br>  <span class="hljs-title function_">on</span>(<span class="hljs-params">eventName, eventFn</span>) &#123;  <span class="hljs-comment">//监听方法</span><br>    <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]<br>    <span class="hljs-keyword">if</span> (!eventFns) &#123;<br>      eventFns = []<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName] = eventFns<br>    &#125;<br>    eventFns.<span class="hljs-title function_">push</span>(eventFn)<br>  &#125;<br>  <br>  <span class="hljs-title function_">off</span>(<span class="hljs-params">eventName, eventFn</span>) &#123;   <span class="hljs-comment">//取消监听</span><br>    <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]<br>    <span class="hljs-keyword">if</span> (!eventFns) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; eventFns.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> fn = eventFns[i]<br>      <span class="hljs-keyword">if</span> (fn === eventFn) &#123;<br>        eventFns.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">break</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果eventFns已经清空了</span><br>    <span class="hljs-keyword">if</span> (eventFns.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">eventName, ...args</span>) &#123;   <span class="hljs-comment">//发射方法</span><br>    <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]<br>    <span class="hljs-keyword">if</span> (!eventFns) <span class="hljs-keyword">return</span><br>    eventFns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>(...args)<br>    &#125;)<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 使用过程</span><br><span class="hljs-keyword">const</span> eventBus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HYEventBus</span>()<br><br><span class="hljs-comment">// aside.vue组件中监听事件</span><br>eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;navclick&quot;</span>, <span class="hljs-function">(<span class="hljs-params">name, age, height</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;navclick listener 01&quot;</span>, name, age, height)<br>&#125;)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">click</span> =  (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;navclick listener 02&quot;</span>)<br>&#125;<br>eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;navclick&quot;</span>, click)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  eventBus.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;navclick&quot;</span>, click)<br>&#125;, <span class="hljs-number">5000</span>);<br><br>eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;asideclick&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;asideclick listener&quot;</span>)<br>&#125;)<br><br><br><span class="hljs-comment">// nav.vue</span><br><span class="hljs-keyword">const</span> navBtnEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.nav-btn&quot;</span>)<br>navBtnEl.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;自己监听到&quot;</span>)<br>  eventBus.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;navclick&quot;</span>, <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS判断是否对象的封装</title>
    <link href="/2022/08/13/JS%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <url>/2022/08/13/JS%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> isObject(<span class="hljs-keyword">value</span>) &#123;<br>  // <span class="hljs-keyword">null</span>,<span class="hljs-keyword">object</span>,<span class="hljs-keyword">function</span>,<span class="hljs-keyword">array</span><br>  // <span class="hljs-keyword">null</span> -&gt; <span class="hljs-keyword">object</span><br>  // <span class="hljs-keyword">function</span> -&gt; <span class="hljs-keyword">function</span> -&gt; <span class="hljs-keyword">true</span><br>  // <span class="hljs-keyword">object</span>/<span class="hljs-keyword">array</span> -&gt; <span class="hljs-keyword">object</span> -&gt; <span class="hljs-keyword">true</span><br>  const valueType = typeof <span class="hljs-keyword">value</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">value</span> !== <span class="hljs-keyword">null</span>) &amp;&amp; ( valueType === &quot;object&quot; || valueType === &quot;function&quot; )<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>小工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS浅拷贝深拷贝</title>
    <link href="/2022/08/13/JS%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/08/13/JS%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>只是浅层的拷贝，内部引入对象时，依然会相互影响；</p></li><li><pre><code class="hljs">    const obj2 = &#123; ...info &#125;    obj2.name = &quot;james&quot;  //展开运算符    obj2.friend.name = &quot;james&quot;    console.log(info.friend.name)<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><br>- 会将info里面得内容拷贝到obj2里面，obj2改变值时info不改变。但是如果是改变拷贝过来得函数得话，info里面得也会改变。因为拷贝过来的函数只是内存地址<br><br><br><br><span class="hljs-meta">## 深拷贝</span><br><br>- 拷贝过来之后和拷贝对象没有关系。改变里面的任何值拷贝对象也不会被改变<br>- JS中没有可以直接深拷贝的方法，因为太消耗资源了。而且用的地方也不多。<br><br><span class="hljs-meta">### 实现</span><br><br>- 可以遍历对象中的数据，当遇到对象类型的时再对其进行遍历。这样的话递归是比较合适的<br><br>- ```<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepcopy</span></span>(value) &#123;<br>        <span class="hljs-comment">// 1.如果是原始类型, 直接返回</span><br>    <span class="hljs-keyword">if</span>(!isObject(value)) &#123;<br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  <br>  <span class="hljs-comment">// 2.如果是对象类型, 才需要创建对象</span><br>    const <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span> = &#123;&#125;<br>    <span class="hljs-keyword">for</span> (const key <span class="hljs-keyword">in</span> value)&#123;<br>      <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>[key] = deepcopy(value[key])<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span><br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>当传入一个数组时，依旧输出一个对象。这是我们不想看到的。</p></li><li><p>可是typeof无法判断出时对象还是数组</p></li><li><p>还有一个方法is.Array</p></li><li><pre><code class="hljs">const newObj = Array.isArray(originValue) ? []: &#123;&#125;<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><br><span class="hljs-meta">### 其他情况</span><br><br>- 遇到<span class="hljs-keyword">set</span>类型时无法正常拷贝，因为其不支持<span class="hljs-keyword">for</span> <span class="hljs-keyword">in</span>方法  <span class="hljs-comment">//set是啥来着</span><br><br>- ```<br>       <span class="hljs-keyword">if</span> (typeof originValue === <span class="hljs-string">&quot;symbol&quot;</span>) &#123;<br>          <span class="hljs-keyword">return</span> Symbol(originValue.description)<br>        &#125;<br>  <span class="hljs-keyword">if</span> (originValue instanceof Set) &#123;<br>          const <span class="hljs-keyword">new</span><span class="hljs-type">Set</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Set</span>()<br>          <span class="hljs-keyword">for</span> (const setItem of originValue) &#123;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Set</span>.add(deepCopy(setItem))<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Set</span><br>        &#125;<br>        <span class="hljs-comment">// 单独遍历symbol</span><br>        const symbolKeys = Object.getOwnPropertySymbols(originValue)<br>        <span class="hljs-keyword">for</span> (const symbolKey of symbolKeys) &#123;<br>          <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>[Symbol(symbolKey.description)] = deepCopy(originValue[symbolKey])<br>        &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li></li><li><p>遇到symbol时因为其特殊性所以要加   &#x2F;&#x2F;什么特殊性我忘了</p></li><li><pre><code class="hljs">     if (typeof originValue === &quot;symbol&quot;) &#123;        return Symbol(originValue.description)      &#125;</code></pre></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS防抖</title>
    <link href="/2022/08/13/JS%E9%98%B2%E6%8A%96/"/>
    <url>/2022/08/13/JS%E9%98%B2%E6%8A%96/</url>
    
    <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ul><li>当事件触发时，相应的函数并不会立即触发，而是会等待一定的时间；</li><li>当事件密集触发时，函数的触发会被频繁的推迟；</li><li>只有等待了一段时间也没有事件触发，才会真正的执行响应函数；</li></ul><h3 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hydebounce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-comment">// 1.用于记录上一次事件触发的timer</span><br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br><br>  <span class="hljs-comment">// 2.触发事件时执行的函数</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">_debounce</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 2.1.如果有再次触发(更多次触发)事件, 那么取消上一次的事件</span><br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br><br>    <span class="hljs-comment">// 2.2.延迟去执行对应的fn函数(传入的回调函数)</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>()<br>      timer = <span class="hljs-literal">null</span> <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span><br>    &#125;, delay);<br>  &#125;<br><br>  <span class="hljs-comment">// 返回一个新的函数</span><br>  <span class="hljs-keyword">return</span> _debounce<br>&#125;  <span class="hljs-comment">//里面的this指定了window，因为上面执行的函数是独立执行函数</span><br></code></pre></td></tr></table></figure><ul><li><p>要绑定this不能直接给fn指定this，因为timer和_debounce都是箭头函数，所以会直接指向hydebounce。可hydebounce是独立函数调用。因为oninput<strong>绑定的是hydebounce的返回值</strong>。所以我们想绑定this，得让this指向_debounce。</p></li><li><p>所以只要将_debounce设为普通函数就可以了</p></li><li><p><code>const _debounce = function() &#123;&#125;</code></p></li></ul><h3 id="取消执行"><a href="#取消执行" class="headerlink" title="取消执行"></a>取消执行</h3><ul><li>因为是延时器执行，所以当页面返回时也会执行。这时候我们就需要取消功能</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"> <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>.给_debounce绑定一个取消的函数 <span class="hljs-regexp">//</span>在hydebounce里面<br>  _debounce.cancel = <span class="hljs-keyword">function</span>() &#123;<br>    <span class="hljs-keyword">if</span> (timer) clearTimeout(timer)<br>    &#125;<br>    <br>    <br> <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>.实现取消的功能<br>cancelBtn.onclick = <span class="hljs-keyword">function</span>() &#123;<br>  debounceFn.cancel()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>如果这个事件会被频繁触发，那么节流函数会按照一定的频率来执行函数；</li><li>定义最小运行间隔</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS异步处理</title>
    <link href="/2022/08/11/JS%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    <url>/2022/08/11/JS%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>延迟获取的值无法用return返回，所以需要异步处理来获取</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs awk"> <span class="hljs-keyword">function</span> requestData(url) &#123;<br>  return new Promise((resolve, reject) =&gt; &#123;<br>    setTimeout(() =&gt; &#123;<br>      resolve(url)<br>    &#125;, <span class="hljs-number">2000</span>)<br>  &#125;)<br>&#125;   <br>需求: <br>    <span class="hljs-number">1</span>.发送一次网络请求, 等到这次网络请求的结果<br>    <span class="hljs-number">2</span>.发送第二次网络请求, 等待这次网络请求的结果<br>    <span class="hljs-number">3</span>.发送第三次网络请求, 等待这次网络请求的结果<br>*/<br><span class="hljs-regexp">//</span> 方式一: 层层嵌套(回调地狱 callback hell)<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span> getData() &#123;<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>.第一次请求<br><span class="hljs-regexp">//</span>   requestData(<span class="hljs-string">&quot;why&quot;</span>).then(res1 =&gt; &#123;<br><span class="hljs-regexp">//</span>     console.log(<span class="hljs-string">&quot;第一次结果:&quot;</span>, res1)<br><br><span class="hljs-regexp">//</span>     <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>.第二次请求<br><span class="hljs-regexp">//</span>     requestData(res1 + <span class="hljs-string">&quot;kobe&quot;</span>).then(res2 =&gt; &#123;<br><span class="hljs-regexp">//</span>       console.log(<span class="hljs-string">&quot;第二次结果:&quot;</span>, res2)<br><br><span class="hljs-regexp">//</span>       <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>.第三次请求<br><span class="hljs-regexp">//</span>       requestData(res2 + <span class="hljs-string">&quot;james&quot;</span>).then(res3 =&gt; &#123;<br><span class="hljs-regexp">//</span>         console.log(<span class="hljs-string">&quot;第三次结果:&quot;</span>, res3)<br><span class="hljs-regexp">//</span>       &#125;)<br><span class="hljs-regexp">//</span>     &#125;)<br><span class="hljs-regexp">//</span>   &#125;)<br><span class="hljs-regexp">//</span> &#125;<br><br><span class="hljs-regexp">//</span> 方式二: 使用Promise进行重构(解决回调地狱)<br><span class="hljs-regexp">//</span> 链式调用<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span> getData() &#123;<br><span class="hljs-regexp">//</span>   requestData(<span class="hljs-string">&quot;why&quot;</span>).then(res1 =&gt; &#123;<br><span class="hljs-regexp">//</span>     console.log(<span class="hljs-string">&quot;第一次结果:&quot;</span>, res1)<br><span class="hljs-regexp">//</span>     return requestData(res1 + <span class="hljs-string">&quot;kobe&quot;</span>)<br><span class="hljs-regexp">//</span>   &#125;).then(res2 =&gt; &#123;<br><span class="hljs-regexp">//</span>     console.log(<span class="hljs-string">&quot;第二次结果:&quot;</span>, res2)<br><span class="hljs-regexp">//</span>     return requestData(res2 + <span class="hljs-string">&quot;james&quot;</span>)<br><span class="hljs-regexp">//</span>   &#125;).then(res3 =&gt; &#123;<br><span class="hljs-regexp">//</span>     console.log(<span class="hljs-string">&quot;第三次结果:&quot;</span>, res3)<br><span class="hljs-regexp">//</span>   &#125;)<br><span class="hljs-regexp">//</span> &#125;<br></code></pre></td></tr></table></figure><ul><li><p>上面第一个没有第二个优雅，因为第一个是属于调用，就是一层层嵌套，而第二个只是返回了新的promise，属于链式调用。</p></li><li><p>而第二种看着结构不够清晰，我们可以用生成器来进行进一步简化</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span>* getData() &#123;  <span class="hljs-regexp">//</span>*是生成器的标志<br> <span class="hljs-regexp">//</span>   const res1 = yield requestData(<span class="hljs-string">&quot;why&quot;</span>)<br> <span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&quot;res1:&quot;</span>, res1)<br>  <br> <span class="hljs-regexp">//</span>   const res2 = yield requestData(res1 + <span class="hljs-string">&quot;kobe&quot;</span>)<br> <span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&quot;res2:&quot;</span>, res2)<br>  <br> <span class="hljs-regexp">//</span>   const res3 = yield requestData(res2 + <span class="hljs-string">&quot;james&quot;</span>)<br> <span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&quot;res3:&quot;</span>, res3)<br> <span class="hljs-regexp">//</span> &#125;<br>  <br> <span class="hljs-regexp">//</span> const generator = getData()<br> <span class="hljs-regexp">//</span> generator.<span class="hljs-keyword">next</span>().value.then(res1 =&gt; &#123;  <span class="hljs-regexp">//yi</span>eld返回一个对象，value是yield后面的值<br> <span class="hljs-regexp">//</span>   generator.<span class="hljs-keyword">next</span>(res1).value.then(res2 =&gt; &#123;<br> <span class="hljs-regexp">//</span>     generator.<span class="hljs-keyword">next</span>(res2).value.then(res3 =&gt; &#123;<br> <span class="hljs-regexp">//</span>       generator.<span class="hljs-keyword">next</span>(res3)<br> <span class="hljs-regexp">//</span>     &#125;)<br> <span class="hljs-regexp">//</span>   &#125;)<br> <span class="hljs-regexp">//</span> &#125;)<br></code></pre></td></tr></table></figure></li><li><p>这样的话看着就清晰多了，但感觉只是清晰了，我们可以看看有没有更好的办法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestData</span>(<span class="hljs-string">&quot;why&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res1:&quot;</span>, res1)<br>  <br>  <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestData</span>(res1 + <span class="hljs-string">&quot;kobe&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res2:&quot;</span>, res2)<br>  <br>  <span class="hljs-keyword">const</span> res3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestData</span>(res2 + <span class="hljs-string">&quot;james&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res3:&quot;</span>, res3)<br>&#125;<br>  <br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">getData</span>()<br></code></pre></td></tr></table></figure></li><li><p>async和await是生成器的语法糖，使用了语法糖后的代码太优雅。太简洁了。这就是代码的艺术嘛</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS迭代器</title>
    <link href="/2022/08/10/JS%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2022/08/10/JS%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h2><ul><li>迭代器（iterator），使用户在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。</li><li>主要还是可以用foreach方法，展开语法，解构对象</li></ul><h3 id="中断（少用）"><a href="#中断（少用）" class="headerlink" title="中断（少用）"></a>中断（少用）</h3><ul><li>迭代器在某些情况下会在没有完全迭代的情况下中断：<ul><li>比如遍历的过程中通过break、return、throw中断了循环操作；</li><li>比如在解构的时候，没有解构所有的值；</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">  [Symbol.iterator]() &#123;<br>    let index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">const</span> iterator = &#123;<br>      next: () =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-keyword">this</span>.friends.length) &#123;<br>          <span class="hljs-keyword">return</span> &#123; done: <span class="hljs-literal">false</span>, value: <span class="hljs-keyword">this</span>.friends[index++] &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123; done: <span class="hljs-literal">true</span> &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-keyword">return</span>: () =&gt; &#123;<br>        console.log(<span class="hljs-string">&quot;监听到迭代器中断了&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123; done: <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">//不写返回undefined会报错</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> iterator<br>  &#125; <span class="hljs-comment">//在Person类里面编写</span><br>  <br>  <span class="hljs-keyword">const</span> p1 = new Person(<span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>, [<span class="hljs-string">&quot;curry&quot;</span>, <span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-string">&quot;james&quot;</span>, <span class="hljs-string">&quot;tatumu&quot;</span>])<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item of p1) &#123;<br>  console.log(item)<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-string">&quot;kobe&quot;</span>) &#123;<br>    <span class="hljs-keyword">break</span><br>  &#125;<br>&#125; <span class="hljs-comment">//可以监听到</span><br></code></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul><li>生成器是ES6中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><ul><li>首先，生成器函数需要在function的后面加一个符号：*</li><li>其次，生成器函数可以通过yield关键字来控制函数的执行流程：</li><li>最后，生成器函数的返回值是一个Generator（生成器）：<ul><li>生成器事实上是一种特殊的迭代器；</li></ul></li></ul></li><li><p>调用生成器时不会执行函数，而是返回一个生成器对象</p></li><li><p>想要让生成器函数执行需要调用next</p></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 1.定义了一个生成器函数</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;1111&quot;</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;2222&quot;</span>)<br>  yield<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;3333&quot;</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;4444&quot;</span>)<br>  yield<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;5555&quot;</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;6666&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 2.调用生成器函数, 返回一个 生成器对象</span><br>const generator = foo()<br><span class="hljs-comment">// 调用next方法</span><br>generator.next() <span class="hljs-comment">//执行函数直到遇到yield</span><br>generator.next()<br>generator.next()<br></code></pre></td></tr></table></figure><ul><li>yield会返回其后面的值</li><li><code> yield &quot;aaa&quot;</code> 执行next时</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS代理</title>
    <link href="/2022/08/09/JS%E4%BB%A3%E7%90%86/"/>
    <url>/2022/08/09/JS%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><ul><li>施工中</li></ul><h3 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h3><ul><li>就是属性改变时，我们可以获取到其改变及其改变的值</li><li>ES5</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> keys) &#123;<br>  <span class="hljs-keyword">let</span> value = obj[key]<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 给<span class="hljs-subst">$&#123;key&#125;</span>设置了新的值:`</span>, newValue)<br>      value = newValue<br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 获取<span class="hljs-subst">$&#123;key&#125;</span>的值`</span>)<br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>我们可以看到，这样很麻烦</p></li><li><p>其次，如果我们想监听更加丰富的操作，比如新增属性、删除属性，那么 Object.defineProperty是无能为力的。</p></li><li><p>因为Object.defineProperty设计的初衷，不是为了去监听截止一个对象中 所有的属性的。</p></li></ul><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><ul><li><p>在ES6中，新增了一个Proxy类，这个类从名字就可以看出来，是用于帮助我们创建一个代理的：</p></li><li><p>首先，我们需要new Proxy对象，并且传入需要侦听的对象以及一个处理对象，可以称之为handler；</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Proxy(<span class="hljs-keyword">target</span>, <span class="hljs-keyword">handler</span>)<br></code></pre></td></tr></table></figure></li><li><p>其次，我们之后的操作都是直接对Proxy的操作，而不是原有的对象，因为我们需要在handler里面进行侦听；</p></li><li><p>如果我们想要侦听某些具体的操作，那么就可以在handler中添加对应的捕捉器（Trap）：</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解构</title>
    <link href="/2022/08/06/%E8%A7%A3%E6%9E%84/"/>
    <url>/2022/08/06/%E8%A7%A3%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="解构Destructuring"><a href="#解构Destructuring" class="headerlink" title="解构Destructuring"></a>解构<strong>Destructuring</strong></h2><ul><li><p><strong>解构赋值</strong> 是一种特殊的语法，它使我们可以将数组或对象“拆包”至一系列变量中。</p></li><li><p>拆分对象内容</p></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> names = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;cba&quot;</span>, undefined, <span class="hljs-string">&quot;nba&quot;</span>, <span class="hljs-string">&quot;mba&quot;</span>]</span><br><span class="hljs-selector-tag">var</span> obj = &#123; name: <span class="hljs-string">&#x27;why&#x27;</span>, age: <span class="hljs-number">18</span>, <span class="hljs-attribute">height</span>: <span class="hljs-number">1.88</span> &#125;<br> <span class="hljs-comment">// 1.数组的解构 没使用</span><br> <span class="hljs-selector-tag">var</span> name1 = names<span class="hljs-selector-attr">[0]</span><br> <span class="hljs-selector-tag">var</span> name2 = names<span class="hljs-selector-attr">[1]</span><br> <span class="hljs-selector-tag">var</span> name3 = names<span class="hljs-selector-attr">[2]</span><br> <br> <span class="hljs-comment">//使用解构</span><br> <span class="hljs-selector-tag">var</span> <span class="hljs-selector-attr">[name1, name2, name3]</span> = names<br> <br> <span class="hljs-comment">//对象的解构</span><br> <span class="hljs-selector-tag">var</span> &#123; name, age, <span class="hljs-attribute">height</span> &#125; = obj<br> <br> <span class="hljs-comment">//1.3. 解构出数组</span><br> <span class="hljs-selector-tag">var</span> <span class="hljs-selector-attr">[name1, name2, ...newNames]</span> = names<br> console<span class="hljs-selector-class">.log</span>(name1, name2, newNames)<br> <br> <span class="hljs-comment">// 1.4. 解构的默认值</span><br> <span class="hljs-selector-tag">var</span> <span class="hljs-selector-attr">[name1, name2, name3 = <span class="hljs-string">&quot;default&quot;</span>]</span> = names<br> console<span class="hljs-selector-class">.log</span>(name1, name2, name3)<br></code></pre></td></tr></table></figure><ul><li>解构数组时要有严格的顺序</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">var [<span class="hljs-symbol">name1</span>, , <span class="hljs-symbol">name3</span>] = <span class="hljs-symbol">names</span><br></code></pre></td></tr></table></figure><ul><li>获取第一个和第三个数组值时，第二个不能忽略，要留个空</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字面量增强</title>
    <link href="/2022/08/06/%E5%AD%97%E9%9D%A2%E9%87%8F%E5%A2%9E%E5%BC%BA/"/>
    <url>/2022/08/06/%E5%AD%97%E9%9D%A2%E9%87%8F%E5%A2%9E%E5%BC%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="对象字面量增强"><a href="#对象字面量增强" class="headerlink" title="对象字面量增强"></a>对象字面量增强</h2><h3 id="属性的增强"><a href="#属性的增强" class="headerlink" title="属性的增强"></a>属性的增强</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;s&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">4</span><br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  name, <span class="hljs-comment">//name: name</span><br>  age <span class="hljs-comment">//age: age</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法的增强"><a href="#方法的增强" class="headerlink" title="方法的增强"></a>方法的增强</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  name,<br>  age,<br>  <span class="hljs-attr">running</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  &#125;,<br>  <span class="hljs-title function_">swimming</span>(<span class="hljs-params"></span>) &#123; &#125; <span class="hljs-comment">//有this，增强</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计算属性的增强"><a href="#计算属性的增强" class="headerlink" title="计算属性的增强"></a>计算属性的增强</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> key = <span class="hljs-string">&#x27;address&#x27;</span><br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  name,<br>  age,<br>  <span class="hljs-attr">running</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>  <span class="hljs-title function_">swimming</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>  <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;广州&#x27;</span>,<br>  [key]:<span class="hljs-string">&#x27;广州&#x27;</span> <span class="hljs-comment">//可以引入外部变量</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS多态</title>
    <link href="/2022/08/06/JS%E5%A4%9A%E6%80%81/"/>
    <url>/2022/08/06/JS%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="wiki"><a href="#wiki" class="headerlink" title="wiki"></a>wiki</h2><ul><li>维基百科对多态的定义：<strong>多态</strong>（英语：polymorphism）指为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型。</li></ul><h2 id="存在条件"><a href="#存在条件" class="headerlink" title="存在条件"></a>存在条件</h2><ul><li>必须有继承</li><li>父类引用指向子类对象</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>))<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;nhc&#x27;</span>))<br></code></pre></td></tr></table></figure><ul><li>这算多态，有单一符号表示多个不同类型（继承？）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS闭包</title>
    <link href="/2022/08/05/JS%E9%97%AD%E5%8C%85/"/>
    <url>/2022/08/05/JS%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="MDN解释"><a href="#MDN解释" class="headerlink" title="MDN解释"></a>MDN解释</h3><ul><li><p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）；</p></li><li><p>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；</p></li><li><p>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；</p></li></ul><h3 id="Feel"><a href="#Feel" class="headerlink" title="Feel"></a>Feel</h3><ul><li>感觉你只要在函数中访问了作用域链，那么你就使用了闭包</li><li>从广义的角度来说：JavaScript中的函数都是闭包；</li><li>从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包；</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>请理解作用域链</li><li>还有内存泄漏的问题，主要是影响性能。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS原型</title>
    <link href="/2022/08/05/JS%E5%8E%9F%E5%9E%8B/"/>
    <url>/2022/08/05/JS%E5%8E%9F%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS执行原理</title>
    <link href="/2022/08/03/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <url>/2022/08/03/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="代码执行过程"><a href="#代码执行过程" class="headerlink" title="代码执行过程"></a>代码执行过程</h2><h3 id="初始化全局对象"><a href="#初始化全局对象" class="headerlink" title="初始化全局对象"></a>初始化全局对象</h3><ul><li>js引擎会在执行代码之前，会在<strong>堆</strong>内存中创建一个<strong>全局对象</strong>：Global Object（GO）<ul><li>该对象所有的作用域（scope）都可以访问；</li><li>里面会包含Date、Array、String、Number、setTimeout、setInterval等等；</li><li>其中还有一个window属性指向自己； &#x2F;&#x2F;window居然是属性嘛</li></ul></li></ul><h3 id="执行上下文（-Execution-Contexts-）"><a href="#执行上下文（-Execution-Contexts-）" class="headerlink" title="执行上下文（ Execution Contexts ）"></a>执行上下文（ Execution Contexts ）</h3><ul><li><p>他是执行代码的调用<strong>栈</strong></p></li><li><p>栈是执行代码的地方，堆是存放内存的地方</p></li><li><p>在栈的最底层是GO：Global Object；</p></li><li><p>在执行函数（fn）时，函数会创建一个新的对象，然后入栈，执行完毕后会出栈。</p></li><li><p>栈 先入后出</p></li><li><p>或许作用域链跟栈结构息息相关</p></li></ul><h3 id="VO对象（Variable-Object）"><a href="#VO对象（Variable-Object）" class="headerlink" title="VO对象（Variable Object）"></a>VO对象（Variable Object）</h3><ul><li><p>每一个执行上下文会关联一个VO（Variable Object，变量对象），变量和函数声明会被添加到这个VO对象中。</p></li><li><p>每一个函数调用时都会创建一个AO，与GO相对应。GO是全局，AO是函数个体。</p></li></ul><h3 id="作用域和作用域链（Scope-Chain）"><a href="#作用域和作用域链（Scope-Chain）" class="headerlink" title="作用域和作用域链（Scope Chain）"></a>作用域和作用域链（Scope Chain）</h3><ul><li>当进入到一个执行上下文(栈)时，执行上下文也会关联一个作用域链（Scope Chain）<ul><li>作用域链是一个对象列表，用于变量标识符的求值；</li><li>当建立作用域链时，变量的指向久已被确定。即使之后在不同位置被调用，建立作用域链时指定的变量不变，函数内的值也不变</li></ul></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> message = <span class="hljs-string">&quot;Global Message&quot;</span><br>function <span class="hljs-built_in">foo</span>() &#123;<br>  console<span class="hljs-selector-class">.log</span>(message)<br>  <span class="hljs-selector-tag">var</span> message = <span class="hljs-string">&#x27;foo&#x27;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//undefind </span><br></code></pre></td></tr></table></figure><ul><li>需要message -&gt; 寻找自身 -&gt; 有 -&gt; 就不会去上层寻找</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> message = <span class="hljs-string">&quot;Global Message&quot;</span><br>function <span class="hljs-built_in">foo</span>() &#123;<br>  <span class="hljs-selector-tag">var</span> message = <span class="hljs-string">&#x27;foo&#x27;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><br><span class="hljs-selector-tag">var</span> obj = &#123;<br>  name: <span class="hljs-string">&quot;obj&quot;</span>,<br>  bar: <span class="hljs-built_in">function</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> message = <span class="hljs-string">&quot;bar message&quot;</span><br>    <span class="hljs-built_in">foo</span>() <span class="hljs-comment">//</span><br>  &#125;<br>&#125;<br><br>obj<span class="hljs-selector-class">.bar</span>() <span class="hljs-comment">//Global Message</span><br><br></code></pre></td></tr></table></figure><ul><li>我们看到 obj.bar()调用，会先寻找函数内有没有message，然后看看obj里有没有message找到了，这时候就是忽略了作用域链的规则，当定义（创建？）函数时，作用域链已被确定。</li><li>函数被定义时，作用域链已经确定，message指向的是第一个message</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> n = <span class="hljs-number">100</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(n)<br>  <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">200</span><br>&#125;<br>foo() <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><ul><li>在解析函数时，就直接把n提升了。遇到return是解析完后调用时的事。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染</title>
    <link href="/2022/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/"/>
    <url>/2022/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h2 id="网页解析"><a href="#网页解析" class="headerlink" title="网页解析"></a>网页解析</h2><h3 id="常用的浏览器内核"><a href="#常用的浏览器内核" class="headerlink" title="常用的浏览器内核"></a>常用的浏览器内核</h3><ul><li>Trident （ 三叉戟）：IE、360安全浏览器、搜狗高速浏览器、百度浏览器、UC浏览器；</li><li>Gecko（ 壁虎） ：Mozilla Firefox；  Presto（急板乐曲）-&gt; Blink （眨眼）：Opera</li><li>Webkit ：Safari、360极速浏览器、搜狗高速浏览器、移动端浏览器（Android、iOS）</li><li>Webkit -&gt; Blink ：Google Chrome，Edge</li></ul><h5 id="我们经常说的浏览器内核指的是浏览器的排版引擎："><a href="#我们经常说的浏览器内核指的是浏览器的排版引擎：" class="headerlink" title="我们经常说的浏览器内核指的是浏览器的排版引擎："></a>我们经常说的浏览器内核指的是浏览器的排版引擎：</h5><ul><li>排版引擎（layout engine），也称为浏览器引擎（browser engine）、页面渲染引擎（rendering engine）或样版引擎。</li><li>也就是一个网页下载下来后，就是由我们的渲染引擎来帮助我们解析的</li></ul><h4 id="渲染引擎在拿到一个页面后，如何解析整个页面并且最终呈现出我们的网页呢？"><a href="#渲染引擎在拿到一个页面后，如何解析整个页面并且最终呈现出我们的网页呢？" class="headerlink" title="渲染引擎在拿到一个页面后，如何解析整个页面并且最终呈现出我们的网页呢？"></a>渲染引擎在拿到一个页面后，如何解析整个页面并且最终呈现出我们的网页呢？</h4><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\DOM node.png)</p><ul><li>更详细</li></ul><p><img src="C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\DOMnodeMore.png"></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>在解析HTML文件时，会生成DOM Tree</p></li><li><p>如果遇到CSS的link元素，那么会由浏览器负责下载对应的CSS文件：不会停止解析</p></li><li><p>浏览器下载完CSS后，会生成CSSOM（CSS Object Model，CSS对象模型）</p></li><li><p>当有了DOM Tree和 CSSOM Tree后，就可以两个结合来构建Render Tree了</p></li><li><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Render Tree.png)</p></li><li><p>布局</p><ul><li>布局是确定呈现树中所有节点的宽度、高度和位置信息；</li></ul></li><li><p>绘制</p><ul><li>在绘制阶段，浏览器将布局阶段计算的每个frame转为屏幕上实际的像素点；</li><li>包括将元素的可见部分进行绘制，比如文本、颜色、边框、阴影、替换元素（比如img）</li></ul></li></ul><h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><ul><li><p>在布局后改变节点布局那就称为回流</p></li><li><p>引起</p><ul><li>比如DOM结构发生改变（添加新的节点或者移除节点）；</li><li>比如改变了布局（修改了width、height、padding、font-size等值） </li><li>比如窗口resize（修改了窗口的尺寸等）</li><li>比如调用getComputedStyle方法获取尺寸、位置信息；</li></ul></li><li><p>重绘</p><ul><li>和回流一样，再次绘制就是重绘</li><li>比如修改背景色、文字颜色、边框颜色、样式等；会引起重绘</li></ul></li></ul><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><ul><li>消耗性能</li><li>尽量避免</li><li>1.修改样式时尽量一次性修改  比如通过cssText修改，比如通过添加class修改 </li><li>◼ 2.尽量避免频繁的操作DOM </li><li> 我们可以在一个DocumentFragment或者父元素中 将要操作的DOM操作完成，再一次性的操作；</li><li>◼ 3.尽量避免通过getComputedStyle获取尺寸、位置等信 息；</li><li>◼ 4.对某些元素使用position的absolute或者fixed  并不是不会引起回流，而是开销相对较小，不会对 其他元素造成影响。</li></ul><h2 id="script元素和页面解析的关系"><a href="#script元素和页面解析的关系" class="headerlink" title="script元素和页面解析的关系"></a>script元素和页面解析的关系</h2><ul><li><p>事实上，浏览器在解析HTML的过程中，遇到了script元素是不能继续构建DOM树的；</p></li><li><p>它会停止继续构建，首先下载JavaScript代码，并且执行JavaScript的脚本；</p></li><li><p>只有等到JavaScript脚本执行结束后，才会继续解析HTML，构建DOM树；</p></li><li><p>这是因为JavaScript的作用之一就是操作DOM，并且可以修改DOM；</p></li><li><p>如果我们等到DOM树构建完成并且渲染再执行JavaScript，会造成严重的回流和重绘，影响页面的性能； </p></li><li><p>所以会在遇到script元素时，优先下载和执行JavaScript代码，再继续构建DOM树；</p></li></ul><h3 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h3><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><ul><li>defer 属性告诉浏览器不要等待脚本下载，而继续解析HTML，构建DOM Tree。</li><li>如果脚本提前下载好了，它会等待DOM Tree构建完成，在DOMContentLoaded事件之前先执行defer中的代码；</li><li>从某种角度来说，defer可以提高页面的性能，并且推荐放到head元素中；</li><li>注意：defer仅适用于外部脚本，对于script默认内容会被忽略。</li></ul><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><ul><li><p>async 特性与 defer 有些类似，它也能够让脚本不阻塞页面。</p></li><li><p>async脚本不能保证顺序，它是独立下载、独立运行，不会等待其他脚本；</p></li><li><p>async不会能保证在DOMContentLoaded之前或者之后执行；</p></li><li><p>async通常用于独立的脚本，对其他脚本，甚至DOM没有依赖的；</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高阶-this</title>
    <link href="/2022/07/31/JS%E9%AB%98%E9%98%B6-this/"/>
    <url>/2022/07/31/JS%E9%AB%98%E9%98%B6-this/</url>
    
    <content type="html"><![CDATA[<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ul><li>this是一个非常方便的工具。他非常的灵活，我们都知道，，越灵活表示他的规则我没越难掌握。</li><li>接下来让我们好好的去了解一下这个灵活的工具</li></ul><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><ul><li><p>我们定义一个函数，然后调用他，看看再此函数中定义的this指向哪</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;指向:&quot;</span>+this)<br> &#125;<br> foo() <span class="hljs-comment">///指向:[object Window]</span><br> <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">fn</span>) &#123;<br>   fn()<br> &#125;<br> <span class="hljs-keyword">var</span> bor = &#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>,<br>   <span class="hljs-attr">baz</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this)<br>   &#125;<br> &#125;<br> foo(bor.baz) <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><ul><li><p>再直接调用的情况下指向了window对象。那我们再看看其他情况</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var bor = &#123;<br>  <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>,<br>  foo<br>&#125;<br>  <br>bor.foo() //指向:[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br></code></pre></td></tr></table></figure></li><li><p>当他在对象中时，且使用对象.调用他时，他的指向变成了对象。</p></li><li><p>那么，还有其他的情况嘛</p></li></ul><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><ul><li><p>在JS中，还有一种方法，可以直接指定函数的this指向对象</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">foo.call(<span class="hljs-string">&#x27;dog&#x27;</span>) <span class="hljs-regexp">//</span>指向:dog<br></code></pre></td></tr></table></figure></li><li><p>call还有apply都可以指定this的指向</p></li><li><p>不同的是，他们可以传多个参数，第一个为指定this的指定。</p></li><li><p>而后面的就是传给函数的参数</p></li><li><p>apply为数组方式传递，而call为参数列表方式传递。</p></li></ul><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><ul><li>JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字</li><li>使用new关键字来调用函数时，会执行如下的操作：<ul><li> 1.创建一个全新的对象； </li><li> 2.这个新对象会被执行prototype连接；</li><li> 3.这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）；</li><li> 4.如果函数没有返回其他对象，表达式会返回这个新对象；</li></ul></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">   <span class="hljs-keyword">function</span> Person(<span class="hljs-type">name</span>) &#123;<br>     console.log(&quot;指向:&quot;+this)<br>     this.name = <span class="hljs-type">name</span><br>   &#125;<br>   var p = <span class="hljs-built_in">new</span> Person(<span class="hljs-string">&#x27;pan&#x27;</span>)<br>   console.log(p)<br>   <br>   指向:[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br>Person<br>       <span class="hljs-type">name</span>: &quot;pan&quot;<br>       __proto__: <span class="hljs-keyword">Object</span><br></code></pre></td></tr></table></figure><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li>过</li></ul><h3 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h3><ul><li><p>函数也是对象的一个属性，而没有绑定对象的函数则被绑定到window中。</p></li><li><p>而this是指向对象的。所以直接调用函数的情况下，函数没有被设置绑定那个对象，就被浏览器绑定到window中，这样this指向的就是window。</p></li></ul><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><ul><li>window是一个对象，window可以包含函数。</li><li>函数是对象的一个属性，函数要在对象中才能运行。</li><li>没有对象的函数会被挂靠在window中</li></ul><h4 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h4><ul><li>无</li></ul><h3 id="间接函数引用"><a href="#间接函数引用" class="headerlink" title="间接函数引用"></a>间接函数引用</h3><ul><li>赋值(obj2.foo &#x3D; obj1.foo)的结果是foo函数</li><li>foo函数被直接调用，那么是默认绑定；</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this)<br>&#125;<br><span class="hljs-keyword">var</span> bor = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br><span class="hljs-keyword">var</span> bor2 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;me&#x27;</span><br>&#125;<br>bor.foo(); <span class="hljs-comment">//bor</span><br>(bor2.foo = bor.foo)(); <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure><ul><li>主要还是有个括号</li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul><li><p>箭头函数是ES6之后增加的一种编写函数的方法，并且它比函数表达式要更加简洁：</p></li><li><p>他没有this属性，当在其中编写this属性时，会向上级作用域寻找。</p></li><li><p><strong>对象没有作用域，函数有</strong></p></li><li><p>但也因为它没有this属性，所以在一些地方的规则会不一样。</p></li><li><p>它不适用上面的四种规则，而是去外层作用域来决定this</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 编写<br>() =&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>看起来很简洁，很方便，也确实如此，只是在用this的地方要小心</p></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><p>如果只有一个参数可以省略()</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">nums.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure></li><li><p>如果函数执行体中只有一行代码，那么可以省略大括号</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">nums.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(item))<br>nums.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><ul><li>并且这行代码的返回值会作为整个函数的返回值</li></ul></li></ul><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade">   <span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-comment">//对象没有作用域</span><br>     name: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>     <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//外层作用域，因为是函数，所以有作用域</span><br>     <br>       <span class="hljs-keyword">var</span> bor = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-comment">//在外层作用域中寻找this</span><br>         <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;bar:&#x27;</span>, this)<br>       &#125;<br>       <span class="hljs-keyword">return</span> bor<br>     &#125;<br>     <br>   &#125;<br>   <span class="hljs-keyword">var</span> fn = obj.foo()<br>   fn.apply(<span class="hljs-string">&#x27;baa&#x27;</span>)<br>   <br>输出：<br>bar: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj&quot;</span>, <span class="hljs-attr">foo</span>: ƒ&#125;<br>       foo: ƒ ()<br>       name: <span class="hljs-string">&quot;obj&quot;</span><br>       __proto__: Object<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON</title>
    <link href="/2022/07/28/JSON/"/>
    <url>/2022/07/28/JSON/</url>
    
    <content type="html"><![CDATA[<h2 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h2><ul><li>JSON是一种数据格式</li><li>算是JavaScript的一个子集</li><li>目前已独立于编程语言，可以在各个编程语言中使用</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul><li>顶层不能放注释，支持下面三种类型的值</li><li>简单值：数字（Number）、字符串（String，不支持单引号）、布尔类型（Boolean）、null类型；</li><li>对象值：由key、value组成，key是字符串类型，并且必须添加双引号，值可以是简单值、对象值、数组值；</li><li>数组值：数组的值可以是简单值、对象值、数组值；</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul><li>将复杂的数据类似对象转换成JSON格式的字符串</li><li>在ES5中引用了JSON全局对象，该对象有两个常用的方法：</li><li> stringify方法：将JavaScript类型转成对应的JSON字符串；</li><li> parse方法：解析JSON字符串，转回对应的JavaScript类型；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS轮播图</title>
    <link href="/2022/07/27/JS%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
    <url>/2022/07/27/JS%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="只能触碰下面的导航来更换图片"><a href="#只能触碰下面的导航来更换图片" class="headerlink" title="只能触碰下面的导航来更换图片"></a>只能触碰下面的导航来更换图片</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> titleListEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.title-list&quot;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> activeItemEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.active&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> imageListEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.image-list&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    titleListEl.<span class="hljs-property">onmouseover</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> itemEl = event.<span class="hljs-property">target</span>.<span class="hljs-property">parentElement</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">if</span>(!itemEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;item&#x27;</span>)) <span class="hljs-keyword">return</span></span><br><span class="language-javascript">      </span><br><span class="language-javascript">      activeItemEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;active&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      itemEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      activeItemEl = itemEl</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; titleListEl.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (titleListEl.<span class="hljs-property">children</span>[i] == itemEl) <span class="hljs-keyword">break</span></span><br><span class="language-javascript">      &#125; <span class="hljs-comment">//感觉要用var有点难受</span></span><br><span class="language-javascript">      </span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> index = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(titleListEl.<span class="hljs-property">children</span>).<span class="hljs-title function_">findIndex</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> item === itemEl</span><br><span class="language-javascript">      &#125;) <span class="hljs-comment">//另一种获取索引的方法</span></span><br><span class="language-javascript">      </span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)</span><br><span class="language-javascript">      imageListEl.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translateX(<span class="hljs-subst">$&#123;-<span class="hljs-number">604</span> * i&#125;</span>px)`</span></span><br><span class="language-javascript">      imageListEl.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">`all 300ms ease`</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="添加定时器"><a href="#添加定时器" class="headerlink" title="添加定时器"></a>添加定时器</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> start<span class="hljs-constructor">Timer()</span> &#123;<br>  timerID = set<span class="hljs-constructor">Interval(<span class="hljs-params">function</span>()</span> &#123;<br>    currentIndex++<br>    <span class="hljs-keyword">if</span> (currentIndex<span class="hljs-operator"> === </span>titleListEl.children.length) &#123;<br>      currentIndex = <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// 调用切换的函数</span><br>    switch<span class="hljs-constructor">Banner()</span><br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;<br>clear<span class="hljs-constructor">Interval(<span class="hljs-params">timerID</span>)</span> <span class="hljs-comment">//清除定时器</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS导航栏切换</title>
    <link href="/2022/07/27/JS%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%88%87%E6%8D%A2/"/>
    <url>/2022/07/27/JS%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="7月27"><a href="#7月27" class="headerlink" title="7月27"></a>7月27</h2><ul><li><p>原本在用JS给导航栏添加active时，鼠标移出的时候思路都是添加一个移出事件。</p></li><li><p>但今天发现一个更方便的写法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 1.获取元素</span><br><span class="hljs-selector-tag">var</span> tabControl = document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&quot;.tab_control&quot;</span>)<br>  <br><span class="hljs-comment">// 2.监听鼠标进入(事件委托)</span><br><span class="hljs-selector-tag">var</span> activeLiEl = tabControl<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&quot;.active&quot;</span>)<br>tabControl<span class="hljs-selector-class">.onmouseover</span> = <span class="hljs-built_in">function</span>(event) &#123;<br>  <span class="hljs-comment">// 1.拿到事件发生的对象</span><br>  <span class="hljs-selector-tag">var</span> itemEl = event<span class="hljs-selector-class">.target</span><br>  <span class="hljs-keyword">if</span> (itemEl<span class="hljs-selector-class">.classList</span><span class="hljs-selector-class">.contains</span>(<span class="hljs-string">&quot;item&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 其他的取消active</span><br>    <span class="hljs-comment">// 1.for循环所有的item</span><br>    <span class="hljs-comment">// 2.querySelector(&quot;.active&quot;)</span><br>    <span class="hljs-comment">// 3.记录当前的active对应的item</span><br>    activeLiEl<span class="hljs-selector-class">.classList</span><span class="hljs-selector-class">.remove</span>(<span class="hljs-string">&quot;active&quot;</span>)<br>  <br>    <span class="hljs-comment">// 当前进入的item变成active</span><br>    itemEl<span class="hljs-selector-class">.classList</span><span class="hljs-selector-class">.add</span>(<span class="hljs-string">&quot;active&quot;</span>)<br>  <br>    <span class="hljs-comment">// 将最新的itemEl变成activeLiEl</span><br>    activeLiEl = itemEl<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在鼠标进入时给目标添加一个标记，当鼠标移入另一个导航栏时令标记的导航栏移除active</p></li><li><p>记得标记先在上面获取</p></li><li><p>简便的代码才是好代码</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS鼠标事件</title>
    <link href="/2022/07/26/JS%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6/"/>
    <url>/2022/07/26/JS%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="mouseover和mouseenter的区别"><a href="#mouseover和mouseenter的区别" class="headerlink" title="mouseover和mouseenter的区别"></a>mouseover和mouseenter的区别</h2><h3 id="mouseenter和mouseleave"><a href="#mouseenter和mouseleave" class="headerlink" title="mouseenter和mouseleave"></a>mouseenter和mouseleave</h3><ul><li>不支持冒泡</li><li>进入子元素依然属于该元素内</li></ul><h3 id="mouseover和mouseout"><a href="#mouseover和mouseout" class="headerlink" title="mouseover和mouseout"></a>mouseover和mouseout</h3><ul><li>支持冒泡</li><li>进入元素的子元素时</li><li><ul><li>先调用父元素的mouseout</li><li>在调用子元素的mouseover</li><li>因为支持冒泡，所以mouseover传递到父元素中</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS事件委托</title>
    <link href="/2022/07/25/JS%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <url>/2022/07/25/JS%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡和捕获"><a href="#冒泡和捕获" class="headerlink" title="冒泡和捕获"></a>冒泡和捕获</h2><ul><li>在监听一个元素时，比如点击事件，监听一个大盒子的点击事件，里面的元素也可以被监听点击事件。</li><li>当你点击里面的元素时，事件的触发顺序是从外到里还是从里到外呢？</li></ul><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><ul><li>◼ 事实上对于事件有一个概念叫做事件流，为什么会产生事件流呢？</li><li> 我们可以想到一个问题：当我们在浏览器上对着一个元素点击时，你点击的不仅仅是这个元素本身；</li><li> 这是因为我们的HTML元素是存在父子元素叠加层级的；</li><li> 比如一个span元素是放在div元素上的，div元素是放在body元素上的，body元素是放在html元素上的；</li></ul><h3 id="事件冒泡和事件捕获"><a href="#事件冒泡和事件捕获" class="headerlink" title="事件冒泡和事件捕获"></a>事件冒泡和事件捕获</h3><ul><li>我们会发现默认情况下事件是从最内层的span向外依次传递的顺序，这个顺序我们称之为事件冒泡（Event Bubble）;从里到外</li><li>事实上，还有另外一种监听事件流的方式就是从外层到内层（body -&gt; span），这种称之为事件捕获（Event Capture）；从外到里</li></ul><h3 id="监听ul里li的点击事件"><a href="#监听ul里li的点击事件" class="headerlink" title="监听ul里li的点击事件"></a>监听ul里li的点击事件</h3><ul><li><p>当点击li时，li会变色</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> liEls = document<span class="hljs-selector-class">.querySelectorAll</span>(<span class="hljs-string">&#x27;li&#x27;</span>)<br><span class="hljs-keyword">for</span> (const liEl of liEls) &#123;<br>  liEl<span class="hljs-selector-class">.onclick</span> = <span class="hljs-built_in">function</span>() &#123;<br>    liEl<span class="hljs-selector-class">.classList</span><span class="hljs-selector-class">.add</span>(<span class="hljs-string">&quot;active&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以监听ul</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> ulEl = document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)<br>ulEl<span class="hljs-selector-class">.onclick</span> = <span class="hljs-built_in">function</span>(e) &#123;<br>  e<span class="hljs-selector-class">.target</span><span class="hljs-selector-class">.classList</span><span class="hljs-selector-class">.add</span>(<span class="hljs-string">&quot;active&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="这就是委托模式"><a href="#这就是委托模式" class="headerlink" title="这就是委托模式"></a>这就是委托模式</h3><ul><li>因为当子元素被点击时，父元素可以通过冒泡可以监听到子元素的点击；</li><li>并且可以通过event.target获取到当前监听的元素；</li></ul><h3 id="BUT"><a href="#BUT" class="headerlink" title="BUT"></a>BUT</h3><ul><li><p>当父元素中有多个子元素时，委托模式应多考虑考虑</p></li><li><p>如</p></li><li><p>创建一个侧边栏，当鼠标放上去时会改变子元素的宽度以便展示文字</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tool-bar&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon icon01&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>购物车<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon icon02&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>收藏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon icon03&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>限时活动<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon icon04&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>大礼包<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>不使用委托模式是这样的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> itemEls = document<span class="hljs-selector-class">.querySelectorAll</span>(<span class="hljs-string">&quot;.item&quot;</span>) <span class="hljs-comment">//获取目标</span><br><span class="hljs-keyword">for</span> (<span class="hljs-selector-tag">var</span> itemEl of itemEls) &#123;  <span class="hljs-comment">//遍历</span><br>  itemEl<span class="hljs-selector-class">.onmouseenter</span> = <span class="hljs-built_in">function</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> nameEl = this<span class="hljs-selector-class">.children</span><span class="hljs-selector-attr">[1]</span><br>    nameEl<span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.width</span> = <span class="hljs-string">&quot;62px&quot;</span> <br>  &#125;<br>  itemEl<span class="hljs-selector-class">.onmouseleave</span> = <span class="hljs-built_in">function</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> nameEl = this<span class="hljs-selector-class">.children</span><span class="hljs-selector-attr">[1]</span><br>    nameEl<span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.width</span> = <span class="hljs-string">&quot;0&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在这里使用委托模式时，鼠标放入会因为冒泡而产生多次事件，同时，放入鼠标时还需要改变目标</p></li><li><p>鼠标一进去时先进入item盒子然后离开item盒子，进入i标签，使用委托的话就触发了两次进入与一次退出。</p></li><li><p>又因为离开了item盒子进入了i标签，还需要改变进入i标签时的目标指向</p></li><li><pre><code class="hljs">var itemEl = event.target.classList.contains(&quot;item&quot;) ? event.target:event.target.parentElement</code></pre></li><li><p>这样就感觉很麻烦</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM初步了解</title>
    <link href="/2022/07/23/DOM%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/07/23/DOM%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="DOM-文档对象模型（Document-Object-Model）"><a href="#DOM-文档对象模型（Document-Object-Model）" class="headerlink" title="DOM: 文档对象模型（Document Object Model）"></a>DOM: 文档对象模型（Document Object Model）</h2><ul><li>简称DOM，将页面所有内容表示为可以修改的对象</li><li>将HTML中的元素抽象成我们可以编辑的对象就叫文档对象模型</li><li>DOMtree（尚未理解）</li></ul><h2 id="BOM：浏览器对象模型（Browser-Object-Model）"><a href="#BOM：浏览器对象模型（Browser-Object-Model）" class="headerlink" title="BOM：浏览器对象模型（Browser Object Model）"></a>BOM：浏览器对象模型（Browser Object Model）</h2><ul><li>由浏览器提供的用于处理文档之外的所有内容的其他对象</li><li>比如navigator，location，history等</li></ul><h2 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(document.doctype) <span class="hljs-comment">//文档声明</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(document.documentElement) <span class="hljs-comment">//html元素</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(document.body) <span class="hljs-comment">//body元素</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(document.head) <span class="hljs-comment">//head元素</span><br></code></pre></td></tr></table></figure><h3 id="Node（节点）之间的导航-navigator"><a href="#Node（节点）之间的导航-navigator" class="headerlink" title="Node（节点）之间的导航(navigator)"></a>Node（节点）之间的导航(navigator)</h3><h3 id="节点之间的导航"><a href="#节点之间的导航" class="headerlink" title="节点之间的导航"></a>节点之间的导航</h3><ul><li>获取一个节点（node）后，可以根据其获取其他节点</li><li> 父节点：parentNode </li><li> 前兄弟节点：previousSibling </li><li> 后兄弟节点：nextSibling </li><li> 子节点：childNodes </li><li> 第一个子节点：firstChild</li><li> 第二个子节点：lastChild</li></ul><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs openscad"> 父元素：parentElement<br> 前兄弟节点：previousElementSibling<br> 后兄弟节点：nextElementSibling<br> 子节点：<span class="hljs-built_in">children</span><br> 第一个子节点：firstElementChild<br> 第二个子节点：lastElementChild<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高阶函数</title>
    <link href="/2022/07/21/JS%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2022/07/21/JS%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>能在函数中运行另一个函数的被称为高阶函数</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><p>forEach函数是一个高阶函数，他的作用对数组中的每个元素执行命令</p><p><code>arr.forEach(function)</code></p></li><li><pre><code class="hljs"> var item = [1, 2, 3, 4]var foo = function(fn)&#123;      for(i = 0; i &lt; item.length; i++)&#123;        fn(item[i], i, item)      &#125;    &#125;<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>- 这也可以实现和forEach一样的效果，但是函数无法便利的获取数组名，不具有复用性<br><br>- 可以将自制的方法放到原型中，这样方便<span class="hljs-keyword">this</span>指向<br><br>- ```<br>  Array.prototype.foo = function(fn) &#123;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++)&#123;<br>          fn(<span class="hljs-keyword">this</span>[i], i, <span class="hljs-keyword">this</span>)<br>        &#125;<br>     &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS的简单内存</title>
    <link href="/2022/07/18/JS%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E5%AD%98/"/>
    <url>/2022/07/18/JS%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h2><ul><li><p>对象内容保存在堆中，而其他的属性，比如变量，常量,函数保存在栈中</p></li><li><p>其实栈中也存在对象，不过只是指向对象的内存地址。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var <span class="hljs-keyword">info</span> = &#123;<br><span class="hljs-type">name</span>: <span class="hljs-string">&#x27;why&#x27;</span>,<br>friend: &#123;<br><span class="hljs-type">name</span>: <span class="hljs-string">&#x27;kobe&#x27;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在这个info对象里面保存的friend也是一个指针，指向新的内存地址</p></li><li><p>所以下面的obj才不会变，因为指向了新的内存地址</p></li><li><pre><code class="hljs">  值传递  function foo(a) &#123;    a = 200  &#125;  let num = 100  foo(num)  console.log(num) //100<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>- ```<br>  function <span class="hljs-built_in">foo</span>(a) &#123;<br>      <span class="hljs-selector-tag">a</span> = &#123;<br>        name: <span class="hljs-string">&#x27;why&#x27;</span><br>      &#125;<br>    &#125;<br>  <br>    <span class="hljs-selector-tag">var</span> obj = &#123;<br>      name: <span class="hljs-string">&#x27;obj&#x27;</span><br>    &#125;<br>    <span class="hljs-built_in">foo</span>(obj)<br>    console<span class="hljs-selector-class">.log</span>(obj.name) <span class="hljs-comment">//obj</span><br>    <span class="hljs-comment">//引用传递，在函数中创建一个新对象，没有对传入对象进行修改</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>以上两个都是函数里面指向了一个新的内存地址，但原本的地址并没有更改</p></li><li><pre><code class="hljs">function foo(a) &#123;      a.name = &#39;why&#39;  &#125;  var obj = &#123;    name: &#39;obj&#39;  &#125;  foo(obj)  console.log(obj.name) //why</code></pre></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象的遍历</title>
    <link href="/2022/07/18/%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2022/07/18/%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h2><ul><li>Object.key() 一个方法，会返回一个由一个给定对象的自身可枚举属性所组成的数组</li></ul><h3 id="普通的for循环"><a href="#普通的for循环" class="headerlink" title="普通的for循环"></a>普通的for循环</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> info = &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kami&quot;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br> <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;Q&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> infoKey = Object.keys(info)<br> <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; infoKey.<span class="hljs-built_in">length</span>; i++) &#123;<br>   <span class="hljs-keyword">var</span> key = infoKey[i]<br>   <span class="hljs-keyword">var</span> value = info[key]<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`key: <span class="hljs-subst">$&#123;key&#125;</span>,value: <span class="hljs-subst">$&#123;value&#125;</span> `</span>)<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="for-in"><a href="#for-in" class="headerlink" title="for..in.."></a>for..in..</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key in info) &#123;<br>    <span class="hljs-keyword">var</span> value = info[key]<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`key: <span class="hljs-subst">$&#123;key&#125;</span>,value: <span class="hljs-subst">$&#123;value&#125;</span> `</span>)<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS入门</title>
    <link href="/2022/07/14/JS%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/14/JS%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="交换两个变量的值"><a href="#交换两个变量的值" class="headerlink" title="交换两个变量的值"></a>交换两个变量的值</h2><ul><li>新建一个变量三。将变量一赋值给他。然后将变量二赋值给变量一。再将变量三赋值给变量二。</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">var <span class="hljs-symbol">num1</span> = <span class="hljs-number">10</span><br>var <span class="hljs-symbol">num2</span> = <span class="hljs-number">20</span><br>var <span class="hljs-symbol">num3</span> = <span class="hljs-symbol">num1</span><br><span class="hljs-symbol">num1</span> = <span class="hljs-symbol">num2</span><br><span class="hljs-symbol">num2</span> = <span class="hljs-symbol">num3</span><br></code></pre></td></tr></table></figure><ul><li>使用加减法交换(不需要新建变量)</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-symbol">num1</span> = <span class="hljs-symbol">num1</span> + <span class="hljs-symbol">num2</span><br><span class="hljs-symbol">num2</span> = <span class="hljs-symbol">num1</span> - <span class="hljs-symbol">num2</span><br><span class="hljs-symbol">num1</span> = <span class="hljs-symbol">num1</span> - <span class="hljs-symbol">num2</span><br></code></pre></td></tr></table></figure><h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><ul><li><p>typeof  判断没赋值的变量时会返回undefined</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> age)<br></code></pre></td></tr></table></figure></li></ul><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><ul><li>NaN  代表一个计算错误,他是一个错误的操作得到的结果 比如数字和字符串相乘</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li><p>用反引号的时候里面可以使用变量  用**${}**引入</p></li><li><p>所以字符串的拼接可以直接用**${}**引入</p></li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><ul><li>指的是这样一个数列：1、1、2、3、5、8、13、21、34</li><li>这个数列从第3项开始，每一项都等于前两项之和。</li><li><em>F</em>(0)&#x3D;0，<em>F</em>(1)&#x3D;1, <em>F</em>(n)&#x3D;<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N*）</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> Fibonacci (n) &#123;<br>      <span class="hljs-keyword">if</span>(n<span class="hljs-operator"> === </span><span class="hljs-number">1</span> <span class="hljs-pattern-match">| n <span class="hljs-operator">==</span>= 2) return n</span><br><span class="hljs-pattern-match">      <span class="hljs-constructor">Fibonacci(<span class="hljs-params">n</span>-2)</span> = <span class="hljs-constructor">Fibonacci(<span class="hljs-params">n</span>)</span> - <span class="hljs-constructor">Fibonacci(<span class="hljs-params">n</span>-1)</span></span><br><span class="hljs-pattern-match">      return <span class="hljs-constructor">Fibonacci(<span class="hljs-params">n</span>-2)</span></span><br><span class="hljs-pattern-match">    &#125;</span><br></code></pre></td></tr></table></figure><ul><li>这样写会报错，return不能返回（n - 2）</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">function Fibonacci (n) &#123;<br>      <span class="hljs-built_in">if</span>(n === <span class="hljs-number">1</span> | n === <span class="hljs-number">2</span>) return n<br>      return <span class="hljs-built_in">Fibonacci</span>(n-<span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span>(n-<span class="hljs-number">2</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>这样才会正确返回</li></ul><h2 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h2><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> bthEls = document.querySelectorAll(<span class="hljs-string">&#x27;.btn&#x27;</span>)<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; bthEls.lenght; i++) &#123;<br><span class="hljs-keyword">var</span> bth = bthEls[i]<br>bth.onclick = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`按钮<span class="hljs-subst">$&#123;i+<span class="hljs-number">1</span>&#125;</span>发生了点击`</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>你点击按钮的时候，输出的是固定的值。</p></li><li><p>因为在你点击按钮的时候，循环就已经结束了。所以i的值也固定了。</p></li><li><p>在ES6后就你用let就行。var是真的拉</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Less</title>
    <link href="/2022/07/12/Less/"/>
    <url>/2022/07/12/Less/</url>
    
    <content type="html"><![CDATA[<h3 id="Less-（Leaner-Style-Sheets-的缩写）-是一门CSS-扩展语言-并且兼容CSS。"><a href="#Less-（Leaner-Style-Sheets-的缩写）-是一门CSS-扩展语言-并且兼容CSS。" class="headerlink" title="Less （Leaner Style Sheets 的缩写） 是一门CSS 扩展语言, 并且兼容CSS。"></a>Less （Leaner Style Sheets 的缩写） 是一门CSS 扩展语言, 并且兼容CSS。</h3><ul><li>Less增加了很多相比于CSS更好用的特性;</li><li>比如定义变量、混入、嵌套、计算等等； </li><li>Less最终需要被编译成CSS运行于浏览器中（包括部署到服务器中）；</li></ul><h3 id="less代码的编译"><a href="#less代码的编译" class="headerlink" title="less代码的编译"></a>less代码的编译</h3><ul><li><p>引入CDN的less编译代码，对less进行实时的处理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet/less&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./css/page_right_nav.less&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/less@4&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>把<a href="https://cdn.jsdelivr.net/npm/less@4%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%96%B0%E5%BB%BA%E7%9A%84.less%E6%96%87%E4%BB%B6%E9%87%8C">https://cdn.jsdelivr.net/npm/less@4里面的代码复制到本地新建的.less文件里</a></p></li></ul><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><ul><li>可以@变量名 : 变量</li><li>然后要使用时直接**@变量名**就可以了</li><li>可以使用关键字，测试@color可以使用</li></ul><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><ul><li><p>给class定义样式时，因为要规范，清晰，往往在写一个class时前面还会拖家带口的</p></li><li><p>less就解决了这个烦恼</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">  &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;<br>    我是box<br>    &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;pel&quot;</span>&gt;<br>      我不是box<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>  <br>  <br>@color : <span class="hljs-comment">#080808;</span><br>@maincolor: <span class="hljs-comment">#f3c258;</span><br>.box &#123;<br>  color: @color;<br><br>  .pel &#123;<br>    background-color: @color;<br>    color: @maincolor;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以在选择器里套后代选择器超方便的.</p></li><li><p>做hover时也有语法糖</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">9</span>, <span class="hljs-number">163</span>, <span class="hljs-number">42</span>);<br>  <br>  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在里面添加一个&amp;:hover就可以设置hover样式了</p></li><li><p>&amp;后面也可以加其他的伪类</p></li></ul><h2 id="运算-很少用"><a href="#运算-很少用" class="headerlink" title="运算(很少用)"></a>运算(很少用)</h2><h3 id="在less中-算术运算符可以对任何数字颜色或变量进行运算"><a href="#在less中-算术运算符可以对任何数字颜色或变量进行运算" class="headerlink" title="在less中,算术运算符可以对任何数字颜色或变量进行运算"></a>在less中,算术运算符可以对任何数字颜色或变量进行运算</h3><ul><li><p>算术运算符在加减或比较前会进行单位换算，计算的结果以最左侧操作数的单位类型为准</p></li><li><p>如果单位换算无效或失去意义，则忽略单位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span> + <span class="hljs-number">10em</span>;<br>这样的话得到的结果是<span class="hljs-number">110px</span>,直接将后面的单位忽略.<br></code></pre></td></tr></table></figure></li></ul><h2 id="混合mixins"><a href="#混合mixins" class="headerlink" title="混合mixins"></a>混合mixins</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: aqua;<br><br>  <span class="hljs-selector-class">.noewrap_ellipsis</span>()<br>&#125;<br><br><span class="hljs-selector-class">.box2</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff5</span>;<br>&#125;<br><br><span class="hljs-selector-class">.noewrap_ellipsis</span> &#123;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将类之间塞进另一个类里,方便了很多.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.box_border</span>(<span class="hljs-variable">@Width</span>: <span class="hljs-number">5px</span>, <span class="hljs-variable">@border</span>: blue) &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-variable">@Width</span> solid <span class="hljs-variable">@border</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以给里面设置变量,这样在引入时可以在小括号里更改参数.</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">上面box2的宽度还可以这样设置<br><span class="hljs-built_in">width</span>: .<span class="hljs-built_in">box</span>()[<span class="hljs-built_in">width</span>]<br></code></pre></td></tr></table></figure><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Uncaught</span> (<span class="hljs-keyword">in</span> promise) <span class="hljs-title class_">TypeError</span>: <span class="hljs-title class_">Cannot</span> read properties <span class="hljs-keyword">of</span> <span class="hljs-literal">undefined</span> (reading <span class="hljs-string">&#x27;href&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>大概是这样的，解决办法很奇怪</li><li>在VScode里启用本地服务器，就是右键Open with Live Server（好像是个插件来着）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFC</title>
    <link href="/2022/07/10/BFC/"/>
    <url>/2022/07/10/BFC/</url>
    
    <content type="html"><![CDATA[<h2 id="FC"><a href="#FC" class="headerlink" title="FC"></a>FC</h2><p>formatting context</p><ul><li>感觉就是布局元素</li></ul><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>Block Formatting Context</p><ul><li>块级元素布局环境</li><li>在以下情况会创建一个bfc</li><li><ul><li>根元素 （<html>)   </li><li>浮动元素</li><li>弹性元素</li><li>绝对定位元素</li><li>行内块元素</li><li>表格单元格</li><li>overflow</li><li>网格元素</li><li>display值为flow-root的元素</li></ul></li><li>影响布局的都会创建一个BFC</li><li>在BFC中，盒子会从顶部开始垂直方向上一个接一个排布</li><li>margin属性是由BFC定义</li></ul><h3 id="在同一个BFC中相邻的两个块级元素margin会折叠"><a href="#在同一个BFC中相邻的两个块级元素margin会折叠" class="headerlink" title="在同一个BFC中相邻的两个块级元素margin会折叠"></a>在同一个BFC中相邻的两个块级元素margin会折叠</h3><h3 id="盒子在默认情况下左边缘会紧挨着BFC左边缘"><a href="#盒子在默认情况下左边缘会紧挨着BFC左边缘" class="headerlink" title="盒子在默认情况下左边缘会紧挨着BFC左边缘"></a>盒子在默认情况下左边缘会紧挨着BFC左边缘</h3><h3 id="在高度是auto的情况下，计算高度"><a href="#在高度是auto的情况下，计算高度" class="headerlink" title="在高度是auto的情况下，计算高度"></a>在高度是auto的情况下，计算高度</h3><ul><li>忽略绝对元素</li><li>增加高度去适应浮动元素</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片模糊</title>
    <link href="/2022/07/10/%E5%9B%BE%E7%89%87%E6%A8%A1%E7%B3%8A/"/>
    <url>/2022/07/10/%E5%9B%BE%E7%89%87%E6%A8%A1%E7%B3%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="blur"><a href="#blur" class="headerlink" title="blur"></a>blur</h2><ul><li><p>将高斯模糊应用于输出图片或者元素</p></li><li><p>such as 给img元素添加模糊效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>像素越大内容越模糊</p></li></ul><h2 id="添加有透明效果的模糊"><a href="#添加有透明效果的模糊" class="headerlink" title="添加有透明效果的模糊"></a>添加有透明效果的模糊</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,.<span class="hljs-number">5</span>);<br> backdrop-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">10px</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>calc</title>
    <link href="/2022/07/10/calc/"/>
    <url>/2022/07/10/calc/</url>
    
    <content type="html"><![CDATA[<h2 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h2><ul><li><p>一个计算属性，常用于变量计算。</p></li><li><pre><code class="hljs">width: calc(100% - 100px)</code></pre></li><li><p>减号左右两边要有空格</p></li><li><p>其中100%是相对于包含块</p></li><li><p>像这样可以计算动态宽度</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>meta</title>
    <link href="/2022/07/10/meta/"/>
    <url>/2022/07/10/meta/</url>
    
    <content type="html"><![CDATA[<h3 id="meta元素用于定义元数据"><a href="#meta元素用于定义元数据" class="headerlink" title="meta元素用于定义元数据"></a>meta元素用于定义元数据</h3><ul><li>比如标签title，样式style，link外部资源等</li></ul><h4 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h4><ul><li>meta是一个字符集声明，告诉文档使用哪种字符编码</li></ul><h4 id="http-equiv"><a href="#http-equiv" class="headerlink" title="http-equiv"></a>http-equiv</h4><ul><li>meta是编译指令</li><li>主要是用于适配浏览器</li></ul><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><ul><li>提供文档级别的元数据，应用于整个页面</li><li>robots</li><li><ul><li>告诉爬虫哪些可以爬</li></ul></li><li>author</li><li><ul><li>文档作者</li></ul></li><li>copyright</li><li><ul><li>版权声明</li></ul></li><li>description</li><li><ul><li>网站描述</li></ul></li><li>keywords</li><li><ul><li>关键字，主要用于SEO优化</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文字前加小图标</title>
    <link href="/2022/07/07/%E6%96%87%E5%AD%97%E5%89%8D%E5%8A%A0%E5%B0%8F%E5%9B%BE%E6%A0%87/"/>
    <url>/2022/07/07/%E6%96%87%E5%AD%97%E5%89%8D%E5%8A%A0%E5%B0%8F%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<ul><li><p>w</p></li><li><p>有时候会有要在一行文字的前面加一个小图片的需求。</p></li><li><p>一般有两种方法，一种是添加一个:hover样式。还有一种就是添加个<i>。</p></li></ul><h3 id="i"><a href="#i" class="headerlink" title="i"></a>i</h3><ul><li><p>在文字前加个i标签，并给i标签设置样式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon_type icon_type_hot&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 游戏介绍<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.icon_type</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">24px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">24px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">2px</span>;</span><br><span class="language-css">  <span class="hljs-comment">/* vertical-align: middle; */</span></span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">../../img/main_sprite.png</span>) no-repeat;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.icon_type_hot</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background-position</span>: -<span class="hljs-number">161px</span> -<span class="hljs-number">67px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><ul><li><p>先给i设置个块级元素以便设置宽高，给右边距和文字有间隔。用background引入图片。要是只有只有一张图片且只用一部分可以直接在background里面设置位置。上面是因为在这个精灵图中要引用几个不同的图标所有才位置分开设置。</p></li><li><p>设置后可能会发现图片没有垂直居中显示。这是因为图片默认设置为基线对齐，基线为文字的底部。这时候我们可以给图片加个vertical-align: middle来改变他的基线对齐。</p></li><li><p>也可以不设置vertical-align: middle。这时候我们可以给a标签加个flex布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<br>      <span class="hljs-attribute">display</span>: flex;<br>      <span class="hljs-attribute">align-items</span>: center;<br>      <span class="hljs-comment">/* justify-content: center; */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这样也可以做到图片垂直居中对齐，不过可能会影响相同class的布局，使他们的居中对齐失效。那我们可以给他加个 justify-content: center;使他们恢复居中对齐</p></li></ul></li></ul><h2 id="after"><a href="#after" class="headerlink" title="::after"></a>::after</h2><h3 id="必须先设置一个content-39-39"><a href="#必须先设置一个content-39-39" class="headerlink" title="必须先设置一个content: &#39;&#39;;"></a>必须先设置一个<code>content: &#39;&#39;;</code></h3><ul><li>给父元素加个相对定位，因为这个要设置绝对定位</li><li>设置宽高，给上下和左或右为0，要对齐那边就哪边为0.</li><li>设置margin：auto 0；来居中</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图层覆盖</title>
    <link href="/2022/07/06/%E5%9B%BE%E5%B1%82%E8%A6%86%E7%9B%96/"/>
    <url>/2022/07/06/%E5%9B%BE%E5%B1%82%E8%A6%86%E7%9B%96/</url>
    
    <content type="html"><![CDATA[<p>- </p><h2 id="图片的层叠性"><a href="#图片的层叠性" class="headerlink" title="图片的层叠性"></a>图片的层叠性</h2><ul><li><p>一般要一个图片在另一个图片之上我们可以给他加z-index</p></li><li><p>当加了z-index无效时查看是否有加定位元素</p></li></ul><h3 id="加了定位元素z-index才会生效"><a href="#加了定位元素z-index才会生效" class="headerlink" title="加了定位元素z-index才会生效"></a>加了定位元素z-index才会生效</h3><ul><li>当双方都没加z-index时，在后面的覆盖前面的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vant组件库</title>
    <link href="/2022/07/04/vant%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    <url>/2022/07/04/vant%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="小程序安装"><a href="#小程序安装" class="headerlink" title="小程序安装"></a>小程序安装</h2><ul><li><p>!()[<a href="https://vant-contrib.gitee.io/vant-weapp/#/home">介绍 - Vant Weapp (gitee.io)</a>]</p></li><li><p>npm安装  是在你使用项目的根目录</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">先安装依赖<br><span class="hljs-built_in">npm</span> init -y<br>然后就可以安装了<br><span class="hljs-built_in">npm</span> i @vant/weapp -S --production<br><br></code></pre></td></tr></table></figure></li><li><p>安装完后会多出两个文件，package.json和node文件夹</p></li><li><p>之后将app.json 中的 “style”: “v2” 删了</p></li><li><p>找到 project.config.json 添加代码</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">&#123;<br>  <span class="hljs-string">...</span><br>  <span class="hljs-string">&quot;setting&quot;</span>: &#123;<br>    <span class="hljs-string">...</span><br>    <span class="hljs-string">&quot;packNpmManually&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;packNpmRelationList&quot;</span>: [<br>      &#123;<br>        <span class="hljs-string">&quot;packageJsonPath&quot;</span>: <span class="hljs-string">&quot;./package.json&quot;</span>,<br>        <span class="hljs-string">&quot;miniprogramNpmDistDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加代码后</p></li><li><p><img src="https://img.yzcdn.cn/public_files/2019/08/15/fa0549210055976cb63798503611ce3d.png" alt="构建npm包"></p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>使用他要现在json中进行配置</p></li><li><p>如要全局使用，则在app.json中配置.只在特定页面中使用则在对应页面的json中配置</p></li></ul><h3 id="引入Button"><a href="#引入Button" class="headerlink" title="引入Button"></a>引入Button</h3>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;usingComponents&quot;: &#123;<br>  &quot;van-<span class="hljs-selector-tag">button</span>&quot;: <span class="hljs-string">&quot;@vant/weapp/dist/button/index&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  引入后,直接在wxml中使用组件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">van-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">van-button</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小程序循环</title>
    <link href="/2022/07/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BE%AA%E7%8E%AF/"/>
    <url>/2022/07/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="简简单单的循环"><a href="#简简单单的循环" class="headerlink" title="简简单单的循环"></a>简简单单的循环</h2><ul><li><p>先在js的data中建立一个数组来存放请求来的数据或是自己定义的数据。</p></li><li><p>然后定义请求方法，定义完后在onLoad函数中调用。</p></li><li><p>在盒子中使用wx:for 用</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-template-variable">&#123;&#123;&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>包裹在data中定义的数组 wx:key，默认为数组的键。</p></li><li><p>data-自定义值   &#x3D;  要传递的值 主要用于事件？</p></li></ul><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-item&quot;</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">product</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;pid&quot;</span> <span class="hljs-attr">data-pid</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.pid</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-coffee&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;widthFix&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.largeImg</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.name</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-enname&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.enname</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-price&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.price</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml"> js</span><br><span class="language-xml"> data: &#123;</span><br><span class="language-xml">    banner: [],</span><br><span class="language-xml">    product: []</span><br><span class="language-xml">  &#125;,</span><br><span class="language-xml">  getProduct()&#123;</span><br><span class="language-xml">    wx.request(&#123;</span><br><span class="language-xml">      url: &#x27;http://www.kangliuyong.com:10002/banner&#x27;, //仅为示例，并非真实的接口地址</span><br><span class="language-xml">      data: &#123;</span><br><span class="language-xml">        appkey: &#x27;U2FsdGVkX19WSQ59Cg+Fj9jNZPxRC5y0xB1iV06BeNA=&#x27;</span><br><span class="language-xml">      &#125;,</span><br><span class="language-xml">      header: &#123;</span><br><span class="language-xml">        &#x27;content-type&#x27;: &#x27;application/json&#x27; // 默认值</span><br><span class="language-xml">      &#125;,</span><br><span class="language-xml">      success:(res)=&gt;&#123;</span><br><span class="language-xml">        console.log(res.data.result);</span><br><span class="language-xml">        this.setData(&#123;</span><br><span class="language-xml">          banner:res.data.result</span><br><span class="language-xml">        &#125;)</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    &#125;)</span><br><span class="language-xml">  &#125;,</span><br><span class="language-xml">  /**</span><br><span class="language-xml">   * 生命周期函数--监听页面加载</span><br><span class="language-xml">   */</span><br><span class="language-xml">  onLoad: function (options) &#123;</span><br><span class="language-xml">    console.log();</span><br><span class="language-xml">    this.getProduct();</span><br><span class="language-xml">  &#125;,</span><br><span class="language-xml">  </span><br></code></pre></td></tr></table></figure><h2 id="双层循环"><a href="#双层循环" class="headerlink" title="双层循环"></a>双层循环</h2><ul><li>在datailData.handler中存在一个数组arr</li><li>在遍历了datailData.handler数组中再遍历arr数组</li><li>wx:for中填写的是item.该数组，后要跟wx:for-item&#x3D;自定义值，之后在盒子内填写 </li></ul><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;choose-type&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;type-box&quot;</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">datailData.handler</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tem&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.type</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-val&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;val&quot;</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.arr</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;count&quot;</span> <span class="hljs-attr">wx:for-index</span>=<span class="hljs-string">&quot;count&quot;</span>  <span class="hljs-attr">wx:for-item</span>=<span class="hljs-string">&quot;val&quot;</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">index</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">data-count</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">count</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">val</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后代选择器</title>
    <link href="/2022/07/02/%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2022/07/02/%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="施工中"><a href="#施工中" class="headerlink" title="施工中"></a>施工中</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VScode快捷键</title>
    <link href="/2022/07/02/VScode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2022/07/02/VScode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="选择相同"><a href="#选择相同" class="headerlink" title="选择相同"></a>选择相同</h2><ul><li><p>依次选择</p></li><li><pre><code class="hljs">Ctrl + D<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>一次选择所有<br><br><span class="hljs-bullet">- </span><span class="hljs-code">```</span><br><span class="hljs-code">  Ctrl + Shift + L</span><br></code></pre></td></tr></table></figure></code></pre></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>border动画</title>
    <link href="/2022/07/01/border%E5%8A%A8%E7%94%BB/"/>
    <url>/2022/07/01/border%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<ul><li><p>给标签加border动画的代码很简单</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transition</span>: border-bottom <span class="hljs-number">150ms</span> ease-in;<br></code></pre></td></tr></table></figure><ul><li>当然前提得是你有个：hover之类得border变化</li></ul></li><li><p>这样一般动画效果都是从上往下加</p></li><li><p>而在你给标签加个</p></li><li><pre><code class="hljs">box-sizing: border-box;</code></pre></li><li><p>这样动画效果就会从下往上了</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂项</title>
    <link href="/2022/06/28/%E6%9D%82%E9%A1%B9/"/>
    <url>/2022/06/28/%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="6月28日"><a href="#6月28日" class="headerlink" title="6月28日"></a>6月28日</h2><p>​在制作样式时，要制作两行文字，一行a标签，一行span。</p><p>​在给a标签添加display：block后，发现他直接把一个盒子行占据了，把span挤出了盒子。给a添加16px的高度后，因为两行文字里的太近了，想添加些中间空隙。给a直接加margin没用，span元素又不支持margin-top。后面发现鼠标放a上不变形状。开F12检查，发现a在盒子最上面。百思不得其解，怎么跑那里去了。就在随便点点的时候把line-height点掉才发现a标签里的字回去了。</p><ul><li>line-height会影响block后的a标签，使其文字和a本身身首异处。</li><li>line-height是<strong>行高</strong>，而a在block后自成一行，所以会受影响。最好line-height别随便加</li></ul><h2 id="文字布局"><a href="#文字布局" class="headerlink" title="文字布局"></a>文字布局</h2><h3 id="使文字在超过两行的内容显示出。。。"><a href="#使文字在超过两行的内容显示出。。。" class="headerlink" title="使文字在超过两行的内容显示出。。。"></a>使文字在超过两行的内容显示出。。。</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-attribute">text-overflow</span>: ellipsis;<br><span class="hljs-attribute">display</span>: -webkit-box;<br>-webkit-line-clamp: <span class="hljs-number">2</span>;<br>-webkit-box-orient: vertical;<br></code></pre></td></tr></table></figure><h3 id="使文字垂直显示"><a href="#使文字垂直显示" class="headerlink" title="使文字垂直显示"></a>使文字垂直显示</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">writing-mode</span>: vertical-lr;<br></code></pre></td></tr></table></figure><h3 id="文字偏移"><a href="#文字偏移" class="headerlink" title="文字偏移"></a>文字偏移</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">text</span>-indent: Xpx<br></code></pre></td></tr></table></figure><ul><li><p>text-indent 属性规定文本块中首行文本的缩进。</p></li><li><p>负值是允许的。如果值是负数，将第一行左缩进。</p></li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="边框合并"><a href="#边框合并" class="headerlink" title="边框合并"></a>边框合并</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">border</span>-<span class="hljs-built_in">collapse</span>: <span class="hljs-built_in">collapse</span><br></code></pre></td></tr></table></figure><ul><li>在设置背景色后可以使格子与格子的间隙消除</li></ul><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">input</span> v-model=<span class="hljs-string">&quot;sth&quot;</span> /&gt;  <span class="hljs-comment">//这一行等于下一行</span><br>    &lt;<span class="hljs-keyword">input</span> v-bind:value=<span class="hljs-string">&quot;sth&quot;</span> v-<span class="hljs-keyword">on</span>:<span class="hljs-keyword">input</span>=<span class="hljs-string">&quot;sth = $event.target.value&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h2 id="hash和history"><a href="#hash和history" class="headerlink" title="hash和history"></a>hash和history</h2><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><ul><li>会改变url，但不会刷新页面。只是在客户端进行的页面跳转</li></ul><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>- </p><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><ul><li><p>我们先用:value绑定数据，再用v-on绑定方法，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">methods: &#123;<br><span class="hljs-built_in">valueChange</span>(event) &#123;<br>this<span class="hljs-selector-class">.message</span> = event<span class="hljs-selector-class">.tarfet</span><span class="hljs-selector-class">.value</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>event是本来就有的。event.target.value就是在input里输入的值。</p></li><li><p>也可以直接</p></li><li><pre><code class="hljs">:value=&quot;message&quot; @input=&quot; message = $event.target.value &quot;</code></pre><p>这就是v-model</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>认识精灵图</title>
    <link href="/2022/06/24/%E8%AE%A4%E8%AF%86%E7%B2%BE%E7%81%B5%E5%9B%BE/"/>
    <url>/2022/06/24/%E8%AE%A4%E8%AF%86%E7%B2%BE%E7%81%B5%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="WHAT-IT"><a href="#WHAT-IT" class="headerlink" title="WHAT IT"></a>WHAT IT</h2><ul><li>是一种CSS图像合成技术，将各种小图片合并到一张图片上，然后利用网站获取代码来显示指定小图片</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>减少网页的HTTP请求数量，加快网页响应速度，减轻服务器压力</li><li>减小图片总大小</li><li>解决了图片命名困扰，一张图片集合了许多小图片</li></ul><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><ul><li><p><a href="http://www.spritecow.com/">方便</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.sprite</span> &#123;<br><span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;imgs/top_sprite.png&#x27;</span>) no-repeat -<span class="hljs-number">36px</span> -<span class="hljs-number">6px</span>;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">18px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">18px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>直接复制就完事了</p></li><li><p>小图标可以用伪元素解决</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.X</span><span class="hljs-selector-pseudo">::after</span> &#123;<br><span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attribute">position</span>:absoluta<br><span class="hljs-attribute">width</span>: X<br><span class="hljs-attribute">height</span>: Y<br><span class="hljs-attribute">right</span>: <span class="hljs-number">0</span><br><span class="hljs-attribute">top</span>: <span class="hljs-number">0</span><br><span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span><br><span class="hljs-attribute">margin</span>: auto <span class="hljs-number">0</span><br><span class="hljs-attribute">background</span>: url(<span class="hljs-string"></span>) no-repeat <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>官方文档</title>
    <link href="/2022/06/24/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    <url>/2022/06/24/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="W3"><a href="#W3" class="headerlink" title="W3"></a>W3</h2><p>[跳转](<a href="https://www.w3.org/">World Wide Web Consortium (W3C)</a>)</p><h2 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h2><p><a href="https://developer.mozilla.org/zh-CN/">MDN Web Docs (mozilla.org)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS编写顺序</title>
    <link href="/2022/06/24/CSS%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F/"/>
    <url>/2022/06/24/CSS%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ul><li>凹凸实验室</li><li><a href="https://guide.aotu.io/">跳转</a></li></ul><h3 id="属性书写顺序"><a href="#属性书写顺序" class="headerlink" title="属性书写顺序"></a>属性书写顺序</h3><ol><li>布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow</li><li>自身属性：width &#x2F; height &#x2F; box-sizing &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</li><li>文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word</li><li>其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient …</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vertical-align</title>
    <link href="/2022/06/23/vertical-align/"/>
    <url>/2022/06/23/vertical-align/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>影响行内块元素在行盒内的对齐方式</li></ul><h3 id="行盒"><a href="#行盒" class="headerlink" title="行盒"></a>行盒</h3><ul><li>一行内所有内容的高撑起来的盒子（图片和行内块元素的高度）</li></ul><h3 id="行内默认基线对齐"><a href="#行内默认基线对齐" class="headerlink" title="行内默认基线对齐"></a>行内默认基线对齐</h3><ul><li><p>没有盒子时，默认的基线是盒子的margin-bottom的底部</p></li><li><p>基线对齐，基线为最后一行文本的底部</p></li><li><p>如一个空盒子，内部没有文字时他的底部会和文字的底部对齐</p></li><li><p>而当盒子内有文字时，则会使盒子内的文字于基线对齐，因为默认底部对齐，而当处于盒子顶部的文字和基线对齐时，会将盒子挤下去</p></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>baseline: (默认值)基线对齐</li><li>top：行内级盒子的顶部更line boxes顶部对齐</li><li>middle：行内级盒子的中心点与父盒基线加上X-height一半的线对齐</li><li>bottom：把行内级盒子的底部跟line box底部对齐</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transition动画</title>
    <link href="/2022/06/23/transition%E5%8A%A8%E7%94%BB/"/>
    <url>/2022/06/23/transition%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="WHAT-IT"><a href="#WHAT-IT" class="headerlink" title="WHAT IT"></a>WHAT IT</h2><ul><li><p>提供了一种在更改CSS属性时控制动画速度的方法。</p></li><li><p>可以让CSS属性变化成为一个持续一段时间的过程，而不是立即生效；</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">transition-property</span>: transform, left; <span class="hljs-comment">//指定动画的元素 设置为all时所有属性都执行动画</span><br><span class="hljs-attribute">transition-duration</span>: ; <span class="hljs-comment">// 时间</span><br><span class="hljs-attribute">transition-timing-function</span>: ease-in; <span class="hljs-comment">//指向速率</span><br><span class="hljs-attribute">transition-delay</span>: ; <span class="hljs-comment">//延迟</span><br><span class="hljs-attribute">transition</span>： <span class="hljs-attribute">all</span> <span class="hljs-number">1s</span> ease-in <span class="hljs-number">1s</span> <span class="hljs-comment">//简写属性</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>水平居中和垂直居中方案</title>
    <link href="/2022/06/23/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/"/>
    <url>/2022/06/23/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h4 id="行内级元素"><a href="#行内级元素" class="headerlink" title="行内级元素"></a>行内级元素</h4><ul><li>设置父元素的text-align: center</li></ul><h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><ul><li>设置当前margin：0 auto</li></ul><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><ul><li>元素有宽度的情况下，left0&#x2F;right0&#x2F;margin：0 auto;</li></ul><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><ul><li>justift-content: center</li></ul><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h4 id="绝对定位-1"><a href="#绝对定位-1" class="headerlink" title="绝对定位"></a>绝对定位</h4><ul><li>在元素有高度的情况下， top0&#x2F;bottom0&#x2F;margin：auto X；</li></ul><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">position:</span> relative<br><span class="hljs-symbol">top:</span> <span class="hljs-number">50</span>%<br><span class="hljs-symbol">transform:</span> translateY(<span class="hljs-number">-50</span>%)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transform</title>
    <link href="/2022/06/23/transform/"/>
    <url>/2022/06/23/transform/</url>
    
    <content type="html"><![CDATA[<h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ul><li>对某些元素进行形变，如旋转，缩放，平移（通常行内级元素不能形变）</li></ul><h3 id="行内级元素无法形变"><a href="#行内级元素无法形变" class="headerlink" title="行内级元素无法形变"></a>行内级元素无法形变</h3><h3 id="常见的有"><a href="#常见的有" class="headerlink" title="常见的有"></a>常见的有</h3><ul><li>平移： translate（x ,y) &#x2F;&#x2F;可以用%参照为自身宽高</li><li>缩放：scale(x ,y)</li><li>旋转：rotate( x ,y)</li><li>倾斜：skew (deg ,deg)</li></ul><h3 id="缩放-scale"><a href="#缩放-scale" class="headerlink" title="缩放 - scale"></a>缩放 - scale</h3><ul><li>改变大小，不影响布局</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">transform</span>: scale(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) //<span class="hljs-number">1</span>为自身大小<br></code></pre></td></tr></table></figure><p>设置为数字的时候从左上角开始计算，只设一个值时就是X轴</p><h3 id="旋转-rotate"><a href="#旋转-rotate" class="headerlink" title="旋转 - rotate"></a>旋转 - rotate</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">90deg</span>)<br></code></pre></td></tr></table></figure><h2 id="形变起点"><a href="#形变起点" class="headerlink" title="形变起点"></a>形变起点</h2><ul><li>transform-origin：</li><li>默认为center center</li></ul><h2 id="倾斜-skew"><a href="#倾斜-skew" class="headerlink" title="倾斜 - skew"></a>倾斜 - skew</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">skew</span>(Xdge,Ydge)<br></code></pre></td></tr></table></figure><h2 id="transform设置多个值"><a href="#transform设置多个值" class="headerlink" title="transform设置多个值"></a>transform设置多个值</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">skew</span>(Xdge,Ydge)<br>transform: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">90deg</span>)<br>transform: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这样写的话后面的会覆盖前面，使前两行代码无效</p><p>正确的是</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">transform</span>: translate(<span class="hljs-number">50</span>px) scale(<span class="hljs-number">1</span>.<span class="hljs-number">2</span>) rotate(<span class="hljs-number">4</span>.<span class="hljs-number">5</span>deg)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的错误</title>
    <link href="/2022/06/21/hexo%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <url>/2022/06/21/hexo%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p> err: YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key (4:1)</p><p>可能是开头的title之类的 : 后面要加空格</p><h3 id="加本地图片"><a href="#加本地图片" class="headerlink" title="加本地图片"></a>加本地图片</h3><ul><li><p>要在source文件夹下创建一个images文件夹，把图片放在里面，在引用图片时</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">![](<span class="hljs-regexp">/images/</span>图片名称)<br></code></pre></td></tr></table></figure><p>在本地文本中不显示图片，但在服务器上会显示</p></li></ul><h2 id="err-Error-Spawn-failed"><a href="#err-Error-Spawn-failed" class="headerlink" title="err: Error: Spawn failed"></a>err: Error: Spawn failed</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">##进入站点根目录</span><br>cd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/src/</span>hexo<span class="hljs-regexp">/hanyubolg/</span><br><br><span class="hljs-comment">##删除git提交内容文件夹</span><br>rm -rf .deploy_git/<br><br><span class="hljs-comment">##执行</span><br>git config --global core.autocrlf false<br><br><span class="hljs-comment">##最后</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br>————————————————<br>版权声明：本文为CSDN博主「wei-xiansen」的原创文章，遵循CC <span class="hljs-number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/weixin_41256398/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">117994899</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex</title>
    <link href="/2022/06/21/flex/"/>
    <url>/2022/06/21/flex/</url>
    
    <content type="html"><![CDATA[<h2 id="flex基本特性"><a href="#flex基本特性" class="headerlink" title="flex基本特性"></a>flex基本特性</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">display: flex;<br>display: <span class="hljs-keyword">inline</span>-flex <span class="hljs-comment">//行内元素</span><br></code></pre></td></tr></table></figure><h3 id="排列布局"><a href="#排列布局" class="headerlink" title="排列布局"></a>排列布局</h3><ul><li><p>在里面的块级元素会按照主轴方向排列一排，在添加换行代码前不会换行，目前已知内部的块级元素宽度相同时，在内部宽度超过当前元素的宽度时，内部元素的宽度会改变成适应当前元素均等宽度</p></li><li><p>主轴方向默认左到右，可以上到下，也可以将主轴头尾置换</p></li></ul><h3 id="改变主轴方向"><a href="#改变主轴方向" class="headerlink" title="改变主轴方向"></a>改变主轴方向</h3>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">flex-direction: <span class="hljs-keyword">row</span> | <span class="hljs-keyword">row</span>-<span class="hljs-keyword">reverse</span> | <span class="hljs-keyword">column</span> | <span class="hljs-keyword">column</span>-<span class="hljs-keyword">reverse</span><br></code></pre></td></tr></table></figure><p>  reverse是将主轴头尾置换</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">flex-<span class="hljs-built_in">wrap</span>: newrap | <span class="hljs-built_in">wrap</span> | <span class="hljs-built_in">wrap</span>-<span class="hljs-built_in">reverse</span>;<br></code></pre></td></tr></table></figure><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">justify-content: flex-start | <span class="hljs-type">flex</span>-<span class="hljs-keyword">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">space</span>-between | <span class="hljs-type">space_around</span><br></code></pre></td></tr></table></figure><p>start ： 左对齐(头)</p><p>end ： 右对齐(尾)</p><p>center： 居中对齐</p><p>between：两边对齐</p><h2 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h2><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sml">flex-flow: &lt; <span class="hljs-symbol">&#x27;flex</span>-direction&#x27; &gt; || &lt; <span class="hljs-symbol">&#x27;flex</span>-wrap&#x27; &gt;<br></code></pre></td></tr></table></figure><ul><li>顺序任意，且都可以省略</li></ul><h3 id="Y轴对齐"><a href="#Y轴对齐" class="headerlink" title="Y轴对齐"></a>Y轴对齐</h3><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">align-items: stretch | <span class="hljs-type">flex</span>-start | <span class="hljs-type">flex</span>-<span class="hljs-keyword">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">baseline</span><br></code></pre></td></tr></table></figure><ul><li>stretch： 在元素高度为auto的情况下，该元素会被拉伸</li><li>start: 顶端对齐</li><li>end：低端对齐</li><li>center：居中对齐</li><li>baseline：基线对齐（文本底部？）</li></ul><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p><img src="/images/content.jpg" alt="content"></p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><ul><li>在子元素的宽度总和未达到父元素宽度时，给flex的子元素设置</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span>: X<br></code></pre></td></tr></table></figure><p>X为数字，会将父元素剩余的宽度分给子元素，分配机制为，子元素的X加起来，将剩余宽度分为X份，在根据子元素的X在分配宽度。当所有子元素X一样时，均分。</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><ul><li><p>在子元素宽度总和超过父元素宽度时使用，默认为1，所以在不设置的情况下会出现子元素被压缩的情景。当设置为0时，子元素可以溢出父元素宽度，不在压缩。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-shrink</span>: X<br></code></pre></td></tr></table></figure><p>分配机制和grow一样。</p><p>flex itmes 压缩后的最终size不能小于min-width\min-height</p></li></ul><h3 id="少用"><a href="#少用" class="headerlink" title="少用"></a>少用</h3><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-basis</span>:X<br></code></pre></td></tr></table></figure><p>在内容不多时和width一样，但当内容超出宽度是，可以将盒子的宽度延申。</p><h2 id="flex简写"><a href="#flex简写" class="headerlink" title="flex简写"></a>flex简写</h2><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sml">flex: none | &lt;<span class="hljs-symbol">&#x27;flex</span>-grow&#x27;&gt; &lt; <span class="hljs-symbol">&#x27;flex</span>-shrink&#x27;&gt;? || &lt;<span class="hljs-symbol">&#x27;flex</span>-basis&#x27;&gt;<br></code></pre></td></tr></table></figure><p>无单位的值就是gorw或shrink，且输入的第一个无单位值默认为gorw</p><h2 id="也许有用"><a href="#也许有用" class="headerlink" title="也许有用"></a>也许有用</h2><ul><li><p>在flex布局中使用 </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">display</span><span class="hljs-punctuation">: </span>flex<br><span class="hljs-attribute">flex-wrap</span><span class="hljs-punctuation">: </span>wrap<br><span class="hljs-attribute">justify-conent</span><span class="hljs-punctuation">: </span>space-between<br></code></pre></td></tr></table></figure><p>的情况下，最后一行元素不够时，会两端对齐，这样中间就没有内容，不够雅观。为了最后一行也可以按顺序排列，我们可以这样做</p><ul><li>在flex盒子的最下层添加个数为（列数-2）的span（i也可以），并将赋予他们宽度，宽度可以为flex内盒子的宽度，这样，span就会将最后一行剩余的盒子数填充，而且不显示，在视图中，则是最后一行是按顺序排列的，达到了我们想要的效果。因为span并没有设置高度和内容，所以他不会破坏flex结构。</li></ul></li></ul><h2 id="当flex设为0时"><a href="#当flex设为0时" class="headerlink" title="当flex设为0时"></a>当flex设为0时</h2><ul><li><p>会发现盒子的宽度变得很小</p></li><li><p>当给flex一个自然数时，flex-basis的值会变为0.而flex的值为1时，盒子的宽度还会增长，就没有问题。当flex为0时就出现了问题</p></li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3>  <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">flex:</span> <span class="hljs-number">0</span> <span class="hljs-keyword">auto</span><br></code></pre></td></tr></table></figure><h2 id="内容溢出盒子"><a href="#内容溢出盒子" class="headerlink" title="内容溢出盒子"></a>内容溢出盒子</h2><ul><li><p>有时会出现给盒子设置文本时会溢出盒子，此时设置宽度也无效。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.father</span> &#123;<br>dusplay: <span class="hljs-attribute">flex</span><br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br><span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时无效的话可给子元素加个</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.son</span> &#123;<br><span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">width</span>: <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在网上看到第二个解决办法，是加个overf：hidden 但我那个本来也要加，就不知道有没有效果。还有在检查样式时发现用外部引入的样式可能会用不了，在浏览器的检查模式中是灰的。不知道什么问题，不过只要在style里添加就可以了</p><ul><li><p>第二种办法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.son</span> &#123;<br><span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">overflow</span>: hidden<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>emmet语法</title>
    <link href="/2022/06/20/emmet%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/06/20/emmet%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/emmet1.jpg" alt="avatar"></p><p><img src="/images/emmet2.jpg" alt="avatar"></p><p><img src="/images/emmet3.jpg" alt="avatar"></p><p><img src="/images/emmet4.jpg" alt="avatar"></p><p><img src="/images/emmet5.jpg" alt="avatar"></p><p><img src="/images/emmet6.jpg" alt="avatar"></p><p>![avatar](&#x2F;images&#x2F;css emmet.jpg)</p>]]></content>
    
    
    
    <tags>
      
      <tag>ccs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础</title>
    <link href="/2022/06/20/CSS%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/06/20/CSS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="margin元素的传递"><a href="#margin元素的传递" class="headerlink" title="margin元素的传递"></a>margin元素的传递</h3><ul><li>当块级子元素和父元素的顶端对齐时，对子元素的margin-top会生效到父元素上</li></ul><h4 id="防止"><a href="#防止" class="headerlink" title="防止"></a>防止</h4><ul><li><p>不使用margin而是使用padding</p></li><li><p>给父元素设置border</p></li><li><p>触发BFC： 设置overflow为auto</p></li></ul><h2 id="快速均等排列"><a href="#快速均等排列" class="headerlink" title="快速均等排列"></a>快速均等排列</h2><ul><li>在父盒子输入display flex属性时在子盒子添加一个相同的类，并在类中添加flex：1的属性便会实现盒子平均横向排列</li></ul><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><ul><li>clear属性可以指定一个元素是否必须移动（清除浮动后）到在它之前的浮动元素下面；</li><li>left：顶部低于左浮动元素底部</li><li>right：右浮动</li><li>both： 所有</li></ul><h3 id="BFC解决高度塌陷"><a href="#BFC解决高度塌陷" class="headerlink" title="BFC解决高度塌陷"></a>BFC解决高度塌陷</h3><ul><li>给父元素一个BFC和height：auto，可以给父元素一个overflow: auto;以创建一个BFC</li></ul><h3 id="伪元素清除浮动"><a href="#伪元素清除浮动" class="headerlink" title="伪元素清除浮动"></a>伪元素清除浮动</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.X</span><span class="hljs-selector-pseudo">::after</span> &#123;<br><span class="hljs-attribute">display</span>: block;<br><span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span><br>clear: both<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><ul><li>align-items 属性为弹性容器内的项目指定默认对齐方式。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p>将弹性 <div> 元素的所有项目的居中对齐</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">align-items: stretch|<span class="hljs-type">center</span>|<span class="hljs-type">flex</span>-start|<span class="hljs-type">flex</span>-<span class="hljs-keyword">end</span>|<span class="hljs-type">baseline</span>|<span class="hljs-type">initial</span>|<span class="hljs-type">inherit</span>;<br></code></pre></td></tr></table></figure><ul><li>stretch  默认。项目被拉伸以适合容器。</li><li>center  项目位于容器中央</li><li>flex-start 开头</li><li>flex-end  末端</li><li>baseline   基线</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定位</title>
    <link href="/2022/06/20/%E5%AE%9A%E4%BD%8D/"/>
    <url>/2022/06/20/%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">position: relative<br></code></pre></td></tr></table></figure><ul><li>依旧在文档流占据位置</li><li>移动时参照自身原本的位置</li></ul><h4 id="保持图片在中心位置"><a href="#保持图片在中心位置" class="headerlink" title="保持图片在中心位置"></a>保持图片在中心位置</h4><ul><li><p>在改变浏览器宽度时，让图片的中心跟随浏览器中心的改变而改变</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">position: relative<br>left: -(图片一半)px<br>margin-left: 50%<br></code></pre></td></tr></table></figure><p>上面的margin-left继承于父元素</p></li></ul><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">position: absolute<br></code></pre></td></tr></table></figure><ul><li>不占据文档流的位置</li><li>移动时参照最近的定位祖先元素</li></ul><h2 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">position: fixed<br></code></pre></td></tr></table></figure><ul><li>不占据文档流位置</li><li>参照为浏览器视口</li></ul><h2 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">position: sticky<br></code></pre></td></tr></table></figure><ul><li>在移动到某个阈值点前和相对定位表现一样</li><li>在达到阈值点后便固定于视口</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS注意事项</title>
    <link href="/2022/06/20/CSS%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2022/06/20/CSS%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h1><h2 id="nth-child"><a href="#nth-child" class="headerlink" title="nth-child"></a>nth-child</h2><ul><li>nth-child(2n) 选择所有偶数后代  </li><li>可以使用::after并在里面添加</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">.<span class="hljs-literal">right</span>-area <span class="hljs-keyword">a</span>:<span class="hljs-keyword">first</span>-child<br></code></pre></td></tr></table></figure><ul><li>用的时候请精确到具体元素</li></ul><h2 id="margin-top"><a href="#margin-top" class="headerlink" title="margin-top"></a>margin-top</h2><p>百分比是相对于父元素的<code>**宽度**</code></p><h3 id="行内级元素无法用transform"><a href="#行内级元素无法用transform" class="headerlink" title="行内级元素无法用transform"></a>行内级元素无法用transform</h3><p>标签与标签之间换行的话中间有个空格，会占据宽度，影响布局</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/19/hello-world/"/>
    <url>/2022/06/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
