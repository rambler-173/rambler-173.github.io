<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>v-model</title>
    <link href="/2022/08/30/v-model/"/>
    <url>/2022/08/30/v-model/</url>
    
    <content type="html"><![CDATA[<h2 id="v-model的基本使用"><a href="#v-model的基本使用" class="headerlink" title="v-model的基本使用"></a><strong>v</strong>-model的基本使用</h2><ul><li><p><strong>表单提交</strong>是开发中非常常见的功能，也是和用户交互的重要手段：</p><ul><li>比如用户在登录、注册时需要提交账号密码；</li><li>比如用户在检索、创建、更新信息时，需要提交一些数据；</li></ul></li><li><p>这些都要求我们可以在<strong>代码逻辑中获取到用户提交的数据</strong>，我们通常会使用<strong>v-model</strong>指令来完成：</p><ul><li>v-model指令可以在表单 input、textarea以及select元素上创建双向数据绑定；</li><li>它会根据控件类型自动选取正确的方法来更新元素；</li><li>尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理；</li></ul></li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">1.手动的实现了双向绑定</span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;inputChange&quot;</span>&gt;</span></span><br><span class="language-xml">       methods: </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">     inputChange(event) &#123;</span><br><span class="hljs-template-variable">       this.message = event.target.value</span><br><span class="hljs-template-variable">     &#125;</span><span class="language-xml">,</span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- 2.v-model实现双向绑定 --&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>       </span><br><span class="language-xml">//双向绑定实现了用户输入将数据改变</span><br></code></pre></td></tr></table></figure><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Vue Model.png)</p><h3 id="v-model绑定checkbox"><a href="#v-model绑定checkbox" class="headerlink" title="v-model绑定checkbox"></a><strong>v</strong>-model绑定checkbox</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">label</span> <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;agree&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">input</span> id=<span class="hljs-string">&quot;agree&quot;</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt; 同意协议<br>&lt;/<span class="hljs-keyword">label</span>&gt;<br></code></pre></td></tr></table></figure><ul><li><p>将id和for设置成一样的值，这样当点击同意协议文字时，单选框也可以被选中</p></li><li><p><strong>我们来看一下</strong>v-model绑定checkbox：单个勾选框和多个勾选框</p></li><li><p>单个勾选框：</p></li><li><ul><li>v-model即为布尔值。</li><li>此时input的value属性并不影响v-model的值。</li></ul></li><li><p><strong>多个复选框：</strong></p></li><li><ul><li>当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。</li><li>当选中某一个时，就会将input的value添加到数组中。</li></ul></li></ul><h3 id="v-model绑定radio"><a href="#v-model绑定radio" class="headerlink" title="v-model绑定radio"></a><strong>v</strong>-model绑定radio</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span> 男</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span> 女</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>性别: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">gender</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>v-model绑定同一个值时label也会互斥</li></ul><h2 id="v-model的值绑定"><a href="#v-model的值绑定" class="headerlink" title="v-model的值绑定"></a><strong>v</strong>-model的值绑定</h2><ul><li><p><strong>目前我们在前面的案例中</strong>大部分的值都是在template中固定好的：</p><ul><li>比如gender的两个输入框值male、female；</li><li>比如hobbies的三个输入框值basketball、football、tennis；</li></ul></li><li><p>在真实开发中，我们的数据可能是来自服务器的，那么我们就可以先将值请求下来，绑定到data返回的对象中，再通过v-bind来进行值的绑定，这个过程就是<strong>值绑定</strong>。</p><ul><li>将里面的数据变成动态的就是值绑定</li></ul></li></ul><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-comment">&lt;!-- 1.select的值绑定 --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">multiple</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;fruits&quot;</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in allFruits&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">             <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.value&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">             <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;item.value&quot;</span>&gt;</span></span><br><span class="language-xml">       </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.text</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>多选: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">fruits</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">   <span class="hljs-comment">&lt;!-- 2.checkbox的值绑定 --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>请选择你的爱好:<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in allHobbies&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.value&quot;</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">:for</span>=<span class="hljs-string">&quot;item.value&quot;</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;item.value&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;hobbies&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;item.value&quot;</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.text</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>爱好: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">hobbies</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-comment">// 1.创建app</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-comment">// data: option api</span></span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-comment">// 水果</span></span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">allFruits</span>: [</span></span><br><span class="language-javascript"><span class="language-xml">           &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;苹果&quot;</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">           &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;橘子&quot;</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">           &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;香蕉&quot;</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">         ],</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">fruits</span>: [],</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-comment">// 爱好</span></span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">allHobbies</span>: [</span></span><br><span class="language-javascript"><span class="language-xml">           &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;sing&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;唱&quot;</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">           &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;jump&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;跳&quot;</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">           &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;rap&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;rap&quot;</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">           &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;basketball&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;篮球&quot;</span> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">         ],</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">hobbies</span>: []</span></span><br><span class="language-javascript"><span class="language-xml">       &#125;</span></span><br><span class="language-javascript"><span class="language-xml">     &#125;</span></span><br><span class="language-javascript"><span class="language-xml">   &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-comment">// 2.挂载app</span></span></span><br><span class="language-javascript"><span class="language-xml">   app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="v-mode修饰符"><a href="#v-mode修饰符" class="headerlink" title="v-mode修饰符"></a><strong>v</strong>-mode修饰符</h3><h5 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a><strong>lazy</strong></h5><ul><li>n*<em>lazy</em>***修饰符是什么作用呢？<ul><li>默认情况下，v-model在进行双向绑定时，绑定的是input事件，那么会在每次内容输入后就将最新的值和绑定的属性进行同步；</li><li>如果我们在v-model后跟上lazy修饰符，那么会将绑定的事件切换为 change 事件，只有在提交时（比如回车）才会触发；</li></ul></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> v-model.<span class="hljs-attribute">lazy</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><ul><li><p><strong>我们先来看一下****v-model绑定后的值是什么类型的：</strong></p><ul><li>message总是string类型，即使在我们设置type为number也是string类型；</li></ul></li><li><p><strong>如果我们希望转换为</strong>数字类型，那么可以使用 <strong>.number</strong> <strong>修饰符</strong>：</p></li><li><pre><code class="hljs">&lt;input type=&quot;text&quot; v-model.number=&quot;counter&quot;&gt;</code></pre></li><li><p>n<strong>另外，在我们进行****逻辑判断时，如果是一个string类型，在可以转化的情况下会进行隐式转换的：</strong></p><ul><li>下面的score在进行判断的过程中会进行隐式转化的；</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>购物车案例</title>
    <link href="/2022/08/29/%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%A1%88%E4%BE%8B/"/>
    <url>/2022/08/29/%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src="C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Vue-Cart.png"></p><ul><li>如何绑定购买数量，直接给按钮设置this.count无法绑定</li><li>移除按钮如何操作</li><li>计算总价</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript">计算总价<br>     <span class="hljs-attr">computed</span>: &#123;<br>        <span class="hljs-title function_">totalPrice</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-number">1.</span>直接遍历books<br>          <span class="hljs-keyword">let</span> price = <span class="hljs-number">0</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">books</span>) &#123;<br>            price += item.<span class="hljs-property">price</span> * item.<span class="hljs-property">count</span><br>          &#125;<br>          <span class="hljs-keyword">return</span> price<br><br>          <span class="hljs-number">2.</span><span class="hljs-title function_">reduce</span>(自己决定)<br>          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">books</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">preValue, item</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> preValue + item.<span class="hljs-property">price</span> * item.<span class="hljs-property">count</span><br>          &#125;, <span class="hljs-number">0</span>)  <span class="hljs-comment">//数组内的方法，第一个参数为回调参数，第二个为定义初始化preValue的值</span><br>        &#125;<br>      &#125;,<br>      <br>绑定数量<br>        <span class="hljs-comment">// 监听-和+操作</span><br>        <span class="hljs-title function_">decrement</span>(<span class="hljs-params">index, item</span>) &#123;  <span class="hljs-comment">//item的是第二种方法，直接传item进来而不是index</span><br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击-&quot;</span>)<br>          <span class="hljs-comment">// this.books[index].count--  //传index的方法</span><br>          item.<span class="hljs-property">count</span>--  <span class="hljs-comment">//传item的方法</span><br>        &#125;,<br>        <span class="hljs-title function_">increment</span>(<span class="hljs-params">index, item</span>) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击+:&quot;</span>, index)<br>          <span class="hljs-comment">// this.books[index].count++</span><br>          item.<span class="hljs-property">count</span>++<br>        &#125;,  <span class="hljs-comment">//index需要传参</span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in books&quot;</span>  //<span class="hljs-attr">v-for</span>里有要点击事件时就需要穿<span class="hljs-attr">index</span></span></span><br><span class="hljs-tag"><span class="language-xml">          &lt;<span class="hljs-attr">button</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;item.count &lt;= 1&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrement(index, item)&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  //</span><br><span class="language-xml">          &#123;&#123; item.count &#125;&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment(index, item)&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">          </span><br><span class="language-xml">移出按钮</span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;removeBook(index, item)&quot;</span>&gt;</span>移除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                removeBook(index, item) &#123;</span><br><span class="language-xml">                  this.books.splice(index, 1)</span><br><span class="language-xml">                &#125;,</span><br></code></pre></td></tr></table></figure><ul><li>动态添加class</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-meta">:class=&quot;&#123; active:</span> index === currentIndex &#125;&quot;  //&#123; class:boolen &#125;<br><span class="hljs-code">         currentIndex: 0</span><br><span class="hljs-code">        rowClick(index) &#123;</span><br><span class="hljs-code">          this.currentIndex = index</span><br><span class="hljs-code">        &#125;</span><br></code></pre></td></tr></table></figure><ul><li>当鼠标点击目标时，他的currentIndex变成等于index，也就是true</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue的计算属性</title>
    <link href="/2022/08/29/vue%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/08/29/vue%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="computed计算属性使用"><a href="#computed计算属性使用" class="headerlink" title="computed计算属性使用"></a><strong>computed</strong>计算属性使用</h3><h4 id="复杂data的处理方式"><a href="#复杂data的处理方式" class="headerlink" title="复杂data的处理方式"></a><strong>复杂</strong>data的处理方式</h4><ul><li><p>我们知道，在模板中可以直接通过<strong>插值语法</strong>显示一些data中的数据。</p></li><li><p>但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示；</p><ul><li>比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示；</li><li>在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算；</li><li>在模板中放入太多的逻辑会让模板过重和难以维护；</li><li>并且如果多个地方都使用到，那么会有大量重复的代码；</li></ul></li><li><p><strong>我们有没有什么方法可以将逻辑抽离出去呢？</strong></p><ul><li>可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中；</li><li>但是，这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用；</li><li>另外一种方式就是使用计算属性computed；</li></ul></li></ul><h3 id="认识计算属性computed"><a href="#认识计算属性computed" class="headerlink" title="认识计算属性computed"></a><strong>认识计算属性</strong>computed</h3><ul><li><p><strong>什么是计算属性呢？</strong></p><ul><li>官方并没有给出直接的概念解释；</li><li>而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用<strong>计算属性</strong>；</li><li>计算属性将被混入到组件实例中<ul><li>所有 getter 和 setter 的 this 上下文自动地绑定为组件实例；</li></ul></li></ul></li><li><p><strong>计算属性的用法：</strong></p><ul><li>选项：<strong>computed</strong></li><li>类型：{ [key: string]: Function | { get: Function, set: Function } }</li></ul></li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Vue Complate.png)</p><ul><li>计算属性更加清晰</li><li>并且计算属性是有缓存的</li></ul><h4 id="计算属性的缓存"><a href="#计算属性的缓存" class="headerlink" title="计算属性的缓存"></a><strong>计算属性的缓存</strong></h4><ul><li><p><strong>这是什么原因呢？</strong></p><ul><li>这是因为计算属性会基于它们的依赖关系进行缓存；</li><li>在数据不发生变化时，计算属性是不需要重新计算的；</li><li>但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算；</li></ul></li><li><h3 id="计算属性的setter和getter"><a href="#计算属性的setter和getter" class="headerlink" title="计算属性的setter和getter"></a><strong>计算属性的</strong>setter和getter</h3></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">语法糖的写法<br>fullname() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstname + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">this</span>.lastname<br>&#125;,<br><br>完整的写法:<br>fullname: &#123;<br>  <span class="hljs-keyword">get</span>: function() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstname + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">this</span>.lastname<br>  &#125;,<br></code></pre></td></tr></table></figure><ul><li>set方法用的很少</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v-for中的Options API</title>
    <link href="/2022/08/29/v-for%E4%B8%AD%E7%9A%84Options-API/"/>
    <url>/2022/08/29/v-for%E4%B8%AD%E7%9A%84Options-API/</url>
    
    <content type="html"><![CDATA[<h2 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h2><h3 id="认识侦听器watch"><a href="#认识侦听器watch" class="headerlink" title="认识侦听器watch"></a><strong>认识侦听器</strong>watch</h3><ul><li><p><strong>什么是侦听器呢？</strong></p><ul><li>开发中我们在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中；</li><li>当数据变化时，template会自动进行更新来显示最新的数据；</li><li>但是在某些情况下，我们希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成了；</li></ul></li><li><p><strong>侦听器的用法如下：</strong></p><ul><li>选项：<strong>watch</strong></li><li>类型：**{ [key: string]: string | Function | Object | Array}**</li></ul></li></ul><h3 id="侦听器watch的配置选项"><a href="#侦听器watch的配置选项" class="headerlink" title="侦听器watch的配置选项"></a><strong>侦听器</strong>watch的配置选项</h3><ul><li><p><strong>我们先来看一个例子：</strong></p><ul><li>当我们点击按钮的时候会修改info.name的值；</li><li>这个时候我们使用watch来侦听info，可以侦听到吗？答案是不可以。</li></ul></li><li><p>这是因为默认情况下，<strong>watch****只是在侦听info的引用变化</strong>，对于<strong>内部属性的变化是不会做出响应</strong>的：</p><ul><li>这个时候我们可以使用一个选项deep进行更深层的侦听；</li><li>注意前面我们说过watch里面侦听的属性对应的也可以是一个Object；</li></ul></li><li><p>还有<strong>另外一个属性</strong>，是<strong>希望一开始的就会立即执行一次</strong>：</p><ul><li><p>这个时候我们使用immediate选项；</p></li><li><p>这个时候无论后面数据是否有变化，侦听的函数都会有限执行一次；</p></li></ul></li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Vue Watch.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v-for中的key</title>
    <link href="/2022/08/29/v-for%E4%B8%AD%E7%9A%84key/"/>
    <url>/2022/08/29/v-for%E4%B8%AD%E7%9A%84key/</url>
    
    <content type="html"><![CDATA[<h2 id="v-for中的key是什么作用？"><a href="#v-for中的key是什么作用？" class="headerlink" title="v-for中的key是什么作用？"></a><strong>v-for</strong>中的key是什么作用？</h2><ul><li><p><strong>在使用</strong>v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性。</p></li><li><p>这个key属性有什么作用呢？我们先来看一下官方的解释：**</p><ul><li>key属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes；</li><li>如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改&#x2F;复用相同类型元素的算法；</li><li>而使用key时，它会基于key的变化重新排列元素顺序，并且会移除&#x2F;销毁key不存在的元素；</li></ul></li><li><p><strong>官方的解释对于初学者来说并不好理解，比如下面的问题：</strong></p><ul><li>什么是新旧nodes，什么是VNode？</li><li>没有key的时候，如何尝试修改和复用的？</li><li>有key的时候，如何基于key重新排列的？</li></ul></li></ul><h3 id="认识VNode"><a href="#认识VNode" class="headerlink" title="认识VNode"></a><strong>认识</strong>VNode</h3><ul><li>我们先来解释一下VNode的概念：<ul><li>因为目前我们还没有比较完整的学习组件的概念，所以目前我们先理解HTML元素创建出来的VNode；</li><li>VNode的全称是Virtual Node，也就是虚拟节点；</li><li>事实上，无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode；</li><li>VNode的本质是一个JavaScript的对象；</li></ul></li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Vue VNode.png)</p><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><ul><li><strong>如果我们不只是一个简单的</strong>div<strong><strong>，而是有一大堆的元素，那么它们应该会形成一个</strong></strong>VNode Tree：</li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Vue VDom.png)</p><h2 id="因为虚拟DOM是一个对象，所以方便跨平台编辑"><a href="#因为虚拟DOM是一个对象，所以方便跨平台编辑" class="headerlink" title="因为虚拟DOM是一个对象，所以方便跨平台编辑"></a>因为虚拟DOM是一个对象，所以方便跨平台编辑</h2><h2 id="有key的diff算法"><a href="#有key的diff算法" class="headerlink" title="有key的diff算法"></a><strong>有</strong>key的diff算法</h2><ul><li><p>当要在li元素或其他元素中插入一个值或是其他什么东西的时候，有key和没有keyvue的处理方式不一样。有key的更快捷高效</p></li><li><p>我们可以确定的是，这次更新对于ul和button是不需要进行更新，需要更新的是我们li的列表：</p><ul><li>在Vue中，对于相同父元素的子元素节点并不会重新渲染整个列表；</li><li>因为对于列表中 a、b、c、d它们都是没有变化的；</li><li>在操作真实DOM的时候，我们只需要在中间插入一个f的li即可；</li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Vue DiffNo.png)</p></li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Vue DiffOne.png)</p><p>![Vue DiffT](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Vue DiffT.png)</p><p>![Vue DiffTh](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Vue DiffTh.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v-for</title>
    <link href="/2022/08/28/v-for/"/>
    <url>/2022/08/28/v-for/</url>
    
    <content type="html"><![CDATA[<h2 id="v-for的基本使用"><a href="#v-for的基本使用" class="headerlink" title="v-for的基本使用"></a>v-for的基本使用</h2><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-comment">&lt;!-- 1.电影列表进行渲染 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>电影列表<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;movie in movies&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">movie</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2.电影列表同时有索引 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(movie, index) in movies&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">index</span> + <span class="hljs-number">1</span>&#125;&#125;</span><span class="language-xml"> - </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">movie</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 3.遍历数组复杂数据 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>商品列表<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in products&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>商品: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.name</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>价格: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.price</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>秒杀: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.desc</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">     movies: [&quot;星际穿越&quot;, &quot;少年派&quot;, &quot;大话西游&quot;, &quot;哆啦A梦&quot;],</span><br><span class="language-xml"></span><br><span class="language-xml">      // 2.数组: 存放的是对象</span><br><span class="language-xml">      products: [</span><br><span class="language-xml">        &#123; id: 110, name: &quot;Macbook&quot;, price: 9.9, desc: &quot;9.9秒杀, 快来抢购!&quot; &#125;,</span><br><span class="language-xml">        &#123; id: 111, name: &quot;iPhone&quot;, price: 8.8, desc: &quot;9.9秒杀, 快来抢购!&quot; &#125;,</span><br><span class="language-xml">        &#123; id: 112, name: &quot;小米电脑&quot;, price: 9.9, desc: &quot;9.9秒杀, 快来抢购!&quot; &#125;,</span><br><span class="language-xml">      ]    </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>template</title>
    <link href="/2022/08/28/template/"/>
    <url>/2022/08/28/template/</url>
    
    <content type="html"><![CDATA[<h2 id="template元素"><a href="#template元素" class="headerlink" title="template元素"></a><strong>t</strong>emplate元素</h2><ul><li><p>因为v-if是一个指令，所以必须将其添加到一个元素上：</p><ul><li>但是如果我们希望切换的是多个元素呢？</li><li>此时我们渲染div，但是我们并不希望div这种元素被渲染；</li><li>这个时候，我们可以选择使用template；</li></ul></li><li><p>感觉等价于div元素</p></li><li><p><strong>template</strong>元素可以当做不可见的包裹元素，并且在v-if上使用，但是最终template不会被渲染出来：</p><ul><li>有点类似于小程序中的block</li></ul></li><li><p>似乎仅仅当作div元素而标签内没有其他属性比如v-if时内容不显示</p></li><li><p>不支持v-show</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v-bind</title>
    <link href="/2022/08/28/v-bind/"/>
    <url>/2022/08/28/v-bind/</url>
    
    <content type="html"><![CDATA[<h2 id="v-bind-的绑定属性"><a href="#v-bind-的绑定属性" class="headerlink" title="v-bind****的绑定属性"></a><strong>v</strong>-bind****的绑定属性</h2><ul><li><strong>前端讲的一系列指令，主要是将值插入到</strong>模板内容中。</li><li>但是，除了内容需要动态来决定外，某些属性我们也希望动态来绑定。<ul><li>比如动态绑定a元素的href属性；</li><li>比如动态绑定img元素的src属性；</li></ul></li></ul><h3 id="绑定基本属性"><a href="#绑定基本属性" class="headerlink" title="绑定基本属性"></a><strong>绑定基本属性</strong></h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 1.绑定img的src属性 --&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;showImgUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-comment">&lt;!-- 语法糖: v-bind -&gt; : --&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;showImgUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-comment">&lt;!-- 2.绑定a的href属性 --&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;href&quot;</span>&gt;</span>百度一下<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">   methods: </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">     switchImage: function() &#123;</span><br><span class="hljs-template-variable">       this.showImgUrl = this.showImgUrl === this.imgUrl1 ? this.imgUrl2: this.imgUrl1</span><br><span class="hljs-template-variable">     &#125;</span><span class="language-xml"></span><br><span class="language-xml">   &#125;</span><br></code></pre></td></tr></table></figure><h3 id="绑定class"><a href="#绑定class" class="headerlink" title="绑定class"></a>绑定class</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 1.基本绑定class --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classes&quot;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2.动态class可以写对象语法 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot; isActive ? &#x27;active&#x27;: &#x27;&#x27; &quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btnClick&quot;</span>&gt;</span>我是按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2.1.对象语法的基本使用(掌握) --&gt;</span> //</span><span class="hljs-template-variable">&#123;key： Boolean&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123; active: isActive &#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btnClick&quot;</span>&gt;</span>我是按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2.2.对象语法的多个键值对 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123; active: isActive, why: true, kobe: false &#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btnClick&quot;</span>&gt;</span>我是按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2.3.动态绑定的class是可以和普通的class同时的使用 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;abc cba&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123; active: isActive, why: true, kobe: false &#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btnClick&quot;</span>&gt;</span>我是按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2.4.动态绑定的class是可以和普通的class同时的使用 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;abc cba&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;getDynamicClasses()&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btnClick&quot;</span>&gt;</span>我是按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  //可以使用方法来获取对象</span><br><span class="language-xml"></span><br><span class="language-xml">    getDynamicClasses: function() </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">      return &#123; active: this.isActive, why: true, kobe: false &#125;</span><span class="language-xml"></span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">  &#125;</span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 3.动态class可以写数组语法(了解) --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#x27;abc&#x27;, &#x27;cba&#x27;]&quot;</span>&gt;</span>Hello Array<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#x27;abc&#x27;, className]&quot;</span>&gt;</span>Hello Array<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#x27;abc&#x27;, className, isActive? &#x27;active&#x27;: &#x27;&#x27;]&quot;</span>&gt;</span>Hello Array<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#x27;abc&#x27;, className, </span></span></span><span class="hljs-template-variable">&#123; active: isActive &#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">]&quot;</span>&gt;</span>Hello Array<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="绑定一个对象"><a href="#绑定一个对象" class="headerlink" title="绑定一个对象"></a><strong>绑定一个对象</strong></h3><ul><li><p>*<em>如果我们希望将一个</em>***对象的所有属性，绑定到元素上的所有属性，应该怎么做呢？</p><ul><li>非常简单，我们可以直接使用 v-bind 绑定一个 对象；</li></ul></li><li><p>案例：info对象会被拆解成div的各个属性</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;h2 v-bind=<span class="hljs-string">&quot;infos&quot;</span>&gt;</span><span class="hljs-attribute">Hello</span> Bind&lt;/h2&gt;<br><br><span class="hljs-attribute">infos</span>: &#123; name: <span class="hljs-string">&quot;why&quot;</span>, age: <span class="hljs-number">18</span>, height: <span class="hljs-number">1</span>.<span class="hljs-number">88</span>, address: <span class="hljs-string">&quot;广州市&quot;</span> &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVVM模型</title>
    <link href="/2022/08/28/MVVM%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/08/28/MVVM%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>声明式和命令式</title>
    <link href="/2022/08/28/%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%92%8C%E5%91%BD%E4%BB%A4%E5%BC%8F/"/>
    <url>/2022/08/28/%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%92%8C%E5%91%BD%E4%BB%A4%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="声明式和命令式"><a href="#声明式和命令式" class="headerlink" title="声明式和命令式"></a><strong>声明式和命令式</strong></h2>]]></content>
    
    
    
    <tags>
      
      <tag>base</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-one</title>
    <link href="/2022/08/27/vue-one/"/>
    <url>/2022/08/27/vue-one/</url>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h5 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h5><h2 id="data属性"><a href="#data属性" class="headerlink" title="data属性"></a>data属性</h2><ul><li><p>再vue2的时候我们可以直接在data里放一个对象，在对象中传入值就可以了</p></li><li><p>在vue3则不行了，我们必须传入一个函数，否则就会直接在浏览器中报错</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">data: <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//function可以省略</span><br><span class="hljs-keyword">return</span> &#123;<br>message: <span class="hljs-string">&#x27;hellp&#x27;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>data</strong>中返回的对象会被Vue的响应式系统劫持，之后对该对象的修改或者访问都会在劫持中被处理：</p><ul><li>所以我们在template或者app中通过  访问counter，可以从对象中获取到数据；</li><li>所以我们修改counter的值时，app中的 也会发生改变；</li></ul></li></ul><h4 id="data遍历"><a href="#data遍历" class="headerlink" title="data遍历"></a>data遍历</h4><ul><li><p>当你的data是一个数组且你引入是希望遍历其时</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in movies&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>直接再标签里添加for-in</li></ul></li></ul><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><ul><li><p>点击➕是count+1，点➖时count-1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button @click=<span class="hljs-string">&quot;increment&quot;</span>&gt;+<span class="hljs-number">1</span>&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrement&quot;</span>&gt;</span>-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span>++<br>    &#125;,<br>    <span class="hljs-attr">decrement</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span>--<br>    &#125;<br>  &#125;        <br></code></pre></td></tr></table></figure></li></ul><h3 id="Mustache双大括号语法"><a href="#Mustache双大括号语法" class="headerlink" title="Mustache双大括号语法"></a><strong>Mustache</strong>双大括号语法</h3><ul><li><strong>如果我们希望把数据显示到模板（</strong>template）中，使用最多的语法是 <strong>“</strong>Mustache”语法 **(**双大括号) 的文本插值。<ul><li>并且我们前端提到过，data返回的对象是有添加到Vue的响应式系统中；</li><li>当data中的数据发生改变时，对应的内容也会发生更新。</li><li>当然，Mustache中不仅仅可以是data中的属性，也可以是一个JavaScript的表达式。</li></ul></li></ul><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-comment">&lt;!-- 1.基本使用 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前计数: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">counter</span> &#125;&#125;</span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2.表达式 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>计数双倍: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">counter</span> * <span class="hljs-number">2</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>展示的信息: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">info.split</span>(<span class="hljs-name">&quot; &quot;</span>) &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 3.三元运算符 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">age</span> &gt;= <span class="hljs-number">18</span>? <span class="hljs-string">&quot;成年人&quot;</span>: <span class="hljs-string">&quot;未成年人&quot;</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 4.调用methods中函数 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">formatDate</span>(<span class="hljs-name">data</span>) &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 5.注意: 这里不能定义语句 --&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- &lt;h2&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">const</span> name = <span class="hljs-string">&quot;why&quot;</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-comment">&lt;/h2&gt; --&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  methods: &#123;</span><br><span class="language-xml">    formatDate: function(date) &#123;  //这里的data可以获取data里面的数据</span><br><span class="language-xml">      return &quot;2022-10-10-&quot; + date</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">  &#125;</span><br></code></pre></td></tr></table></figure><h5 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h5><ul><li>让指定标签内的数据只渲染一次。就是他在渲染数据后，你在外面修改数据不会改变里面的值</li></ul><h4 id="v-memo"><a href="#v-memo" class="headerlink" title="v-memo"></a>v-memo</h4><ul><li><p>指定标签内，有多个数据，指定一个数据，只有其更新时，其他数据才会跟着跟新。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-memo</span>=<span class="hljs-string">&quot;[name]&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">age</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">height</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程仓库</title>
    <link href="/2022/08/25/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2022/08/25/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="WHAT’s"><a href="#WHAT’s" class="headerlink" title="WHAT’s"></a>WHAT’s</h2><ul><li><p>什么是远程仓库（Remote Repository）呢？  </p><ul><li>目前我们的代码是保存在一个本地仓库中，也就意味着我们只是在进行本地操作；  </li><li>在真实开发中，我们通常是多人开发的，所以我们会将管理的代码共享到远程仓库中； ◼</li></ul></li><li><p>那么如何创建一个远程仓库呢？  </p><ul><li>远程仓库通常是搭建在某一个服务器上的（当然本地也可以，但是本地很难共享）； </li><li>所以我们需要在Git服务器上搭建一个远程仓库； ◼</li></ul></li><li><p>目前我们有如下方式可以使用Git服务器：  </p><ul><li>使用第三方的Git服务器：比如GitHub、Gitee、Gitlab等等；  </li><li>在自己服务器搭建一个Git服务</li></ul></li></ul><h2 id="管理远程服务器"><a href="#管理远程服务器" class="headerlink" title="管理远程服务器"></a>管理远程服务器</h2>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建git仓库</title>
    <link href="/2022/08/24/%E5%88%9B%E5%BB%BAgit%E4%BB%93%E5%BA%93/"/>
    <url>/2022/08/24/%E5%88%9B%E5%BB%BAgit%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h2><ul><li><p>打开git bush并输入git init（要先在git bush进入目标文件夹）</p></li><li><p>方式一：初始化Git仓库  </p><ul><li><p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的核心； </p></li><li><p>但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪；</p></li></ul></li></ul><h2 id="拿取远程仓库"><a href="#拿取远程仓库" class="headerlink" title="拿取远程仓库"></a>拿取远程仓库</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/coderwhy/</span>hy-react-web-music.git <br></code></pre></td></tr></table></figure><h2 id="文件的状态划分"><a href="#文件的状态划分" class="headerlink" title="文件的状态划分"></a>文件的状态划分</h2><h4 id="现在我们的电脑上已经有一个Git仓库：-"><a href="#现在我们的电脑上已经有一个Git仓库：-" class="headerlink" title="现在我们的电脑上已经有一个Git仓库： "></a>现在我们的电脑上已经有一个Git仓库： </h4><ul><li>在实际开发中，你需要将某些文件交由这个Git仓库来管理；  </li><li>并且我们之后会修改文件的内容，当达成某一个目标时，想要记录下来这次操作，就会将它提交到仓库中；</li></ul><h4 id="那么我们需要对文件来划分不同的状态，以确定这个文件是否已经归于Git仓库的管理："><a href="#那么我们需要对文件来划分不同的状态，以确定这个文件是否已经归于Git仓库的管理：" class="headerlink" title="那么我们需要对文件来划分不同的状态，以确定这个文件是否已经归于Git仓库的管理："></a>那么我们需要对文件来划分不同的状态，以确定这个文件是否已经归于Git仓库的管理：</h4><ul><li>未跟踪：默认情况下，Git仓库下的文件也没有添加到Git仓库管理中，我们需要通过add命令来操作；  </li><li>已跟踪：添加到Git仓库管理的文件处于已跟踪状态，Git可以对其进行各种跟踪管理；</li></ul><h4 id="已跟踪的文件又可以进行细分状态划分：-"><a href="#已跟踪的文件又可以进行细分状态划分：-" class="headerlink" title="已跟踪的文件又可以进行细分状态划分： "></a>已跟踪的文件又可以进行细分状态划分： </h4><ul><li>staged：暂缓区中的文件状态；  </li><li>Unmodified：commit命令，可以将staged中文件提交到Git仓库 </li><li>Modified：修改了某个文件后，会处于Modified状态；</li></ul><h4 id="在工作时，你可以选择性地将这些修改过的文件放入暂存区；"><a href="#在工作时，你可以选择性地将这些修改过的文件放入暂存区；" class="headerlink" title="在工作时，你可以选择性地将这些修改过的文件放入暂存区；"></a>在工作时，你可以选择性地将这些修改过的文件放入暂存区；</h4><h4 id="然后提交所有已暂存的修改，如此反复；"><a href="#然后提交所有已暂存的修改，如此反复；" class="headerlink" title="然后提交所有已暂存的修改，如此反复；"></a>然后提交所有已暂存的修改，如此反复；</h4><h2 id="git操作流程图"><a href="#git操作流程图" class="headerlink" title="git操作流程图"></a>git操作流程图</h2><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\git index.png)</p><h2 id="检测文件的状态-git-status"><a href="#检测文件的状态-git-status" class="headerlink" title="检测文件的状态 - git status"></a>检测文件的状态 - git status</h2><ul><li><p>我们在有Git仓库的目录下新建一个文件，查看文件的状态：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\git status.png)</p></li><li><p>◼ Untracked files：未跟踪的文件  </p><ul><li>未跟踪的文件意味着 Git 在之前的提交中没有这些文件；  </li><li>Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”；</li></ul></li><li><p>我们也可以查看更加简洁的状态信息：</p><ul><li>左栏指明了暂存区的状态，右栏指明了工作区的状态；</li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\git status-2.png)</p></li></ul><h2 id="文件添加到暂存区-–-git-add"><a href="#文件添加到暂存区-–-git-add" class="headerlink" title="文件添加到暂存区 – git add"></a>文件添加到暂存区 – git add</h2><h4 id="跟踪新文件命令："><a href="#跟踪新文件命令：" class="headerlink" title="跟踪新文件命令："></a>跟踪新文件命令：</h4><ul><li>&#96;&#96;&#96;<br>git add aaa.js<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 使用命令 git add 开始跟踪一个文件<br><br><span class="hljs-bullet">-</span> 通过git add . 将所有的文件添加到暂存区中<br><br><br><br><span class="hljs-section">### git忽略文件</span><br><br><span class="hljs-section">##### 一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在 未跟踪文件列表。  </span><br><br><span class="hljs-bullet">-</span> 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建 的临时文件等；  <br><span class="hljs-bullet">-</span> 我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模 式；<br><br><span class="hljs-section">##### 在实际开发中，这个文件通常不需要手动创建，在必须的时候添加自 己的忽略内容即可；</span><br><br><br><br><span class="hljs-section">## 文件更新提交 – git commit</span><br><br><span class="hljs-section">#####  现在的暂存区已经准备就绪，可以提交了。  </span><br><br><span class="hljs-bullet">-</span> 每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了；  <br><span class="hljs-bullet">-</span> 再运行提交命令 git commit；  <br><span class="hljs-bullet">-</span> 可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行;<br><span class="hljs-bullet">-</span> git commit –m &quot;提交信息&quot;<br><br>![](<span class="hljs-link">C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\git commit.png</span>)<br><br><span class="hljs-section">##### 如果我们修改文件的add操作，加上commit的操作有点繁琐，那么可以将两个命令结合来使用：</span><br><br><br><br><span class="hljs-section">### Git的校验和</span><br><br><span class="hljs-bullet">-</span> Git 中所有的数据在存储前都计算校验和，然后以 校验和 来引用。  <br><span class="hljs-bullet">  -</span> Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）；  <br><span class="hljs-bullet">  -</span> 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来；<br><br><br><br><span class="hljs-section">### 查看提交的历史 – git log</span><br><br><span class="hljs-bullet">-</span> 在提交了若干更新，又或者克隆了某个项目之后，有时候我们想要查看一下所有的历史提交记录。 ◼ <br><span class="hljs-bullet">-</span> 这个时候我们可以使用git log命令：<br><span class="hljs-bullet">  -</span> 不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面；  <br><span class="hljs-bullet">  -</span> 这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明；<br><br>![](<span class="hljs-link">C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\git log.png</span>)<br><br><span class="hljs-bullet">-</span> 这样看感觉很复杂，不够清晰<br><span class="hljs-bullet">-</span> git log --pretty=oneline<br><span class="hljs-bullet">-</span> ![](<span class="hljs-link">C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\git log --pretty.png</span>)<br><br><span class="hljs-bullet">-</span> 这看起来就舒服很多了<br><br><br><br><span class="hljs-section">### 版本回退 – git reset</span><br><br><span class="hljs-bullet">-</span> 如果想要进行版本回退，我们需要先知道目前处于哪一个版本：Git通过HEAD指针记录当前版本。  <br><span class="hljs-bullet">  -</span> HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交；  <br><span class="hljs-bullet">  -</span> 理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照；<br><br><span class="hljs-bullet">-</span> 我们可以通过HEAD来改变Git目前的版本指向：  <br><br><span class="hljs-bullet">  -</span> 上一个版本就是HEAD^，上上一个版本就是HEAD^^； <br><span class="hljs-bullet">  -</span>  如果是上1000个版本，我们可以使用HEAD~1000；  <br><span class="hljs-bullet">  -</span> 我们可以可以指定某一个commit id；<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```</span><br><span class="hljs-code">  git reset --hard HEAD^</span><br><span class="hljs-code">  git reset --hard HEAD~1000</span><br><span class="hljs-code">  git reset --hard 2d44982</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack建立本地服务器</title>
    <link href="/2022/08/23/webpack%E5%BB%BA%E7%AB%8B%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/08/23/webpack%E5%BB%BA%E7%AB%8B%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><ul><li><p>目前我们开发的代码，为了运行需要有两个操作： </p><ul><li> 操作一：npm run build，编译相关的代码； </li><li>操作二：通过live server或者直接通过浏览器，打开index.html代码，查看效果；</li></ul></li><li><p>这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成 编译 和 展示； ◼ </p></li><li><p>为了完成自动编译，webpack提供了几种可选的方式： </p><ul><li>webpack watch mode；  </li><li>webpack-dev-server（常用）；  </li><li>webpack-dev-middleware；</li></ul></li></ul><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><ul><li><p>上面的方式可以监听到文件的变化，但是事实上它本身是没有自动刷新浏览器的功能的：  </p><ul><li>当然，目前我们可以在VSCode中使用live-server来完成这样的功能；  </li><li>但是，我们希望在不适用live-server的情况下，可以具备live reloading（实时重新加载）的功能；</li></ul></li><li><p>安装webpack-dev-server</p></li><li><pre><code class="hljs">npm install webpack-dev-server -D<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 修改配置文件，启动时加上serve参数：<br><br>  - ```<br>    <span class="hljs-string">&quot;serve&quot;</span>: <span class="hljs-string">&quot;webpack serve --config wk.config.js&quot;</span> //在package.json的<span class="hljs-string">&quot;scripts&quot;</span>里<br></code></pre></td></tr></table></figure></code></pre></li><li></li></ul><h3 id="认识模块热替换（HMR）"><a href="#认识模块热替换（HMR）" class="headerlink" title="认识模块热替换（HMR）"></a>认识模块热替换（HMR）</h3><ul><li><p>◼ 什么是HMR呢？  </p><ul><li>HMR的全称是Hot Module Replacement，翻译为模块热替换；  </li><li>模块热替换是指在 应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面；</li></ul></li><li><p>HMR通过如下几种方式，来提高开发的速度：  </p><ul><li>不重新加载整个页面，这样可以保留某些应用程序的状态不丢失；  </li><li>只更新需要变化的内容，节省开发的时间；  </li><li>修改了css、js源代码，会立即在浏览器更新，相当于直接在浏览器的devtools中直接修改样式；</li></ul></li><li><p>如何使用HMR呢？ </p><ul><li>默认情况下，webpack-dev-server已经支持HMR，我们只需要开启即可（默认已经开启）；  </li><li>在不开启HMR的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是live reloading；</li></ul></li><li><p>修改webpack的配置</p><ul><li><pre><code class="hljs">devServer: &#123;    hot: true,    &#125;  //在webpack.config.js</code></pre></li><li></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node内的path模块</title>
    <link href="/2022/08/21/node%E5%86%85%E7%9A%84path%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/08/21/node%E5%86%85%E7%9A%84path%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="内置模块path"><a href="#内置模块path" class="headerlink" title="内置模块path"></a><strong>内置模块</strong>path</h2><ul><li><p><strong>path</strong>模块用于对路径和文件进行处理，提供了很多好用的方法。</p></li><li><p><strong>我们知道在</strong>Mac OS<strong>、</strong>Linux和window上的路径时不一样的</p></li><li><p><strong>那么如果我们在</strong>window上使用 来作为分隔符开发了一个应用程序，要部署到Linux上面应该怎么办呢？</p><ul><li>显示路径会出现一些问题；</li><li>所以为了屏蔽他们之间的差异，在开发中对于路径的操作我们可以使用 path 模块；</li></ul></li></ul><h3 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h3><ul><li><p>从路劲中获取信息</p><ul><li>dirname：获取文件的父文件夹；</li><li>basename：获取文件名；</li><li>extname：获取文件扩展名</li></ul></li><li><p><strong>路径的拼接：</strong>path.join</p><ul><li>如果我们希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符；</li><li>这个时候我们可以使用path.join函数；</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pnpm与软连接</title>
    <link href="/2022/08/21/pnpm%E4%B8%8E%E8%BD%AF%E8%BF%9E%E6%8E%A5/"/>
    <url>/2022/08/21/pnpm%E4%B8%8E%E8%BD%AF%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么是pnpm"><a href="#为什么是pnpm" class="headerlink" title="为什么是pnpm"></a>为什么是pnpm</h2><ul><li>可以在不同项目中下载的同一个包不会重复下载，节约空间。使用硬连接</li><li>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\pnpm first.png)</li></ul><h2 id="硬链接和软连接的概念"><a href="#硬链接和软连接的概念" class="headerlink" title="硬链接和软连接的概念"></a>硬链接和软连接的概念</h2><ul><li>硬链接（hard link）：</li><li> 硬链接（英语：hard link）是电脑文件系统中的多个文件平等地共享同一个文件存储单元；</li><li> 删除一个文件名字后，还可以用其它名字继续访问该文件；</li><li>符号链接（软链接soft link、Symbolic link）： <ul><li> 符号链接（软链接、Symbolic link）是一类特殊的文件；  其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用；</li></ul></li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\pnpm link.png)</p><ul><li>记得补充，面试可能会问</li></ul><h3 id="pnpm到底做了什么呢？"><a href="#pnpm到底做了什么呢？" class="headerlink" title="pnpm到底做了什么呢？"></a>pnpm到底做了什么呢？</h3><ul><li>当使用 npm 或 Yarn 时，如果你有 100 个项目，并且所有项目都有一个相同的依赖包，那么， 你在硬盘上就需要保存 100 份该相同依赖包的副本。</li><li>如果是使用 pnpm，依赖包将被 存放在一个统一的位置，因此：</li><li>如果你对同一依赖包使用相同的版本，那么磁盘上只有这个依赖包的一份文件；</li><li>如果你对同一依赖包需要使用不同的版本，则仅有 版本之间不同的文件会被存储起来； </li><li>所有文件都保存在硬盘上的统一的位置：<ul><li>当安装软件包时， 其包含的所有文件都会硬链接到此位置，而不会占用 额外的硬盘空间</li><li>这让你可以在项目之间方便地共享相同版本的 依赖包；</li></ul></li></ul><h3 id="pnpm创建非扁平的-node-modules-目录"><a href="#pnpm创建非扁平的-node-modules-目录" class="headerlink" title="pnpm创建非扁平的 node_modules 目录"></a>pnpm创建非扁平的 node_modules 目录</h3><ul><li><p>当使用 npm 或 Yarn Classic 安装依赖包时，所有软件包都将被提升到 node_modules 的 根目录下。（即扁平化，就是将包的文件夹都提升到一个目录下）</p><ul><li>其结果是，源码可以访问 本不属于当前项目所设定的依赖包</li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\pnpm pack.png)</p></li></ul><h2 id="pnpm的安装和使用"><a href="#pnpm的安装和使用" class="headerlink" title="pnpm的安装和使用"></a>pnpm的安装和使用</h2><ul><li><p>安装</p><ul><li><p>官网提供了很多种方式来安装pnpm：<a href="https://www.pnpm.cn/installation">https://www.pnpm.cn/installation</a> </p></li><li><p>Node中有npm，所以我们通过npm安装即可；</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g pnpm<br></code></pre></td></tr></table></figure></li></ul></li><li><p>以下是一个与 npm 等价命令的对照表，帮助你快速入门</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">npm 命令 pnpm 等价命令<br>npm install = pnpm install<br>npm install = <span class="hljs-symbol">&lt;pkg&gt;</span> pnpm <span class="hljs-built_in">add</span> <span class="hljs-symbol">&lt;pkg&gt;</span><br>npm uninstall = <span class="hljs-symbol">&lt;pkg&gt;</span> pnpm <span class="hljs-built_in">remove</span> <span class="hljs-symbol">&lt;pkg&gt;</span><br>npm run <span class="hljs-symbol">&lt;cmd&gt;</span> = pnpm <span class="hljs-symbol">&lt;cmd&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>更多命令和用法可以参考pnpm的官网：<a href="https://pnpm.io/zh/">https://pnpm.io/zh/</a></p></li></ul><h3 id="pnpm的存储store"><a href="#pnpm的存储store" class="headerlink" title="pnpm的存储store"></a>pnpm的存储store</h3><ul><li><p>在pnpm7.0之前，统一的存储位置是 ~&#x2F;.pnpm-score中的；</p></li><li><p>在pnpm7.0之后，统一的存储位置进行了更改：&#x2F;store</p><ul><li>在 Linux 上，默认是 ~&#x2F;.local&#x2F;share&#x2F;pnpm&#x2F;store </li><li>在 Windows 上： %LOCALAPPDATA%&#x2F;pnpm&#x2F;store </li><li>在 macOS 上： ~&#x2F;Library&#x2F;pnpm&#x2F;store</li></ul></li><li><p>我们可以通过一些终端命令获取这个目录：获取当前活跃的store目录</p><ul><li>&#96;&#96;&#96;<br>pnpm store path<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><br>- 另外一个非常重要的<span class="hljs-keyword">store</span>命令是prune（修剪）：从<span class="hljs-keyword">store</span>中删除当前未被引用的包来释放<span class="hljs-keyword">store</span>的空间<br><br>  - ```<br>    pnpm <span class="hljs-keyword">store</span> prune<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>包管理工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bootstrap</title>
    <link href="/2022/08/18/Bootstrap/"/>
    <url>/2022/08/18/Bootstrap/</url>
    
    <content type="html"><![CDATA[<h2 id="认识Bootstrap"><a href="#认识Bootstrap" class="headerlink" title="认识Bootstrap"></a>认识<strong>Bootstrap</strong></h2><h4 id="是一个非常受欢迎的前端框架，官方网站将其描述为"><a href="#是一个非常受欢迎的前端框架，官方网站将其描述为" class="headerlink" title="是一个非常受欢迎的前端框架，官方网站将其描述为"></a>是一个非常受欢迎的前端框架，官方网站将其描述为</h4><ul><li>最流行的 HTML、CSS 和 JS 框架，用于在 Web 上开发响应式、移动优先的项目。<ul><li>响应式页面：页面布局会随着屏幕尺寸的变化而自动调整布局，作用是适配各个屏幕</li></ul></li><li>Bootstrap是功能强大、可扩展，且功能丰富的前端工具包</li><li>Bootstrap底层是使用Sass构建，支持定制（Sass、Color、CSS variable ….）。</li><li>Bootstrap中的网格系统、组件以及强大的JavaScript 插件可以让我们快速搭建响应式网站</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>简单的文件结构，只需要懂HTML、CSS 和 JS 的基本知识，就可以上手使用Bootstrap，甚至阅读其源码，对于初学者来是说易于学习。</li><li>Bootstrap拥有一个强大的网格系统，它是由行和列组成，我们可以直接创建网格，无需自行编写媒体查询来创建。</li><li>Bootstrap预定义很多响应式的类。例如，给图片添加.img-responsive类，图片将会根据用户的屏幕尺寸自动调整图像大小，更方便我们去做各个屏幕的适配。另外Bootstrap 还提供了很多额外的工具类辅助我们进行网页开发。</li><li>Bootstrap框架提供的组件、插件、布局、栅格系统、响应式工具等等，可以为我们节省了大量的开发时间。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不适合高度定制类型的项目，因为Bootstrap具有统一的视觉风格，高度定制类的项目需要大量的自定义和样式覆盖。</li><li>Bootstrap的框架文件比较大(61KB JS + 159KB CSS)，资源文件过大会增加网站首屏加载的时间，并加重服务器的负担。</li><li>Bootstrap样式相对笨重，也会额外添加一些不必要的HTML元素，他会浪费一小部分浏览器的资源。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="Bootstrap-是一个前端框架。"><a href="#Bootstrap-是一个前端框架。" class="headerlink" title="Bootstrap 是一个前端框架。"></a>Bootstrap <strong>是一个前端框架。</strong></h4><ul><li>该框架主要是由CSS 和 JS组成，但是也会依赖一小部分的HTML。</li><li>因此在安装Bootstrap时，我们需要引入相应的CSS和JS文件，当然也需要添加一些全局的配置。</li><li>在Bootstrap 5 版本以前，Bootstrap是依赖jQuery的。</li><li>那么如果使用的是Bootstrap5以下的版本，需在引入Bootstrap之前先引入jQuery库。</li></ul><h4 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h4><ul><li>方式一：在页面中，直接通过CDN的方式引入。</li><li>方式二：下载Bootstrap框架，并在页面中手动引入。</li><li>方式三：使用npm包管理工具安装到项目中（npm在Node基础阶段会讲解）</li></ul><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><ul><li><a href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css">https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css</a></li><li><a href="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js">https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js</a></li><li><a href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js">https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js</a></li></ul><h4 id="HTML中引入之后，添加重要的全局配置"><a href="#HTML中引入之后，添加重要的全局配置" class="headerlink" title="HTML中引入之后，添加重要的全局配置"></a><strong>HTML</strong>中引入之后，添加重要的全局配置</h4><ul><li><p>HTML5 文档类型（doctype 或 DOCTYPE），Bootstrap 要求文档类型（doctype）是 HTML5。</p><ul><li>如果没有设置这个，就会看到一些古怪的、不完整的样式，因此，正确设置文档类型（doctype）能轻松避免这些困扰。</li></ul></li><li><p>添加视口（viewport）</p><ul><li><p>Bootstrap 采用的是移动设备优先（mobile first） 的开发策略，为了网页能够适配移动端的设备，需在 <head> 标签中添加viewport（视口）。</p></li><li><p>在移动端会把 layout viewport 的宽度设置为设备的宽，并且不允许用户进行页面的缩放。</p></li><li><meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no,maximum-scale=1.0,minimum-scale=1.0,shrink-to-fit=no"></li></ul></li></ul><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><h4 id="Bootstrap框架的下载"><a href="#Bootstrap框架的下载" class="headerlink" title="Bootstrap框架的下载"></a>Bootstrap框架的下载</h4><ul><li>Bootstrap下载地址：<a href="https://v4.bootcss.com/docs/getting-started/download/">https://v4.bootcss.com/docs/getting-started/download/</a></li><li>jQuery下载地址：<a href="https://jquery.com/download/">https://jquery.com/download/</a></li></ul><h3 id="npm下载"><a href="#npm下载" class="headerlink" title="npm下载"></a>npm下载</h3><ul><li>$npm install bootstrap</li><li>$yarn add bootstrap</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Bootstrap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery方法</title>
    <link href="/2022/08/17/jQuery%E6%96%B9%E6%B3%95/"/>
    <url>/2022/08/17/jQuery%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="想到哪写到哪"><a href="#想到哪写到哪" class="headerlink" title="想到哪写到哪"></a>想到哪写到哪</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$(<span class="hljs-string">&#x27;.header .address&#x27;</span>).<span class="hljs-built_in">text</span>(addr.city)<br></code></pre></td></tr></table></figure><ul><li><p>先用选择器获取目标，然后用text替换目标中的文字</p></li><li><p>目标在鼠标失去焦点后隐藏</p></li><li><pre><code class="hljs">var $searchTips = $(&#39;.header .search-tips&#39;) //css选择$searchHouseInput.on(&#39;blur&#39;, function() &#123;    $searchTips.css(&#39;display&#39;,&#39;none&#39;)  &#125;)</code></pre></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery中的AJAX</title>
    <link href="/2022/08/16/jQuery%E4%B8%AD%E7%9A%84AJAX/"/>
    <url>/2022/08/16/jQuery%E4%B8%AD%E7%9A%84AJAX/</url>
    
    <content type="html"><![CDATA[<h2 id="还没写"><a href="#还没写" class="headerlink" title="还没写"></a>还没写</h2><h2 id="在项目中通过jQuery封装的网络请求"><a href="#在项目中通过jQuery封装的网络请求" class="headerlink" title="在项目中通过jQuery封装的网络请求"></a>在项目中通过jQuery封装的网络请求</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs lua">;(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(window, $)</span></span> &#123;<br><br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span><span class="hljs-params">(config)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> $.ajax(&#123;<br>      url: <span class="hljs-built_in">config</span>.url || <span class="hljs-string">&#x27;&#x27;</span>,<br>      method: <span class="hljs-built_in">config</span>.method || <span class="hljs-string">&#x27;GET&#x27;</span>,<br>      timeout: <span class="hljs-built_in">config</span>.timeout || <span class="hljs-number">5000</span>,<br>      data: <span class="hljs-built_in">config</span>.data || &#123;&#125;,<br>      headers: <span class="hljs-built_in">config</span>.headers || &#123;&#125;,<br>      ...<span class="hljs-built_in">config</span><br>    &#125;)<br>    <br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span><span class="hljs-params">(url, data, config)</span></span> &#123;<br><br>    <span class="hljs-keyword">return</span> request(&#123;<br>      url,<br>      method: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>      data,<br>      ...<span class="hljs-built_in">config</span><br>    &#125;)<br><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span><span class="hljs-params">(url, data, config)</span></span> &#123;<br><br>    <span class="hljs-keyword">return</span> request(&#123;<br>      url,<br>      method: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>      data,<br>      ...<span class="hljs-built_in">config</span><br>    &#125;)<br><br>  &#125;<br><br>  window.HYReq = &#123;<br>    request,<br>    get,<br>    post<br>  &#125;<br><br>&#125;(window, jQuery))<br></code></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">HYReq.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;http://123.207.32.32:9060/beike/api/homePageInfo&#x27;</span>)<br>.then(<span class="hljs-keyword">function</span>(<span class="hljs-keyword">res</span>) &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">res</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作jQuery</title>
    <link href="/2022/08/16/%E6%93%8D%E4%BD%9CjQuery/"/>
    <url>/2022/08/16/%E6%93%8D%E4%BD%9CjQuery/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="监听文档加载"><a href="#监听文档加载" class="headerlink" title="监听文档加载"></a>监听文档加载</h3><ul><li>只用掌握一种</li><li>这个是当文档加载完成时执行里面的函数</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>  var <span class="hljs-variable">$doc</span> =  $(document)<br><span class="hljs-regexp">//</span>  <span class="hljs-regexp">//</span> 方式 <span class="hljs-number">1</span>:监听文档完全解析完成<br><span class="hljs-regexp">//</span>  <span class="hljs-variable">$doc</span>.ready(<span class="hljs-keyword">function</span>() &#123;<br><span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&#x27;doc ready&#x27;</span>)<br><span class="hljs-regexp">//</span>  &#125;)<br><br> <span class="hljs-regexp">//</span> 方式 <span class="hljs-number">2</span>:监听文档完全解析完成<br><span class="hljs-regexp">//</span> jQuery(<span class="hljs-string">&#x27;document&#x27;</span>).ready(<span class="hljs-keyword">function</span>()&#123;<br><span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&#x27;doc ready&#x27;</span>)<br><span class="hljs-regexp">//</span> &#125;)<br><br> <span class="hljs-regexp">//</span> 方式 <span class="hljs-number">3</span>:监听文档完全解析完成<br><span class="hljs-regexp">//</span> $().ready(<span class="hljs-keyword">function</span>()&#123;<br><span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&#x27;doc ready&#x27;</span>)<br><span class="hljs-regexp">//</span> &#125;)<br><br> <span class="hljs-regexp">//</span> 方式 <span class="hljs-number">4</span>:监听文档完全解析完成<br><span class="hljs-regexp">//</span> $(<span class="hljs-keyword">function</span>() &#123;<br><span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&#x27;doc ready&#x27;</span>)<br><span class="hljs-regexp">//</span> &#125;)<br></code></pre></td></tr></table></figure><h3 id="jQuery与其它库的变量名冲突"><a href="#jQuery与其它库的变量名冲突" class="headerlink" title="jQuery与其它库的变量名冲突"></a><strong>jQuery</strong>与其它库的变量名冲突</h3><ul><li><strong>和 jQuery库一样，</strong>许多JavaScript库也会使用 $ 作为函数名或变量名。<ul><li>在 jQuery 中，$ 是jQuery的别名。</li><li>如果我们在使用jQuery库之前，其它库已经使用了 $ 函数或者变量，这时就会出现冲突的情况。</li><li>这时我们可以通过调用jQuery中的noConflict函数来解决冲突问题。</li><li>jQuery在初始化前会先备份一下全局其它库的jQuery和$变量，调用noConflict函数只是恢复之前备份的jQuery和$变量。</li></ul></li></ul><h4 id="jQuery的选择器-Selectors"><a href="#jQuery的选择器-Selectors" class="headerlink" title="jQuery的选择器**(Selectors)**"></a><strong>jQuery</strong>的选择器**(Selectors)**</h4><ul><li><strong>jQuery</strong>函数支持大部分的CSS选择器，语法：jQuery（’字符串格式的选择器’）<ul><li>1.通用选择器（*）</li><li>2.基本选择器（id, class, 元素）</li><li>3.属性选择器（ [attr] , [atrr&#x3D;”value ”] ）</li><li>4.后代选择器（div &gt; span, div span）</li><li>5.兄弟选择器（div + span , div ~ span）</li><li>6.交集选择器（div.container） </li><li>7.伪类选择器（:nth-child()，:nth-of-type()，:not()， 但不支持状态伪类 :hover, :focus…）</li><li>8.内容选择器（:empty，:has(selector)）, empty指选中的元素没有子元素或文本； has指选中的元素是否存在某个子元素</li><li>9.可见选择器（:visible, :hidden）</li><li>10.jQuery扩展选择器：（:eq(), :odd, :even, :first, :last ）</li></ul></li></ul><h4 id="jQuery对文本的操作"><a href="#jQuery对文本的操作" class="headerlink" title="jQuery对文本的操作"></a><strong>jQuery</strong>对文本的操作</h4><ul><li><p>.text()、.text(text)</p><ul><li>获取匹配到元素集合中每个元素组合的文本内容，包括它们的后代，或设置匹配到元素的文本内容。</li><li>相当与原生元素的textContent属性。</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$(<span class="hljs-string">&#x27;ul li&#x27;</span>).<span class="hljs-built_in">text</span>(<span class="hljs-string">&#x27;我是li&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>.html()<strong>、</strong>html(htmlString)</strong></p><ul><li>获取匹配到元素集合中第一个元素的HTML内容，包括它们的后代，或设置每个匹配元素的 HTML 内容。</li><li>相当与原生元素的innerHTML属性。</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery">$(<span class="hljs-string">&#x27;ul li&#x27;</span>).html(`<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是p元素<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是一个span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>`)<br></code></pre></td></tr></table></figure></li><li><p>.val()、.val(value)</p><ul><li>获取匹配到元素集合中第一个元素的当前值 或 设置每个匹配到元素的值。</li><li>该.val()方法主要用于获取input,select和等表单元素的值。</li><li>相当与获取原生元素的value属性。</li></ul></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$(<span class="hljs-string">&#x27;.login&#x27;</span>).click(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( $(<span class="hljs-string">&#x27;.user&#x27;</span>).val() )<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( $(<span class="hljs-string">&#x27;.password&#x27;</span>).val() )<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识jQuery</title>
    <link href="/2022/08/16/jQuery/"/>
    <url>/2022/08/16/jQuery/</url>
    
    <content type="html"><![CDATA[<h2 id="What’s-it"><a href="#What’s-it" class="headerlink" title="What’s it"></a>What’s it</h2><h4 id="是一个快速、小型且功能丰富的-JavaScript-库，官网对jQuery的描述："><a href="#是一个快速、小型且功能丰富的-JavaScript-库，官网对jQuery的描述：" class="headerlink" title="是一个快速、小型且功能丰富的 JavaScript 库，官网对jQuery的描述："></a><strong>是一个</strong>快速、小型且功能丰富的 JavaScript 库，官网对jQuery的描述：</h4><ul><li>使HTML文档遍历、操作、事件处理、动画和 Ajax 之类的事情变得更加简单。</li><li>具有易于使用的 API，可在多种浏览器中使用。</li><li>jQuery 结合多功能性和可扩展性，改变了数百万人编写 JavaScript 的方式。</li></ul><h4 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h4><ul><li><strong><a href="https://jquery.com/">https://jquery.com/</a></strong></li></ul><h4 id="源码下载地址"><a href="#源码下载地址" class="headerlink" title="源码下载地址"></a>源码下载地址</h4><ul><li><a href="https://code.jquery.com/jquery-3.6.0.js">https://code.jquery.com/jquery-3.6.0.js</a></li></ul><h2 id="库-library-和框架-framework-的概念"><a href="#库-library-和框架-framework-的概念" class="headerlink" title="库(library)和框架(framework)的概念"></a>库(library)和框架(framework)的概念</h2><ul><li><strong>随着</strong>JavaScript<strong>的普及，以及越来越多人使用</strong>JavaScript<strong>来构建网站和应用程序</strong><ul><li>JavaScript社区认识到代码中存在非常多相同的逻辑是可复用的。</li><li>因此社区就开始对这些相同的逻辑的代码封装到一个JavaScript文件中。</li><li>这个封装好的JavaScript文件就可称为JavaScript库或JavaScript框架。</li></ul></li><li><strong>库</strong>(library)<ul><li>JavaScript库是一个预先编写好并实现了一些特定功能的代码片段的集合。</li><li>一个库中会包含许多的函数、变量等，可根据需求引入到项目中使用。</li><li>一些常见的库有jQuery、Day.js、Lodash和React等</li></ul></li><li><strong>框架（framework）</strong><ul><li>JavaScript框架是一个完整的工具集，可帮助塑造和组织您的网站或应用程序。</li><li>提供一个结构来构建整个应用程序，开发人员可以在结构的规则内更安全、更高效地工作。</li><li>一些更常见的框架有：Bootstrap、Angular、Vue、Next.js等。</li></ul></li></ul><h2 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>易于学习：相对于其它的前端框架，jQuery 更易于学习，它支持 JavaScript 的编码风格。</p></li><li><p>少写多做（Write less, do more）</p><ul><li>jQuery提供了丰富的功能(DOM操作、过滤器、事件、动画、Ajax等)。</li><li>可以编写更少可读的代码来提高开发人员的工作效率。</li></ul><p>优秀的 API 文档：jQuery 提供了优秀的在线 API 文档。</p><p>跨浏览器支持：提供出色的跨浏览器支持 (IE9+)，无需编写额外代码。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>jQuery代码库一直在增长（自 jQuery 1.5 起超过 200KB）</li><li>不支持组件化开发</li><li>jQuery 更适合DOM操作，当涉及到开发复杂的项目时，jQuery能力有限。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS网络请求封装</title>
    <link href="/2022/08/15/JS%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/"/>
    <url>/2022/08/15/JS%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="系统课的"><a href="#系统课的" class="headerlink" title="系统课的"></a>系统课的</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 练习hyajax -&gt; axios</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hyajax</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">  url,</span><br><span class="hljs-params">  method = <span class="hljs-string">&quot;get&quot;</span>,</span><br><span class="hljs-params">  data = &#123;&#125;,</span><br><span class="hljs-params">  headers = &#123;&#125;, // token</span><br><span class="hljs-params">  success,</span><br><span class="hljs-params">  failure</span><br><span class="hljs-params">&#125; = &#123;&#125;</span>) &#123;  <span class="hljs-comment">//= &#123;&#125;是为了默认值？ 默认对象，解构</span><br>  <span class="hljs-comment">// 1.创建对象</span><br>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><br>  <span class="hljs-comment">// 2.监听数据</span><br>  xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>      success &amp;&amp; <span class="hljs-title function_">success</span>(xhr.<span class="hljs-property">response</span>)  <span class="hljs-comment">//&amp;&amp;防止没有传入success参数</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      failure &amp;&amp; <span class="hljs-title function_">failure</span>(&#123; <span class="hljs-attr">status</span>: xhr.<span class="hljs-property">status</span>, <span class="hljs-attr">message</span>: xhr.<span class="hljs-property">statusText</span> &#125;)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 3.设置类型</span><br>  xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>  <span class="hljs-comment">//一般都要转json格式，因为好解析</span><br><br>  <span class="hljs-comment">// 4.open方法</span><br>  <span class="hljs-keyword">if</span> (method.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&quot;GET&quot;</span>) &#123;  <span class="hljs-comment">//防止调用者用小写的get</span><br>    <span class="hljs-keyword">const</span> queryStrings = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> data) &#123;<br>      queryStrings.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;data[key]&#125;</span>`</span>)<br>    &#125;<br>    url = url + <span class="hljs-string">&quot;?&quot;</span> + queryStrings.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&amp;&quot;</span>)<br>    xhr.<span class="hljs-title function_">open</span>(method, url)<br>    xhr.<span class="hljs-title function_">send</span>()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    xhr.<span class="hljs-title function_">open</span>(method, url)<br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data))<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> xhr<br>&#125;<br><br><span class="hljs-comment">// 调用者</span><br><span class="hljs-title function_">hyajax</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://123.207.32.32:1888/02_param/get&quot;</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>  &#125;,<br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res:&quot;</span>, res)<br>  &#125;,<br>  <span class="hljs-attr">failure</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-comment">// alert(err.message)</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>因为函数的形参太多了，所以给参数设置默认值。</p></li><li><p>XMLHttpRequest是ajax的网络请求类方法</p></li><li><p>然后编写监听函数，要判断是否请求成功，所以要进行状态判定。当成功时执行success函数，为了防止调用者没有传入success函数，所以要判断</p></li><li><p>记得把获得的类型转换成json</p></li><li><p>接下来就是调用open方法，但是使用get和用post他们传入的参数格式不一样。所以也要加个判断。？？什么格式不一样？？</p><ul><li>调用者在使用get方法时，可能将data放在对象中的data里面，而不是放在url里，所以要拼接</li></ul></li><li><p>判断完open后就要调用sent来完成网络请求</p></li><li><p>最后将其返回就完成了</p></li></ul><h2 id="建立缓存"><a href="#建立缓存" class="headerlink" title="建立缓存"></a>建立缓存</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> cacheSearchListData = <span class="hljs-selector-attr">[]</span><br><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(cacheSearchListData.length)</span></span> &#123;<br>    <span class="hljs-built_in">renderSearchList</span>(cacheSearchListData)<br>    return<br>  &#125;<br>  <br> cacheSearchListData = searchListData<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS发送网络请求</title>
    <link href="/2022/08/15/JS%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <url>/2022/08/15/JS%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="AJAX发送请求"><a href="#AJAX发送请求" class="headerlink" title="AJAX发送请求"></a>AJAX发送请求</h2><ul><li>AJAX 是异步的 JavaScript 和 XML（Asynchronous JavaScript And XML）<ul><li>它可以使用 JSON，XML，HTML 和 text 文本等格式发送和接收数据；</li></ul></li></ul><h4 id="如何来完成AJAX请求呢？"><a href="#如何来完成AJAX请求呢？" class="headerlink" title="如何来完成AJAX请求呢？"></a>如何来完成AJAX请求呢？</h4><ul><li> 第一步：创建网络请求的AJAX对象（使用XMLHttpRequest）</li><li> 第二步：监听XMLHttpRequest对象状态的变化，或者监听onload事件（请求完成时触发）； </li><li> 第三步：配置网络请求（通过open方法）； </li><li> 第四步：发送send网络请求；</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>.创建XMLHttpRequest对象<br> const xhr = new XMLHttpRequest()<br><br> <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>.监听状态的改变(宏任务)<br> xhr.onreadystatechange = <span class="hljs-keyword">function</span>() &#123;<br>   <span class="hljs-regexp">//</span> console.log(xhr.response)<br>   <span class="hljs-keyword">if</span> (xhr.readyState !== XMLHttpRequest.DONE) return  <span class="hljs-regexp">//</span>XMLHttpRequest共有四个状态不判断的话会进行四次<br><br>   <span class="hljs-regexp">//</span> 将字符串转成JSON对象(js对象)<br>   const resJSON = JSON.parse(xhr.response)<br>   const banners = resJSON.data.banner.list<br>   console.log(banners)<br> &#125;<br><br> <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>.配置请求open<br> <span class="hljs-regexp">//</span> method: 请求的方式(get<span class="hljs-regexp">/post/</span><span class="hljs-keyword">delete</span><span class="hljs-regexp">/put/</span>patch...)<br> <span class="hljs-regexp">//</span> url: 请求的地址<br> xhr.open(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>)<br><br> <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>.发送请求(浏览器帮助发送对应请求)<br> xhr.send()<br><br></code></pre></td></tr></table></figure><h4 id="XMLHttpRequest的state（状态）"><a href="#XMLHttpRequest的state（状态）" class="headerlink" title="XMLHttpRequest的state（状态）"></a>XMLHttpRequest的state（状态）</h4><ul><li>事实上，我们在一次网络请求中看到状态发生了很多次变化，这是因为对于一次请求来说包括如下的状态：</li></ul><p><img src="C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\XMLstate.png"></p><ul><li><p>发送同步请求：</p><ul><li>将open的第三个参数设置为false</li></ul></li></ul><h3 id="XMLHttpRequest其他事件监听"><a href="#XMLHttpRequest其他事件监听" class="headerlink" title="XMLHttpRequest其他事件监听"></a>XMLHttpRequest其他事件监听</h3><h5 id="除了onreadystatechange还有其他的事件可以监听"><a href="#除了onreadystatechange还有其他的事件可以监听" class="headerlink" title="除了onreadystatechange还有其他的事件可以监听"></a>除了onreadystatechange还有其他的事件可以监听</h5><ul><li> loadstart：请求开始。 </li><li> progress： 一个响应数据包到达，此时整个 response body 都在 response 中。 </li><li> abort：调用 xhr.abort() 取消了请求。 </li><li> error：发生连接错误，例如，域错误。不会发生诸如 404 这类的 HTTP 错误。 </li><li> load：请求成功完成。 </li><li> timeout：由于请求超时而取消了该请求（仅发生在设置了 timeout 的情况下）。</li><li> loadend：在 load，error，timeout 或 abort 之后触发。</li></ul><h4 id="HTTP响应的状态status"><a href="#HTTP响应的状态status" class="headerlink" title="HTTP响应的状态status"></a>HTTP响应的状态status</h4><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\HTTP code.png)</p><h4 id="GET-x2F-POST请求传递参数"><a href="#GET-x2F-POST请求传递参数" class="headerlink" title="GET&#x2F;POST请求传递参数"></a>GET&#x2F;POST请求传递参数</h4><ul><li>方式一：GET请求的query参数</li><li>方式二：POST请求 x-www-form-urlencoded 格式  </li><li>方式三：POST请求 FormData 格式  </li><li>方式四：POST请求 JSON 格式</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>.传递参数方式一: get -&gt; query<br><span class="hljs-regexp">//</span> xhr.open(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;http://123.207.32.32:1888/02_param/get?name=why&amp;age=18&amp;address=广州市&quot;</span>)<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>.传递参数方式二: post -&gt; urlencoded<br><span class="hljs-regexp">//</span> xhr.open(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;http://123.207.32.32:1888/02_param/posturl&quot;</span>)<br><span class="hljs-regexp">//</span> <span class="hljs-regexp">//</span> 发送请求(请求体body)<br><span class="hljs-regexp">//</span> xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>)<br><span class="hljs-regexp">//</span> xhr.send(<span class="hljs-string">&quot;name=why&amp;age=18&amp;address=广州市&quot;</span>)<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span>.传递参数方式三: post -&gt; formdata<br><span class="hljs-regexp">//</span> xhr.open(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;http://123.207.32.32:1888/02_param/postform&quot;</span>)<br><span class="hljs-regexp">//</span> <span class="hljs-regexp">//</span> formElement对象转成FormData对象<br><span class="hljs-regexp">//</span> const formData = new FormData(formEl)<br><span class="hljs-regexp">//</span> xhr.send(formData)<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">4</span>.传递参数方式四: post -&gt; json<br>xhr.open(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;http://123.207.32.32:1888/02_param/postjson&quot;</span>)<br>xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>xhr.send(JSON.stringify(&#123;name: <span class="hljs-string">&quot;why&quot;</span>, age: <span class="hljs-number">18</span>, height: <span class="hljs-number">1.88</span>&#125;))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS网络请求协议</title>
    <link href="/2022/08/14/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/08/14/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h2><ul><li><p>什么是HTTP呢？我们来看一下维基百科的解释</p><ul><li>超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议；</li><li> HTTP是万维网的数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法；</li><li> 通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识；</li></ul></li><li><p>HTTP是一个客户端（用户）和服务端（网站）之间请求和响应的标准。</p><ul><li>通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）；<ul><li>✓ 我们称这个客户端为用户代理程序（user agent）；</li></ul></li><li> 响应的服务器上存储着一些资源，比如HTML文件和图像。 </li><li>✓ 我们称这个响应服务器为源服务器（origin server）；</li></ul></li></ul><h2 id="HTTP的组成"><a href="#HTTP的组成" class="headerlink" title="HTTP的组成"></a>HTTP的组成</h2><ul><li>一次HTTP请求主要包括：请求（Request）和响应（Response）</li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\HTTP R.png)</p><h2 id="HTTP的请求方式"><a href="#HTTP的请求方式" class="headerlink" title="HTTP的请求方式"></a>HTTP的请求方式</h2><ul><li><p> GET：GET 方法请求一个指定资源的表示形式，使用 GET 的请求应该只被用于获取数据。</p></li><li><p> HEAD：HEAD 方法请求一个与 GET 请求的响应相同的响应，但没有响应体。 ✓ 比如在准备下载一个文件前，先获取文件的大小，再决定是否进行下载；  POST：POST 方法用于将实体提交到指定的资源。</p></li><li><p> PUT：PUT 方法用请求有效载荷（payload）替换目标资源的所有当前表示；</p></li><li><p> DELETE：DELETE 方法删除指定的资源；</p></li><li><p> PATCH：PATCH 方法用于对资源应部分修改；</p></li><li><p> CONNECT：CONNECT 方法建立一个到目标资源标识的服务器的隧道，通常用在代理服务器，网页开发很少用到。</p></li><li><p> TRACE：TRACE 方法沿着到目标资源的路径执行一个消息环回测试。</p></li><li><p>一般都是GET和HEAD方法</p></li></ul><h2 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h2><h3 id="content-type是这次请求携带的数据的类型："><a href="#content-type是这次请求携带的数据的类型：" class="headerlink" title="content-type是这次请求携带的数据的类型："></a>content-type是这次请求携带的数据的类型：</h3><ul><li> application&#x2F;x-www-form-urlencoded：表示数据被编码成以 ‘&amp;’ 分隔的键 - 值对，同时以 ‘&#x3D;’ 分隔键和值 </li><li> application&#x2F;json：表示是一个json类型； </li><li> text&#x2F;plain：表示是文本类型； </li><li> application&#x2F;xml：表示是xml类型；</li><li> multipart&#x2F;form-data：表示是上传文件；</li></ul><h3 id="content-length：文件的大小长度"><a href="#content-length：文件的大小长度" class="headerlink" title="content-length：文件的大小长度"></a>content-length：文件的大小长度</h3><h2 id="HTTP请求头响应状态码"><a href="#HTTP请求头响应状态码" class="headerlink" title="HTTP请求头响应状态码"></a>HTTP请求头响应状态码</h2><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\HTTP code.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前后端分离</title>
    <link href="/2022/08/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    <url>/2022/08/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="◼-早期的网页都是通过后端渲染来完成的：服务器端渲染（SSR，server-side-render）："><a href="#◼-早期的网页都是通过后端渲染来完成的：服务器端渲染（SSR，server-side-render）：" class="headerlink" title="◼ 早期的网页都是通过后端渲染来完成的：服务器端渲染（SSR，server side render）："></a>◼ 早期的网页都是通过后端渲染来完成的：服务器端渲染（SSR，server side render）：</h3><ul><li>客户端发出请求 -&gt; 服务端接收请求并返回相应HTML文档 -&gt; 页面刷新，客户端加载新的HTML文档；</li></ul><h3 id="服务器端渲染的缺点："><a href="#服务器端渲染的缺点：" class="headerlink" title="服务器端渲染的缺点："></a>服务器端渲染的缺点：</h3><ul><li>当用户点击页面中的某个按钮向服务器发送请求时，页面本质上只是一些数据发生了变化，而此时服务器却要将重绘的整个页面再返 回给浏览器加载，这显然有悖于程序员的“DRY（ Don‘t repeat yourself ）”原则；</li><li>而且明明只是一些数据的变化却迫使服务器要返回整个HTML文档，这本身也会给网络带宽带来不必要的开销。</li></ul><h3 id="有没有办法在页面数据变动时，只向服务器请求新的数据，并且在阻止页面刷新的情况下，动态的替换页面中展示的数据呢？"><a href="#有没有办法在页面数据变动时，只向服务器请求新的数据，并且在阻止页面刷新的情况下，动态的替换页面中展示的数据呢？" class="headerlink" title="有没有办法在页面数据变动时，只向服务器请求新的数据，并且在阻止页面刷新的情况下，动态的替换页面中展示的数据呢？"></a>有没有办法在页面数据变动时，只向服务器请求新的数据，并且在阻止页面刷新的情况下，动态的替换页面中展示的数据呢？</h3><h3 id="答案正是“AJAX”。"><a href="#答案正是“AJAX”。" class="headerlink" title="答案正是“AJAX”。"></a>答案正是“AJAX”。</h3><h3 id="AJAX是“Asynchronous-JavaScript-And-XML”的缩写-异步的JavaScript和XML-，是一种实现-无页面刷新-获取服务器数据的技术。"><a href="#AJAX是“Asynchronous-JavaScript-And-XML”的缩写-异步的JavaScript和XML-，是一种实现-无页面刷新-获取服务器数据的技术。" class="headerlink" title="AJAX是“Asynchronous JavaScript And XML”的缩写(异步的JavaScript和XML)，是一种实现 无页面刷新 获取服务器数据的技术。"></a>AJAX是“Asynchronous JavaScript And XML”的缩写(异步的JavaScript和XML)，是一种实现 无页面刷新 获取服务器数据的技术。</h3><ul><li> AJAX最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</li></ul><h3 id="你可以使用AJAX最主要的两个特性做下列事："><a href="#你可以使用AJAX最主要的两个特性做下列事：" class="headerlink" title="你可以使用AJAX最主要的两个特性做下列事："></a>你可以使用AJAX最主要的两个特性做下列事：</h3><ul><li>在不重新加载页面的情况下发送请求给服务器；</li><li>接受并使用从服务器发来的数据。</li></ul><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Web Render.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>history</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS事件总线</title>
    <link href="/2022/08/14/JS%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
    <url>/2022/08/14/JS%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>负责组件通信的工具</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HYEventBus</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span> = &#123;&#125;<br>  &#125;<br><br>  <span class="hljs-title function_">on</span>(<span class="hljs-params">eventName, eventFn</span>) &#123;  <span class="hljs-comment">//监听方法</span><br>    <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]<br>    <span class="hljs-keyword">if</span> (!eventFns) &#123;<br>      eventFns = []<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName] = eventFns<br>    &#125;<br>    eventFns.<span class="hljs-title function_">push</span>(eventFn)<br>  &#125;<br>  <br>  <span class="hljs-title function_">off</span>(<span class="hljs-params">eventName, eventFn</span>) &#123;   <span class="hljs-comment">//取消监听</span><br>    <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]<br>    <span class="hljs-keyword">if</span> (!eventFns) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; eventFns.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> fn = eventFns[i]<br>      <span class="hljs-keyword">if</span> (fn === eventFn) &#123;<br>        eventFns.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">break</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果eventFns已经清空了</span><br>    <span class="hljs-keyword">if</span> (eventFns.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">eventName, ...args</span>) &#123;   <span class="hljs-comment">//发射方法</span><br>    <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]<br>    <span class="hljs-keyword">if</span> (!eventFns) <span class="hljs-keyword">return</span><br>    eventFns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>(...args)<br>    &#125;)<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 使用过程</span><br><span class="hljs-keyword">const</span> eventBus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HYEventBus</span>()<br><br><span class="hljs-comment">// aside.vue组件中监听事件</span><br>eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;navclick&quot;</span>, <span class="hljs-function">(<span class="hljs-params">name, age, height</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;navclick listener 01&quot;</span>, name, age, height)<br>&#125;)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">click</span> =  (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;navclick listener 02&quot;</span>)<br>&#125;<br>eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;navclick&quot;</span>, click)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  eventBus.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;navclick&quot;</span>, click)<br>&#125;, <span class="hljs-number">5000</span>);<br><br>eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;asideclick&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;asideclick listener&quot;</span>)<br>&#125;)<br><br><br><span class="hljs-comment">// nav.vue</span><br><span class="hljs-keyword">const</span> navBtnEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.nav-btn&quot;</span>)<br>navBtnEl.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;自己监听到&quot;</span>)<br>  eventBus.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;navclick&quot;</span>, <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS判断是否对象的封装</title>
    <link href="/2022/08/13/JS%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <url>/2022/08/13/JS%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> isObject(<span class="hljs-keyword">value</span>) &#123;<br>  // <span class="hljs-keyword">null</span>,<span class="hljs-keyword">object</span>,<span class="hljs-keyword">function</span>,<span class="hljs-keyword">array</span><br>  // <span class="hljs-keyword">null</span> -&gt; <span class="hljs-keyword">object</span><br>  // <span class="hljs-keyword">function</span> -&gt; <span class="hljs-keyword">function</span> -&gt; <span class="hljs-keyword">true</span><br>  // <span class="hljs-keyword">object</span>/<span class="hljs-keyword">array</span> -&gt; <span class="hljs-keyword">object</span> -&gt; <span class="hljs-keyword">true</span><br>  const valueType = typeof <span class="hljs-keyword">value</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">value</span> !== <span class="hljs-keyword">null</span>) &amp;&amp; ( valueType === &quot;object&quot; || valueType === &quot;function&quot; )<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>小工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS浅拷贝深拷贝</title>
    <link href="/2022/08/13/JS%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/08/13/JS%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>只是浅层的拷贝，内部引入对象时，依然会相互影响；</p></li><li><pre><code class="hljs">    const obj2 = &#123; ...info &#125;    obj2.name = &quot;james&quot;  //展开运算符    obj2.friend.name = &quot;james&quot;    console.log(info.friend.name)<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><br>- 会将info里面得内容拷贝到obj2里面，obj2改变值时info不改变。但是如果是改变拷贝过来得函数得话，info里面得也会改变。因为拷贝过来的函数只是内存地址<br><br><br><br><span class="hljs-meta">## 深拷贝</span><br><br>- 拷贝过来之后和拷贝对象没有关系。改变里面的任何值拷贝对象也不会被改变<br>- JS中没有可以直接深拷贝的方法，因为太消耗资源了。而且用的地方也不多。<br><br><span class="hljs-meta">### 实现</span><br><br>- 可以遍历对象中的数据，当遇到对象类型的时再对其进行遍历。这样的话递归是比较合适的<br><br>- ```<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepcopy</span></span>(value) &#123;<br>        <span class="hljs-comment">// 1.如果是原始类型, 直接返回</span><br>    <span class="hljs-keyword">if</span>(!isObject(value)) &#123;<br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  <br>  <span class="hljs-comment">// 2.如果是对象类型, 才需要创建对象</span><br>    const <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span> = &#123;&#125;<br>    <span class="hljs-keyword">for</span> (const key <span class="hljs-keyword">in</span> value)&#123;<br>      <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>[key] = deepcopy(value[key])<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span><br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>当传入一个数组时，依旧输出一个对象。这是我们不想看到的。</p></li><li><p>可是typeof无法判断出时对象还是数组</p></li><li><p>还有一个方法is.Array</p></li><li><pre><code class="hljs">const newObj = Array.isArray(originValue) ? []: &#123;&#125;<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><br><span class="hljs-meta">### 其他情况</span><br><br>- 遇到<span class="hljs-keyword">set</span>类型时无法正常拷贝，因为其不支持<span class="hljs-keyword">for</span> <span class="hljs-keyword">in</span>方法  <span class="hljs-comment">//set是啥来着</span><br><br>- ```<br>       <span class="hljs-keyword">if</span> (typeof originValue === <span class="hljs-string">&quot;symbol&quot;</span>) &#123;<br>          <span class="hljs-keyword">return</span> Symbol(originValue.description)<br>        &#125;<br>  <span class="hljs-keyword">if</span> (originValue instanceof Set) &#123;<br>          const <span class="hljs-keyword">new</span><span class="hljs-type">Set</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Set</span>()<br>          <span class="hljs-keyword">for</span> (const setItem of originValue) &#123;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Set</span>.add(deepCopy(setItem))<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Set</span><br>        &#125;<br>        <span class="hljs-comment">// 单独遍历symbol</span><br>        const symbolKeys = Object.getOwnPropertySymbols(originValue)<br>        <span class="hljs-keyword">for</span> (const symbolKey of symbolKeys) &#123;<br>          <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>[Symbol(symbolKey.description)] = deepCopy(originValue[symbolKey])<br>        &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li></li><li><p>遇到symbol时因为其特殊性所以要加   &#x2F;&#x2F;什么特殊性我忘了</p></li><li><pre><code class="hljs">     if (typeof originValue === &quot;symbol&quot;) &#123;        return Symbol(originValue.description)      &#125;</code></pre></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS防抖</title>
    <link href="/2022/08/13/JS%E9%98%B2%E6%8A%96/"/>
    <url>/2022/08/13/JS%E9%98%B2%E6%8A%96/</url>
    
    <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ul><li>当事件触发时，相应的函数并不会立即触发，而是会等待一定的时间；</li><li>当事件密集触发时，函数的触发会被频繁的推迟；</li><li>只有等待了一段时间也没有事件触发，才会真正的执行响应函数；</li></ul><h3 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hydebounce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-comment">// 1.用于记录上一次事件触发的timer</span><br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br><br>  <span class="hljs-comment">// 2.触发事件时执行的函数</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">_debounce</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 2.1.如果有再次触发(更多次触发)事件, 那么取消上一次的事件</span><br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br><br>    <span class="hljs-comment">// 2.2.延迟去执行对应的fn函数(传入的回调函数)</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>()<br>      timer = <span class="hljs-literal">null</span> <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span><br>    &#125;, delay);<br>  &#125;<br><br>  <span class="hljs-comment">// 返回一个新的函数</span><br>  <span class="hljs-keyword">return</span> _debounce<br>&#125;  <span class="hljs-comment">//里面的this指定了window，因为上面执行的函数是独立执行函数</span><br></code></pre></td></tr></table></figure><ul><li><p>要绑定this不能直接给fn指定this，因为timer和_debounce都是箭头函数，所以会直接指向hydebounce。可hydebounce是独立函数调用。因为oninput<strong>绑定的是hydebounce的返回值</strong>。所以我们想绑定this，得让this指向_debounce。</p></li><li><p>所以只要将_debounce设为普通函数就可以了</p></li><li><p><code>const _debounce = function() &#123;&#125;</code></p></li></ul><h3 id="取消执行"><a href="#取消执行" class="headerlink" title="取消执行"></a>取消执行</h3><ul><li>因为是延时器执行，所以当页面返回时也会执行。这时候我们就需要取消功能</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"> <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>.给_debounce绑定一个取消的函数 <span class="hljs-regexp">//</span>在hydebounce里面<br>  _debounce.cancel = <span class="hljs-keyword">function</span>() &#123;<br>    <span class="hljs-keyword">if</span> (timer) clearTimeout(timer)<br>    &#125;<br>    <br>    <br> <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>.实现取消的功能<br>cancelBtn.onclick = <span class="hljs-keyword">function</span>() &#123;<br>  debounceFn.cancel()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>如果这个事件会被频繁触发，那么节流函数会按照一定的频率来执行函数；</li><li>定义最小运行间隔</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS异步处理</title>
    <link href="/2022/08/11/JS%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    <url>/2022/08/11/JS%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>延迟获取的值无法用return返回，所以需要异步处理来获取</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs awk"> <span class="hljs-keyword">function</span> requestData(url) &#123;<br>  return new Promise((resolve, reject) =&gt; &#123;<br>    setTimeout(() =&gt; &#123;<br>      resolve(url)<br>    &#125;, <span class="hljs-number">2000</span>)<br>  &#125;)<br>&#125;   <br>需求: <br>    <span class="hljs-number">1</span>.发送一次网络请求, 等到这次网络请求的结果<br>    <span class="hljs-number">2</span>.发送第二次网络请求, 等待这次网络请求的结果<br>    <span class="hljs-number">3</span>.发送第三次网络请求, 等待这次网络请求的结果<br>*/<br><span class="hljs-regexp">//</span> 方式一: 层层嵌套(回调地狱 callback hell)<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span> getData() &#123;<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>.第一次请求<br><span class="hljs-regexp">//</span>   requestData(<span class="hljs-string">&quot;why&quot;</span>).then(res1 =&gt; &#123;<br><span class="hljs-regexp">//</span>     console.log(<span class="hljs-string">&quot;第一次结果:&quot;</span>, res1)<br><br><span class="hljs-regexp">//</span>     <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>.第二次请求<br><span class="hljs-regexp">//</span>     requestData(res1 + <span class="hljs-string">&quot;kobe&quot;</span>).then(res2 =&gt; &#123;<br><span class="hljs-regexp">//</span>       console.log(<span class="hljs-string">&quot;第二次结果:&quot;</span>, res2)<br><br><span class="hljs-regexp">//</span>       <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>.第三次请求<br><span class="hljs-regexp">//</span>       requestData(res2 + <span class="hljs-string">&quot;james&quot;</span>).then(res3 =&gt; &#123;<br><span class="hljs-regexp">//</span>         console.log(<span class="hljs-string">&quot;第三次结果:&quot;</span>, res3)<br><span class="hljs-regexp">//</span>       &#125;)<br><span class="hljs-regexp">//</span>     &#125;)<br><span class="hljs-regexp">//</span>   &#125;)<br><span class="hljs-regexp">//</span> &#125;<br><br><span class="hljs-regexp">//</span> 方式二: 使用Promise进行重构(解决回调地狱)<br><span class="hljs-regexp">//</span> 链式调用<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span> getData() &#123;<br><span class="hljs-regexp">//</span>   requestData(<span class="hljs-string">&quot;why&quot;</span>).then(res1 =&gt; &#123;<br><span class="hljs-regexp">//</span>     console.log(<span class="hljs-string">&quot;第一次结果:&quot;</span>, res1)<br><span class="hljs-regexp">//</span>     return requestData(res1 + <span class="hljs-string">&quot;kobe&quot;</span>)<br><span class="hljs-regexp">//</span>   &#125;).then(res2 =&gt; &#123;<br><span class="hljs-regexp">//</span>     console.log(<span class="hljs-string">&quot;第二次结果:&quot;</span>, res2)<br><span class="hljs-regexp">//</span>     return requestData(res2 + <span class="hljs-string">&quot;james&quot;</span>)<br><span class="hljs-regexp">//</span>   &#125;).then(res3 =&gt; &#123;<br><span class="hljs-regexp">//</span>     console.log(<span class="hljs-string">&quot;第三次结果:&quot;</span>, res3)<br><span class="hljs-regexp">//</span>   &#125;)<br><span class="hljs-regexp">//</span> &#125;<br></code></pre></td></tr></table></figure><ul><li><p>上面第一个没有第二个优雅，因为第一个是属于调用，就是一层层嵌套，而第二个只是返回了新的promise，属于链式调用。</p></li><li><p>而第二种看着结构不够清晰，我们可以用生成器来进行进一步简化</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span>* getData() &#123;  <span class="hljs-regexp">//</span>*是生成器的标志<br> <span class="hljs-regexp">//</span>   const res1 = yield requestData(<span class="hljs-string">&quot;why&quot;</span>)<br> <span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&quot;res1:&quot;</span>, res1)<br>  <br> <span class="hljs-regexp">//</span>   const res2 = yield requestData(res1 + <span class="hljs-string">&quot;kobe&quot;</span>)<br> <span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&quot;res2:&quot;</span>, res2)<br>  <br> <span class="hljs-regexp">//</span>   const res3 = yield requestData(res2 + <span class="hljs-string">&quot;james&quot;</span>)<br> <span class="hljs-regexp">//</span>   console.log(<span class="hljs-string">&quot;res3:&quot;</span>, res3)<br> <span class="hljs-regexp">//</span> &#125;<br>  <br> <span class="hljs-regexp">//</span> const generator = getData()<br> <span class="hljs-regexp">//</span> generator.<span class="hljs-keyword">next</span>().value.then(res1 =&gt; &#123;  <span class="hljs-regexp">//yi</span>eld返回一个对象，value是yield后面的值<br> <span class="hljs-regexp">//</span>   generator.<span class="hljs-keyword">next</span>(res1).value.then(res2 =&gt; &#123;<br> <span class="hljs-regexp">//</span>     generator.<span class="hljs-keyword">next</span>(res2).value.then(res3 =&gt; &#123;<br> <span class="hljs-regexp">//</span>       generator.<span class="hljs-keyword">next</span>(res3)<br> <span class="hljs-regexp">//</span>     &#125;)<br> <span class="hljs-regexp">//</span>   &#125;)<br> <span class="hljs-regexp">//</span> &#125;)<br></code></pre></td></tr></table></figure></li><li><p>这样的话看着就清晰多了，但感觉只是清晰了，我们可以看看有没有更好的办法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestData</span>(<span class="hljs-string">&quot;why&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res1:&quot;</span>, res1)<br>  <br>  <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestData</span>(res1 + <span class="hljs-string">&quot;kobe&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res2:&quot;</span>, res2)<br>  <br>  <span class="hljs-keyword">const</span> res3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestData</span>(res2 + <span class="hljs-string">&quot;james&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res3:&quot;</span>, res3)<br>&#125;<br>  <br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">getData</span>()<br></code></pre></td></tr></table></figure></li><li><p>async和await是生成器的语法糖，使用了语法糖后的代码太优雅。太简洁了。这就是代码的艺术嘛</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS迭代器</title>
    <link href="/2022/08/10/JS%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2022/08/10/JS%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h2><ul><li>迭代器（iterator），使用户在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。</li><li>主要还是可以用foreach方法，展开语法，解构对象</li></ul><h3 id="中断（少用）"><a href="#中断（少用）" class="headerlink" title="中断（少用）"></a>中断（少用）</h3><ul><li>迭代器在某些情况下会在没有完全迭代的情况下中断：<ul><li>比如遍历的过程中通过break、return、throw中断了循环操作；</li><li>比如在解构的时候，没有解构所有的值；</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">  [Symbol.iterator]() &#123;<br>    let index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">const</span> iterator = &#123;<br>      next: () =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-keyword">this</span>.friends.length) &#123;<br>          <span class="hljs-keyword">return</span> &#123; done: <span class="hljs-literal">false</span>, value: <span class="hljs-keyword">this</span>.friends[index++] &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123; done: <span class="hljs-literal">true</span> &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-keyword">return</span>: () =&gt; &#123;<br>        console.log(<span class="hljs-string">&quot;监听到迭代器中断了&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123; done: <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">//不写返回undefined会报错</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> iterator<br>  &#125; <span class="hljs-comment">//在Person类里面编写</span><br>  <br>  <span class="hljs-keyword">const</span> p1 = new Person(<span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>, [<span class="hljs-string">&quot;curry&quot;</span>, <span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-string">&quot;james&quot;</span>, <span class="hljs-string">&quot;tatumu&quot;</span>])<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item of p1) &#123;<br>  console.log(item)<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-string">&quot;kobe&quot;</span>) &#123;<br>    <span class="hljs-keyword">break</span><br>  &#125;<br>&#125; <span class="hljs-comment">//可以监听到</span><br></code></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul><li>生成器是ES6中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><ul><li>首先，生成器函数需要在function的后面加一个符号：*</li><li>其次，生成器函数可以通过yield关键字来控制函数的执行流程：</li><li>最后，生成器函数的返回值是一个Generator（生成器）：<ul><li>生成器事实上是一种特殊的迭代器；</li></ul></li></ul></li><li><p>调用生成器时不会执行函数，而是返回一个生成器对象</p></li><li><p>想要让生成器函数执行需要调用next</p></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 1.定义了一个生成器函数</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;1111&quot;</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;2222&quot;</span>)<br>  yield<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;3333&quot;</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;4444&quot;</span>)<br>  yield<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;5555&quot;</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;6666&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 2.调用生成器函数, 返回一个 生成器对象</span><br>const generator = foo()<br><span class="hljs-comment">// 调用next方法</span><br>generator.next() <span class="hljs-comment">//执行函数直到遇到yield</span><br>generator.next()<br>generator.next()<br></code></pre></td></tr></table></figure><ul><li>yield会返回其后面的值</li><li><code> yield &quot;aaa&quot;</code> 执行next时</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS代理</title>
    <link href="/2022/08/09/JS%E4%BB%A3%E7%90%86/"/>
    <url>/2022/08/09/JS%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><ul><li>施工中</li></ul><h3 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h3><ul><li>就是属性改变时，我们可以获取到其改变及其改变的值</li><li>ES5</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> keys) &#123;<br>  <span class="hljs-keyword">let</span> value = obj[key]<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 给<span class="hljs-subst">$&#123;key&#125;</span>设置了新的值:`</span>, newValue)<br>      value = newValue<br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 获取<span class="hljs-subst">$&#123;key&#125;</span>的值`</span>)<br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>我们可以看到，这样很麻烦</p></li><li><p>其次，如果我们想监听更加丰富的操作，比如新增属性、删除属性，那么 Object.defineProperty是无能为力的。</p></li><li><p>因为Object.defineProperty设计的初衷，不是为了去监听截止一个对象中 所有的属性的。</p></li></ul><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><ul><li><p>在ES6中，新增了一个Proxy类，这个类从名字就可以看出来，是用于帮助我们创建一个代理的：</p></li><li><p>首先，我们需要new Proxy对象，并且传入需要侦听的对象以及一个处理对象，可以称之为handler；</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Proxy(<span class="hljs-keyword">target</span>, <span class="hljs-keyword">handler</span>)<br></code></pre></td></tr></table></figure></li><li><p>其次，我们之后的操作都是直接对Proxy的操作，而不是原有的对象，因为我们需要在handler里面进行侦听；</p></li><li><p>如果我们想要侦听某些具体的操作，那么就可以在handler中添加对应的捕捉器（Trap）：</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解构</title>
    <link href="/2022/08/06/%E8%A7%A3%E6%9E%84/"/>
    <url>/2022/08/06/%E8%A7%A3%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="解构Destructuring"><a href="#解构Destructuring" class="headerlink" title="解构Destructuring"></a>解构<strong>Destructuring</strong></h2><ul><li><p><strong>解构赋值</strong> 是一种特殊的语法，它使我们可以将数组或对象“拆包”至一系列变量中。</p></li><li><p>拆分对象内容</p></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> names = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;cba&quot;</span>, undefined, <span class="hljs-string">&quot;nba&quot;</span>, <span class="hljs-string">&quot;mba&quot;</span>]</span><br><span class="hljs-selector-tag">var</span> obj = &#123; name: <span class="hljs-string">&#x27;why&#x27;</span>, age: <span class="hljs-number">18</span>, <span class="hljs-attribute">height</span>: <span class="hljs-number">1.88</span> &#125;<br> <span class="hljs-comment">// 1.数组的解构 没使用</span><br> <span class="hljs-selector-tag">var</span> name1 = names<span class="hljs-selector-attr">[0]</span><br> <span class="hljs-selector-tag">var</span> name2 = names<span class="hljs-selector-attr">[1]</span><br> <span class="hljs-selector-tag">var</span> name3 = names<span class="hljs-selector-attr">[2]</span><br> <br> <span class="hljs-comment">//使用解构</span><br> <span class="hljs-selector-tag">var</span> <span class="hljs-selector-attr">[name1, name2, name3]</span> = names<br> <br> <span class="hljs-comment">//对象的解构</span><br> <span class="hljs-selector-tag">var</span> &#123; name, age, <span class="hljs-attribute">height</span> &#125; = obj<br> <br> <span class="hljs-comment">//1.3. 解构出数组</span><br> <span class="hljs-selector-tag">var</span> <span class="hljs-selector-attr">[name1, name2, ...newNames]</span> = names<br> console<span class="hljs-selector-class">.log</span>(name1, name2, newNames)<br> <br> <span class="hljs-comment">// 1.4. 解构的默认值</span><br> <span class="hljs-selector-tag">var</span> <span class="hljs-selector-attr">[name1, name2, name3 = <span class="hljs-string">&quot;default&quot;</span>]</span> = names<br> console<span class="hljs-selector-class">.log</span>(name1, name2, name3)<br></code></pre></td></tr></table></figure><ul><li>解构数组时要有严格的顺序</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">var [<span class="hljs-symbol">name1</span>, , <span class="hljs-symbol">name3</span>] = <span class="hljs-symbol">names</span><br></code></pre></td></tr></table></figure><ul><li>获取第一个和第三个数组值时，第二个不能忽略，要留个空</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字面量增强</title>
    <link href="/2022/08/06/%E5%AD%97%E9%9D%A2%E9%87%8F%E5%A2%9E%E5%BC%BA/"/>
    <url>/2022/08/06/%E5%AD%97%E9%9D%A2%E9%87%8F%E5%A2%9E%E5%BC%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="对象字面量增强"><a href="#对象字面量增强" class="headerlink" title="对象字面量增强"></a>对象字面量增强</h2><h3 id="属性的增强"><a href="#属性的增强" class="headerlink" title="属性的增强"></a>属性的增强</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;s&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">4</span><br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  name, <span class="hljs-comment">//name: name</span><br>  age <span class="hljs-comment">//age: age</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法的增强"><a href="#方法的增强" class="headerlink" title="方法的增强"></a>方法的增强</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  name,<br>  age,<br>  <span class="hljs-attr">running</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  &#125;,<br>  <span class="hljs-title function_">swimming</span>(<span class="hljs-params"></span>) &#123; &#125; <span class="hljs-comment">//有this，增强</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计算属性的增强"><a href="#计算属性的增强" class="headerlink" title="计算属性的增强"></a>计算属性的增强</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> key = <span class="hljs-string">&#x27;address&#x27;</span><br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  name,<br>  age,<br>  <span class="hljs-attr">running</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>  <span class="hljs-title function_">swimming</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>  <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;广州&#x27;</span>,<br>  [key]:<span class="hljs-string">&#x27;广州&#x27;</span> <span class="hljs-comment">//可以引入外部变量</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><ul><li><p>当引用一个请求过来的数据而里面内容太多时</p></li><li><p>这样他原本.app_house_title就变成了.title</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">    <span class="hljs-keyword">var</span> searchListData = res.rent_house_list.list || []<br>    searchListData = searchListData.<span class="hljs-built_in">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>       <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">title</span>: item.app_house_title<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS多态</title>
    <link href="/2022/08/06/JS%E5%A4%9A%E6%80%81/"/>
    <url>/2022/08/06/JS%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="wiki"><a href="#wiki" class="headerlink" title="wiki"></a>wiki</h2><ul><li>维基百科对多态的定义：<strong>多态</strong>（英语：polymorphism）指为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型。</li></ul><h2 id="存在条件"><a href="#存在条件" class="headerlink" title="存在条件"></a>存在条件</h2><ul><li>必须有继承</li><li>父类引用指向子类对象</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>))<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;nhc&#x27;</span>))<br></code></pre></td></tr></table></figure><ul><li>这算多态，有单一符号表示多个不同类型（继承？）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS闭包</title>
    <link href="/2022/08/05/JS%E9%97%AD%E5%8C%85/"/>
    <url>/2022/08/05/JS%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="MDN解释"><a href="#MDN解释" class="headerlink" title="MDN解释"></a>MDN解释</h3><ul><li><p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）；</p></li><li><p>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；</p></li><li><p>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；</p></li></ul><h3 id="Feel"><a href="#Feel" class="headerlink" title="Feel"></a>Feel</h3><ul><li>感觉你只要在函数中访问了作用域链，那么你就使用了闭包</li><li>从广义的角度来说：JavaScript中的函数都是闭包；</li><li>从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包；</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>请理解作用域链</li><li>还有内存泄漏的问题，主要是影响性能。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS原型</title>
    <link href="/2022/08/05/JS%E5%8E%9F%E5%9E%8B/"/>
    <url>/2022/08/05/JS%E5%8E%9F%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS执行原理</title>
    <link href="/2022/08/03/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <url>/2022/08/03/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="代码执行过程"><a href="#代码执行过程" class="headerlink" title="代码执行过程"></a>代码执行过程</h2><h3 id="初始化全局对象"><a href="#初始化全局对象" class="headerlink" title="初始化全局对象"></a>初始化全局对象</h3><ul><li>js引擎会在执行代码之前，会在<strong>堆</strong>内存中创建一个<strong>全局对象</strong>：Global Object（GO）<ul><li>该对象所有的作用域（scope）都可以访问；</li><li>里面会包含Date、Array、String、Number、setTimeout、setInterval等等；</li><li>其中还有一个window属性指向自己； &#x2F;&#x2F;window居然是属性嘛</li></ul></li></ul><h3 id="执行上下文（-Execution-Contexts-）"><a href="#执行上下文（-Execution-Contexts-）" class="headerlink" title="执行上下文（ Execution Contexts ）"></a>执行上下文（ Execution Contexts ）</h3><ul><li><p>他是执行代码的调用<strong>栈</strong></p></li><li><p>栈是执行代码的地方，堆是存放内存的地方</p></li><li><p>在栈的最底层是GO：Global Object；</p></li><li><p>在执行函数（fn）时，函数会创建一个新的对象，然后入栈，执行完毕后会出栈。</p></li><li><p>栈 先入后出</p></li><li><p>或许作用域链跟栈结构息息相关</p></li></ul><h3 id="VO对象（Variable-Object）"><a href="#VO对象（Variable-Object）" class="headerlink" title="VO对象（Variable Object）"></a>VO对象（Variable Object）</h3><ul><li><p>每一个执行上下文会关联一个VO（Variable Object，变量对象），变量和函数声明会被添加到这个VO对象中。</p></li><li><p>每一个函数调用时都会创建一个AO，与GO相对应。GO是全局，AO是函数个体。</p></li></ul><h3 id="作用域和作用域链（Scope-Chain）"><a href="#作用域和作用域链（Scope-Chain）" class="headerlink" title="作用域和作用域链（Scope Chain）"></a>作用域和作用域链（Scope Chain）</h3><ul><li>当进入到一个执行上下文(栈)时，执行上下文也会关联一个作用域链（Scope Chain）<ul><li>作用域链是一个对象列表，用于变量标识符的求值；</li><li>当建立作用域链时，变量的指向久已被确定。即使之后在不同位置被调用，建立作用域链时指定的变量不变，函数内的值也不变</li></ul></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> message = <span class="hljs-string">&quot;Global Message&quot;</span><br>function <span class="hljs-built_in">foo</span>() &#123;<br>  console<span class="hljs-selector-class">.log</span>(message)<br>  <span class="hljs-selector-tag">var</span> message = <span class="hljs-string">&#x27;foo&#x27;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//undefind </span><br></code></pre></td></tr></table></figure><ul><li>需要message -&gt; 寻找自身 -&gt; 有 -&gt; 就不会去上层寻找</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> message = <span class="hljs-string">&quot;Global Message&quot;</span><br>function <span class="hljs-built_in">foo</span>() &#123;<br>  <span class="hljs-selector-tag">var</span> message = <span class="hljs-string">&#x27;foo&#x27;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><br><span class="hljs-selector-tag">var</span> obj = &#123;<br>  name: <span class="hljs-string">&quot;obj&quot;</span>,<br>  bar: <span class="hljs-built_in">function</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> message = <span class="hljs-string">&quot;bar message&quot;</span><br>    <span class="hljs-built_in">foo</span>() <span class="hljs-comment">//</span><br>  &#125;<br>&#125;<br><br>obj<span class="hljs-selector-class">.bar</span>() <span class="hljs-comment">//Global Message</span><br><br></code></pre></td></tr></table></figure><ul><li>我们看到 obj.bar()调用，会先寻找函数内有没有message，然后看看obj里有没有message找到了，这时候就是忽略了作用域链的规则，当定义（创建？）函数时，作用域链已被确定。</li><li>函数被定义时，作用域链已经确定，message指向的是第一个message</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> n = <span class="hljs-number">100</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(n)<br>  <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">200</span><br>&#125;<br>foo() <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><ul><li>在解析函数时，就直接把n提升了。遇到return是解析完后调用时的事。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染</title>
    <link href="/2022/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/"/>
    <url>/2022/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h2 id="网页解析"><a href="#网页解析" class="headerlink" title="网页解析"></a>网页解析</h2><h3 id="常用的浏览器内核"><a href="#常用的浏览器内核" class="headerlink" title="常用的浏览器内核"></a>常用的浏览器内核</h3><ul><li>Trident （ 三叉戟）：IE、360安全浏览器、搜狗高速浏览器、百度浏览器、UC浏览器；</li><li>Gecko（ 壁虎） ：Mozilla Firefox；  Presto（急板乐曲）-&gt; Blink （眨眼）：Opera</li><li>Webkit ：Safari、360极速浏览器、搜狗高速浏览器、移动端浏览器（Android、iOS）</li><li>Webkit -&gt; Blink ：Google Chrome，Edge</li></ul><h5 id="我们经常说的浏览器内核指的是浏览器的排版引擎："><a href="#我们经常说的浏览器内核指的是浏览器的排版引擎：" class="headerlink" title="我们经常说的浏览器内核指的是浏览器的排版引擎："></a>我们经常说的浏览器内核指的是浏览器的排版引擎：</h5><ul><li>排版引擎（layout engine），也称为浏览器引擎（browser engine）、页面渲染引擎（rendering engine）或样版引擎。</li><li>也就是一个网页下载下来后，就是由我们的渲染引擎来帮助我们解析的</li></ul><h4 id="渲染引擎在拿到一个页面后，如何解析整个页面并且最终呈现出我们的网页呢？"><a href="#渲染引擎在拿到一个页面后，如何解析整个页面并且最终呈现出我们的网页呢？" class="headerlink" title="渲染引擎在拿到一个页面后，如何解析整个页面并且最终呈现出我们的网页呢？"></a>渲染引擎在拿到一个页面后，如何解析整个页面并且最终呈现出我们的网页呢？</h4><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\DOM node.png)</p><ul><li>更详细</li></ul><p><img src="C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\DOMnodeMore.png"></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>在解析HTML文件时，会生成DOM Tree</p></li><li><p>如果遇到CSS的link元素，那么会由浏览器负责下载对应的CSS文件：不会停止解析</p></li><li><p>浏览器下载完CSS后，会生成CSSOM（CSS Object Model，CSS对象模型）</p></li><li><p>当有了DOM Tree和 CSSOM Tree后，就可以两个结合来构建Render Tree了</p></li><li><p>![](C:\Users\admin\Desktop\vue\blog\hexoblog\source\images\Render Tree.png)</p></li><li><p>布局</p><ul><li>布局是确定呈现树中所有节点的宽度、高度和位置信息；</li></ul></li><li><p>绘制</p><ul><li>在绘制阶段，浏览器将布局阶段计算的每个frame转为屏幕上实际的像素点；</li><li>包括将元素的可见部分进行绘制，比如文本、颜色、边框、阴影、替换元素（比如img）</li></ul></li></ul><h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><ul><li><p>在布局后改变节点布局那就称为回流</p></li><li><p>引起</p><ul><li>比如DOM结构发生改变（添加新的节点或者移除节点）；</li><li>比如改变了布局（修改了width、height、padding、font-size等值） </li><li>比如窗口resize（修改了窗口的尺寸等）</li><li>比如调用getComputedStyle方法获取尺寸、位置信息；</li></ul></li><li><p>重绘</p><ul><li>和回流一样，再次绘制就是重绘</li><li>比如修改背景色、文字颜色、边框颜色、样式等；会引起重绘</li></ul></li></ul><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><ul><li>消耗性能</li><li>尽量避免</li><li>1.修改样式时尽量一次性修改  比如通过cssText修改，比如通过添加class修改 </li><li>◼ 2.尽量避免频繁的操作DOM </li><li> 我们可以在一个DocumentFragment或者父元素中 将要操作的DOM操作完成，再一次性的操作；</li><li>◼ 3.尽量避免通过getComputedStyle获取尺寸、位置等信 息；</li><li>◼ 4.对某些元素使用position的absolute或者fixed  并不是不会引起回流，而是开销相对较小，不会对 其他元素造成影响。</li></ul><h2 id="script元素和页面解析的关系"><a href="#script元素和页面解析的关系" class="headerlink" title="script元素和页面解析的关系"></a>script元素和页面解析的关系</h2><ul><li><p>事实上，浏览器在解析HTML的过程中，遇到了script元素是不能继续构建DOM树的；</p></li><li><p>它会停止继续构建，首先下载JavaScript代码，并且执行JavaScript的脚本；</p></li><li><p>只有等到JavaScript脚本执行结束后，才会继续解析HTML，构建DOM树；</p></li><li><p>这是因为JavaScript的作用之一就是操作DOM，并且可以修改DOM；</p></li><li><p>如果我们等到DOM树构建完成并且渲染再执行JavaScript，会造成严重的回流和重绘，影响页面的性能； </p></li><li><p>所以会在遇到script元素时，优先下载和执行JavaScript代码，再继续构建DOM树；</p></li></ul><h3 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h3><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><ul><li>defer 属性告诉浏览器不要等待脚本下载，而继续解析HTML，构建DOM Tree。</li><li>如果脚本提前下载好了，它会等待DOM Tree构建完成，在DOMContentLoaded事件之前先执行defer中的代码；</li><li>从某种角度来说，defer可以提高页面的性能，并且推荐放到head元素中；</li><li>注意：defer仅适用于外部脚本，对于script默认内容会被忽略。</li></ul><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><ul><li><p>async 特性与 defer 有些类似，它也能够让脚本不阻塞页面。</p></li><li><p>async脚本不能保证顺序，它是独立下载、独立运行，不会等待其他脚本；</p></li><li><p>async不会能保证在DOMContentLoaded之前或者之后执行；</p></li><li><p>async通常用于独立的脚本，对其他脚本，甚至DOM没有依赖的；</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高阶-this</title>
    <link href="/2022/07/31/JS%E9%AB%98%E9%98%B6-this/"/>
    <url>/2022/07/31/JS%E9%AB%98%E9%98%B6-this/</url>
    
    <content type="html"><![CDATA[<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ul><li>this是一个非常方便的工具。他非常的灵活，我们都知道，，越灵活表示他的规则我没越难掌握。</li><li>接下来让我们好好的去了解一下这个灵活的工具</li></ul><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><ul><li><p>我们定义一个函数，然后调用他，看看再此函数中定义的this指向哪</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;指向:&quot;</span>+this)<br> &#125;<br> foo() <span class="hljs-comment">///指向:[object Window]</span><br> <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">fn</span>) &#123;<br>   fn()<br> &#125;<br> <span class="hljs-keyword">var</span> bor = &#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>,<br>   <span class="hljs-attr">baz</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this)<br>   &#125;<br> &#125;<br> foo(bor.baz) <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><ul><li><p>再直接调用的情况下指向了window对象。那我们再看看其他情况</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var bor = &#123;<br>  <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>,<br>  foo<br>&#125;<br>  <br>bor.foo() //指向:[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br></code></pre></td></tr></table></figure></li><li><p>当他在对象中时，且使用对象.调用他时，他的指向变成了对象。</p></li><li><p>那么，还有其他的情况嘛</p></li></ul><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><ul><li><p>在JS中，还有一种方法，可以直接指定函数的this指向对象</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">foo.call(<span class="hljs-string">&#x27;dog&#x27;</span>) <span class="hljs-regexp">//</span>指向:dog<br></code></pre></td></tr></table></figure></li><li><p>call还有apply都可以指定this的指向</p></li><li><p>不同的是，他们可以传多个参数，第一个为指定this的指定。</p></li><li><p>而后面的就是传给函数的参数</p></li><li><p>apply为数组方式传递，而call为参数列表方式传递。</p></li></ul><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><ul><li>JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字</li><li>使用new关键字来调用函数时，会执行如下的操作：<ul><li> 1.创建一个全新的对象； </li><li> 2.这个新对象会被执行prototype连接；</li><li> 3.这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）；</li><li> 4.如果函数没有返回其他对象，表达式会返回这个新对象；</li></ul></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">   <span class="hljs-keyword">function</span> Person(<span class="hljs-type">name</span>) &#123;<br>     console.log(&quot;指向:&quot;+this)<br>     this.name = <span class="hljs-type">name</span><br>   &#125;<br>   var p = <span class="hljs-built_in">new</span> Person(<span class="hljs-string">&#x27;pan&#x27;</span>)<br>   console.log(p)<br>   <br>   指向:[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br>Person<br>       <span class="hljs-type">name</span>: &quot;pan&quot;<br>       __proto__: <span class="hljs-keyword">Object</span><br></code></pre></td></tr></table></figure><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li>过</li></ul><h3 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h3><ul><li><p>函数也是对象的一个属性，而没有绑定对象的函数则被绑定到window中。</p></li><li><p>而this是指向对象的。所以直接调用函数的情况下，函数没有被设置绑定那个对象，就被浏览器绑定到window中，这样this指向的就是window。</p></li></ul><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><ul><li>window是一个对象，window可以包含函数。</li><li>函数是对象的一个属性，函数要在对象中才能运行。</li><li>没有对象的函数会被挂靠在window中</li></ul><h4 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h4><ul><li>无</li></ul><h3 id="间接函数引用"><a href="#间接函数引用" class="headerlink" title="间接函数引用"></a>间接函数引用</h3><ul><li>赋值(obj2.foo &#x3D; obj1.foo)的结果是foo函数</li><li>foo函数被直接调用，那么是默认绑定；</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this)<br>&#125;<br><span class="hljs-keyword">var</span> bor = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br><span class="hljs-keyword">var</span> bor2 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;me&#x27;</span><br>&#125;<br>bor.foo(); <span class="hljs-comment">//bor</span><br>(bor2.foo = bor.foo)(); <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure><ul><li>主要还是有个括号</li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul><li><p>箭头函数是ES6之后增加的一种编写函数的方法，并且它比函数表达式要更加简洁：</p></li><li><p>他没有this属性，当在其中编写this属性时，会向上级作用域寻找。</p></li><li><p><strong>对象没有作用域，函数有</strong></p></li><li><p>但也因为它没有this属性，所以在一些地方的规则会不一样。</p></li><li><p>它不适用上面的四种规则，而是去外层作用域来决定this</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 编写<br>() =&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>看起来很简洁，很方便，也确实如此，只是在用this的地方要小心</p></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><p>如果只有一个参数可以省略()</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">nums.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure></li><li><p>如果函数执行体中只有一行代码，那么可以省略大括号</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">nums.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(item))<br>nums.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><ul><li>并且这行代码的返回值会作为整个函数的返回值</li></ul></li></ul><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade">   <span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-comment">//对象没有作用域</span><br>     name: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>     <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//外层作用域，因为是函数，所以有作用域</span><br>     <br>       <span class="hljs-keyword">var</span> bor = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-comment">//在外层作用域中寻找this</span><br>         <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;bar:&#x27;</span>, this)<br>       &#125;<br>       <span class="hljs-keyword">return</span> bor<br>     &#125;<br>     <br>   &#125;<br>   <span class="hljs-keyword">var</span> fn = obj.foo()<br>   fn.apply(<span class="hljs-string">&#x27;baa&#x27;</span>)<br>   <br>输出：<br>bar: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj&quot;</span>, <span class="hljs-attr">foo</span>: ƒ&#125;<br>       foo: ƒ ()<br>       name: <span class="hljs-string">&quot;obj&quot;</span><br>       __proto__: Object<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON</title>
    <link href="/2022/07/28/JSON/"/>
    <url>/2022/07/28/JSON/</url>
    
    <content type="html"><![CDATA[<h2 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h2><ul><li>JSON是一种数据格式</li><li>算是JavaScript的一个子集</li><li>目前已独立于编程语言，可以在各个编程语言中使用</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul><li>顶层不能放注释，支持下面三种类型的值</li><li>简单值：数字（Number）、字符串（String，不支持单引号）、布尔类型（Boolean）、null类型；</li><li>对象值：由key、value组成，key是字符串类型，并且必须添加双引号，值可以是简单值、对象值、数组值；</li><li>数组值：数组的值可以是简单值、对象值、数组值；</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul><li>将复杂的数据类似对象转换成JSON格式的字符串</li><li>在ES5中引用了JSON全局对象，该对象有两个常用的方法：</li><li> stringify方法：将JavaScript类型转成对应的JSON字符串；</li><li> parse方法：解析JSON字符串，转回对应的JavaScript类型；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS轮播图</title>
    <link href="/2022/07/27/JS%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
    <url>/2022/07/27/JS%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="只能触碰下面的导航来更换图片"><a href="#只能触碰下面的导航来更换图片" class="headerlink" title="只能触碰下面的导航来更换图片"></a>只能触碰下面的导航来更换图片</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> titleListEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.title-list&quot;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> activeItemEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.active&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> imageListEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.image-list&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    titleListEl.<span class="hljs-property">onmouseover</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> itemEl = event.<span class="hljs-property">target</span>.<span class="hljs-property">parentElement</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">if</span>(!itemEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;item&#x27;</span>)) <span class="hljs-keyword">return</span></span><br><span class="language-javascript">      </span><br><span class="language-javascript">      activeItemEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;active&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      itemEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      activeItemEl = itemEl</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; titleListEl.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (titleListEl.<span class="hljs-property">children</span>[i] == itemEl) <span class="hljs-keyword">break</span></span><br><span class="language-javascript">      &#125; <span class="hljs-comment">//感觉要用var有点难受</span></span><br><span class="language-javascript">      </span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> index = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(titleListEl.<span class="hljs-property">children</span>).<span class="hljs-title function_">findIndex</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> item === itemEl</span><br><span class="language-javascript">      &#125;) <span class="hljs-comment">//另一种获取索引的方法</span></span><br><span class="language-javascript">      </span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)</span><br><span class="language-javascript">      imageListEl.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translateX(<span class="hljs-subst">$&#123;-<span class="hljs-number">604</span> * i&#125;</span>px)`</span></span><br><span class="language-javascript">      imageListEl.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">`all 300ms ease`</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="添加定时器"><a href="#添加定时器" class="headerlink" title="添加定时器"></a>添加定时器</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> start<span class="hljs-constructor">Timer()</span> &#123;<br>  timerID = set<span class="hljs-constructor">Interval(<span class="hljs-params">function</span>()</span> &#123;<br>    currentIndex++<br>    <span class="hljs-keyword">if</span> (currentIndex<span class="hljs-operator"> === </span>titleListEl.children.length) &#123;<br>      currentIndex = <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// 调用切换的函数</span><br>    switch<span class="hljs-constructor">Banner()</span><br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;<br>clear<span class="hljs-constructor">Interval(<span class="hljs-params">timerID</span>)</span> <span class="hljs-comment">//清除定时器</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS导航栏切换</title>
    <link href="/2022/07/27/JS%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%88%87%E6%8D%A2/"/>
    <url>/2022/07/27/JS%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="7月27"><a href="#7月27" class="headerlink" title="7月27"></a>7月27</h2><ul><li><p>原本在用JS给导航栏添加active时，鼠标移出的时候思路都是添加一个移出事件。</p></li><li><p>但今天发现一个更方便的写法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 1.获取元素</span><br><span class="hljs-selector-tag">var</span> tabControl = document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&quot;.tab_control&quot;</span>)<br>  <br><span class="hljs-comment">// 2.监听鼠标进入(事件委托)</span><br><span class="hljs-selector-tag">var</span> activeLiEl = tabControl<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&quot;.active&quot;</span>)<br>tabControl<span class="hljs-selector-class">.onmouseover</span> = <span class="hljs-built_in">function</span>(event) &#123;<br>  <span class="hljs-comment">// 1.拿到事件发生的对象</span><br>  <span class="hljs-selector-tag">var</span> itemEl = event<span class="hljs-selector-class">.target</span><br>  <span class="hljs-keyword">if</span> (itemEl<span class="hljs-selector-class">.classList</span><span class="hljs-selector-class">.contains</span>(<span class="hljs-string">&quot;item&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 其他的取消active</span><br>    <span class="hljs-comment">// 1.for循环所有的item</span><br>    <span class="hljs-comment">// 2.querySelector(&quot;.active&quot;)</span><br>    <span class="hljs-comment">// 3.记录当前的active对应的item</span><br>    activeLiEl<span class="hljs-selector-class">.classList</span><span class="hljs-selector-class">.remove</span>(<span class="hljs-string">&quot;active&quot;</span>)<br>  <br>    <span class="hljs-comment">// 当前进入的item变成active</span><br>    itemEl<span class="hljs-selector-class">.classList</span><span class="hljs-selector-class">.add</span>(<span class="hljs-string">&quot;active&quot;</span>)<br>  <br>    <span class="hljs-comment">// 将最新的itemEl变成activeLiEl</span><br>    activeLiEl = itemEl<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在鼠标进入时给目标添加一个标记，当鼠标移入另一个导航栏时令标记的导航栏移除active</p></li><li><p>记得标记先在上面获取</p></li><li><p>简便的代码才是好代码</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS鼠标事件</title>
    <link href="/2022/07/26/JS%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6/"/>
    <url>/2022/07/26/JS%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="mouseover和mouseenter的区别"><a href="#mouseover和mouseenter的区别" class="headerlink" title="mouseover和mouseenter的区别"></a>mouseover和mouseenter的区别</h2><h3 id="mouseenter和mouseleave"><a href="#mouseenter和mouseleave" class="headerlink" title="mouseenter和mouseleave"></a>mouseenter和mouseleave</h3><ul><li>不支持冒泡</li><li>进入子元素依然属于该元素内</li></ul><h3 id="mouseover和mouseout"><a href="#mouseover和mouseout" class="headerlink" title="mouseover和mouseout"></a>mouseover和mouseout</h3><ul><li>支持冒泡</li><li>进入元素的子元素时</li><li><ul><li>先调用父元素的mouseout</li><li>在调用子元素的mouseover</li><li>因为支持冒泡，所以mouseover传递到父元素中</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS事件委托</title>
    <link href="/2022/07/25/JS%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <url>/2022/07/25/JS%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡和捕获"><a href="#冒泡和捕获" class="headerlink" title="冒泡和捕获"></a>冒泡和捕获</h2><ul><li>在监听一个元素时，比如点击事件，监听一个大盒子的点击事件，里面的元素也可以被监听点击事件。</li><li>当你点击里面的元素时，事件的触发顺序是从外到里还是从里到外呢？</li></ul><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><ul><li>◼ 事实上对于事件有一个概念叫做事件流，为什么会产生事件流呢？</li><li> 我们可以想到一个问题：当我们在浏览器上对着一个元素点击时，你点击的不仅仅是这个元素本身；</li><li> 这是因为我们的HTML元素是存在父子元素叠加层级的；</li><li> 比如一个span元素是放在div元素上的，div元素是放在body元素上的，body元素是放在html元素上的；</li></ul><h3 id="事件冒泡和事件捕获"><a href="#事件冒泡和事件捕获" class="headerlink" title="事件冒泡和事件捕获"></a>事件冒泡和事件捕获</h3><ul><li>我们会发现默认情况下事件是从最内层的span向外依次传递的顺序，这个顺序我们称之为事件冒泡（Event Bubble）;从里到外</li><li>事实上，还有另外一种监听事件流的方式就是从外层到内层（body -&gt; span），这种称之为事件捕获（Event Capture）；从外到里</li></ul><h3 id="监听ul里li的点击事件"><a href="#监听ul里li的点击事件" class="headerlink" title="监听ul里li的点击事件"></a>监听ul里li的点击事件</h3><ul><li><p>当点击li时，li会变色</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> liEls = document<span class="hljs-selector-class">.querySelectorAll</span>(<span class="hljs-string">&#x27;li&#x27;</span>)<br><span class="hljs-keyword">for</span> (const liEl of liEls) &#123;<br>  liEl<span class="hljs-selector-class">.onclick</span> = <span class="hljs-built_in">function</span>() &#123;<br>    liEl<span class="hljs-selector-class">.classList</span><span class="hljs-selector-class">.add</span>(<span class="hljs-string">&quot;active&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以监听ul</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> ulEl = document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)<br>ulEl<span class="hljs-selector-class">.onclick</span> = <span class="hljs-built_in">function</span>(e) &#123;<br>  e<span class="hljs-selector-class">.target</span><span class="hljs-selector-class">.classList</span><span class="hljs-selector-class">.add</span>(<span class="hljs-string">&quot;active&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="这就是委托模式"><a href="#这就是委托模式" class="headerlink" title="这就是委托模式"></a>这就是委托模式</h3><ul><li>因为当子元素被点击时，父元素可以通过冒泡可以监听到子元素的点击；</li><li>并且可以通过event.target获取到当前监听的元素；</li></ul><h3 id="BUT"><a href="#BUT" class="headerlink" title="BUT"></a>BUT</h3><ul><li><p>当父元素中有多个子元素时，委托模式应多考虑考虑</p></li><li><p>如</p></li><li><p>创建一个侧边栏，当鼠标放上去时会改变子元素的宽度以便展示文字</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tool-bar&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon icon01&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>购物车<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon icon02&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>收藏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon icon03&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>限时活动<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon icon04&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>大礼包<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>不使用委托模式是这样的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> itemEls = document<span class="hljs-selector-class">.querySelectorAll</span>(<span class="hljs-string">&quot;.item&quot;</span>) <span class="hljs-comment">//获取目标</span><br><span class="hljs-keyword">for</span> (<span class="hljs-selector-tag">var</span> itemEl of itemEls) &#123;  <span class="hljs-comment">//遍历</span><br>  itemEl<span class="hljs-selector-class">.onmouseenter</span> = <span class="hljs-built_in">function</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> nameEl = this<span class="hljs-selector-class">.children</span><span class="hljs-selector-attr">[1]</span><br>    nameEl<span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.width</span> = <span class="hljs-string">&quot;62px&quot;</span> <br>  &#125;<br>  itemEl<span class="hljs-selector-class">.onmouseleave</span> = <span class="hljs-built_in">function</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> nameEl = this<span class="hljs-selector-class">.children</span><span class="hljs-selector-attr">[1]</span><br>    nameEl<span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.width</span> = <span class="hljs-string">&quot;0&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在这里使用委托模式时，鼠标放入会因为冒泡而产生多次事件，同时，放入鼠标时还需要改变目标</p></li><li><p>鼠标一进去时先进入item盒子然后离开item盒子，进入i标签，使用委托的话就触发了两次进入与一次退出。</p></li><li><p>又因为离开了item盒子进入了i标签，还需要改变进入i标签时的目标指向</p></li><li><pre><code class="hljs">var itemEl = event.target.classList.contains(&quot;item&quot;) ? event.target:event.target.parentElement</code></pre></li><li><p>这样就感觉很麻烦</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM初步了解</title>
    <link href="/2022/07/23/DOM%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/07/23/DOM%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="DOM-文档对象模型（Document-Object-Model）"><a href="#DOM-文档对象模型（Document-Object-Model）" class="headerlink" title="DOM: 文档对象模型（Document Object Model）"></a>DOM: 文档对象模型（Document Object Model）</h2><ul><li>简称DOM，将页面所有内容表示为可以修改的对象</li><li>将HTML中的元素抽象成我们可以编辑的对象就叫文档对象模型</li><li>DOMtree（尚未理解）</li></ul><h2 id="BOM：浏览器对象模型（Browser-Object-Model）"><a href="#BOM：浏览器对象模型（Browser-Object-Model）" class="headerlink" title="BOM：浏览器对象模型（Browser Object Model）"></a>BOM：浏览器对象模型（Browser Object Model）</h2><ul><li>由浏览器提供的用于处理文档之外的所有内容的其他对象</li><li>比如navigator，location，history等</li></ul><h2 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(document.doctype) <span class="hljs-comment">//文档声明</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(document.documentElement) <span class="hljs-comment">//html元素</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(document.body) <span class="hljs-comment">//body元素</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(document.head) <span class="hljs-comment">//head元素</span><br></code></pre></td></tr></table></figure><h3 id="Node（节点）之间的导航-navigator"><a href="#Node（节点）之间的导航-navigator" class="headerlink" title="Node（节点）之间的导航(navigator)"></a>Node（节点）之间的导航(navigator)</h3><h3 id="节点之间的导航"><a href="#节点之间的导航" class="headerlink" title="节点之间的导航"></a>节点之间的导航</h3><ul><li>获取一个节点（node）后，可以根据其获取其他节点</li><li> 父节点：parentNode </li><li> 前兄弟节点：previousSibling </li><li> 后兄弟节点：nextSibling </li><li> 子节点：childNodes </li><li> 第一个子节点：firstChild</li><li> 第二个子节点：lastChild</li></ul><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs openscad"> 父元素：parentElement<br> 前兄弟节点：previousElementSibling<br> 后兄弟节点：nextElementSibling<br> 子节点：<span class="hljs-built_in">children</span><br> 第一个子节点：firstElementChild<br> 第二个子节点：lastElementChild<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高阶函数</title>
    <link href="/2022/07/21/JS%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2022/07/21/JS%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>能在函数中运行另一个函数的被称为高阶函数</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><p>forEach函数是一个高阶函数，他的作用对数组中的每个元素执行命令</p><p><code>arr.forEach(function)</code></p></li><li><pre><code class="hljs"> var item = [1, 2, 3, 4]var foo = function(fn)&#123;      for(i = 0; i &lt; item.length; i++)&#123;        fn(item[i], i, item)      &#125;    &#125;<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>- 这也可以实现和forEach一样的效果，但是函数无法便利的获取数组名，不具有复用性<br><br>- 可以将自制的方法放到原型中，这样方便<span class="hljs-keyword">this</span>指向<br><br>- ```<br>  Array.prototype.foo = function(fn) &#123;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++)&#123;<br>          fn(<span class="hljs-keyword">this</span>[i], i, <span class="hljs-keyword">this</span>)<br>        &#125;<br>     &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS的简单内存</title>
    <link href="/2022/07/18/JS%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E5%AD%98/"/>
    <url>/2022/07/18/JS%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h2><ul><li><p>对象内容保存在堆中，而其他的属性，比如变量，常量,函数保存在栈中</p></li><li><p>其实栈中也存在对象，不过只是指向对象的内存地址。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var <span class="hljs-keyword">info</span> = &#123;<br><span class="hljs-type">name</span>: <span class="hljs-string">&#x27;why&#x27;</span>,<br>friend: &#123;<br><span class="hljs-type">name</span>: <span class="hljs-string">&#x27;kobe&#x27;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在这个info对象里面保存的friend也是一个指针，指向新的内存地址</p></li><li><p>所以下面的obj才不会变，因为指向了新的内存地址</p></li><li><pre><code class="hljs">  值传递  function foo(a) &#123;    a = 200  &#125;  let num = 100  foo(num)  console.log(num) //100<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>- ```<br>  function <span class="hljs-built_in">foo</span>(a) &#123;<br>      <span class="hljs-selector-tag">a</span> = &#123;<br>        name: <span class="hljs-string">&#x27;why&#x27;</span><br>      &#125;<br>    &#125;<br>  <br>    <span class="hljs-selector-tag">var</span> obj = &#123;<br>      name: <span class="hljs-string">&#x27;obj&#x27;</span><br>    &#125;<br>    <span class="hljs-built_in">foo</span>(obj)<br>    console<span class="hljs-selector-class">.log</span>(obj.name) <span class="hljs-comment">//obj</span><br>    <span class="hljs-comment">//引用传递，在函数中创建一个新对象，没有对传入对象进行修改</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>以上两个都是函数里面指向了一个新的内存地址，但原本的地址并没有更改</p></li><li><pre><code class="hljs">function foo(a) &#123;      a.name = &#39;why&#39;  &#125;  var obj = &#123;    name: &#39;obj&#39;  &#125;  foo(obj)  console.log(obj.name) //why</code></pre></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象的遍历</title>
    <link href="/2022/07/18/%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2022/07/18/%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h2><ul><li>Object.key() 一个方法，会返回一个由一个给定对象的自身可枚举属性所组成的数组</li></ul><h3 id="普通的for循环"><a href="#普通的for循环" class="headerlink" title="普通的for循环"></a>普通的for循环</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> info = &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kami&quot;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br> <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;Q&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> infoKey = Object.keys(info)<br> <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; infoKey.<span class="hljs-built_in">length</span>; i++) &#123;<br>   <span class="hljs-keyword">var</span> key = infoKey[i]<br>   <span class="hljs-keyword">var</span> value = info[key]<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`key: <span class="hljs-subst">$&#123;key&#125;</span>,value: <span class="hljs-subst">$&#123;value&#125;</span> `</span>)<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="for-in"><a href="#for-in" class="headerlink" title="for..in.."></a>for..in..</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key in info) &#123;<br>    <span class="hljs-keyword">var</span> value = info[key]<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`key: <span class="hljs-subst">$&#123;key&#125;</span>,value: <span class="hljs-subst">$&#123;value&#125;</span> `</span>)<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS入门</title>
    <link href="/2022/07/14/JS%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/14/JS%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="交换两个变量的值"><a href="#交换两个变量的值" class="headerlink" title="交换两个变量的值"></a>交换两个变量的值</h2><ul><li>新建一个变量三。将变量一赋值给他。然后将变量二赋值给变量一。再将变量三赋值给变量二。</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">var <span class="hljs-symbol">num1</span> = <span class="hljs-number">10</span><br>var <span class="hljs-symbol">num2</span> = <span class="hljs-number">20</span><br>var <span class="hljs-symbol">num3</span> = <span class="hljs-symbol">num1</span><br><span class="hljs-symbol">num1</span> = <span class="hljs-symbol">num2</span><br><span class="hljs-symbol">num2</span> = <span class="hljs-symbol">num3</span><br></code></pre></td></tr></table></figure><ul><li>使用加减法交换(不需要新建变量)</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-symbol">num1</span> = <span class="hljs-symbol">num1</span> + <span class="hljs-symbol">num2</span><br><span class="hljs-symbol">num2</span> = <span class="hljs-symbol">num1</span> - <span class="hljs-symbol">num2</span><br><span class="hljs-symbol">num1</span> = <span class="hljs-symbol">num1</span> - <span class="hljs-symbol">num2</span><br></code></pre></td></tr></table></figure><h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><ul><li><p>typeof  判断没赋值的变量时会返回undefined</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> age)<br></code></pre></td></tr></table></figure></li></ul><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><ul><li>NaN  代表一个计算错误,他是一个错误的操作得到的结果 比如数字和字符串相乘</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li><p>用反引号的时候里面可以使用变量  用**${}**引入</p></li><li><p>所以字符串的拼接可以直接用**${}**引入</p></li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><ul><li>指的是这样一个数列：1、1、2、3、5、8、13、21、34</li><li>这个数列从第3项开始，每一项都等于前两项之和。</li><li><em>F</em>(0)&#x3D;0，<em>F</em>(1)&#x3D;1, <em>F</em>(n)&#x3D;<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N*）</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> Fibonacci (n) &#123;<br>      <span class="hljs-keyword">if</span>(n<span class="hljs-operator"> === </span><span class="hljs-number">1</span> <span class="hljs-pattern-match">| n <span class="hljs-operator">==</span>= 2) return n</span><br><span class="hljs-pattern-match">      <span class="hljs-constructor">Fibonacci(<span class="hljs-params">n</span>-2)</span> = <span class="hljs-constructor">Fibonacci(<span class="hljs-params">n</span>)</span> - <span class="hljs-constructor">Fibonacci(<span class="hljs-params">n</span>-1)</span></span><br><span class="hljs-pattern-match">      return <span class="hljs-constructor">Fibonacci(<span class="hljs-params">n</span>-2)</span></span><br><span class="hljs-pattern-match">    &#125;</span><br></code></pre></td></tr></table></figure><ul><li>这样写会报错，return不能返回（n - 2）</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">function Fibonacci (n) &#123;<br>      <span class="hljs-built_in">if</span>(n === <span class="hljs-number">1</span> | n === <span class="hljs-number">2</span>) return n<br>      return <span class="hljs-built_in">Fibonacci</span>(n-<span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span>(n-<span class="hljs-number">2</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>这样才会正确返回</li></ul><h2 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h2><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> bthEls = document.querySelectorAll(<span class="hljs-string">&#x27;.btn&#x27;</span>)<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; bthEls.lenght; i++) &#123;<br><span class="hljs-keyword">var</span> bth = bthEls[i]<br>bth.onclick = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`按钮<span class="hljs-subst">$&#123;i+<span class="hljs-number">1</span>&#125;</span>发生了点击`</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>你点击按钮的时候，输出的是固定的值。</p></li><li><p>因为在你点击按钮的时候，循环就已经结束了。所以i的值也固定了。</p></li><li><p>在ES6后就你用let就行。var是真的拉</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Less</title>
    <link href="/2022/07/12/Less/"/>
    <url>/2022/07/12/Less/</url>
    
    <content type="html"><![CDATA[<h3 id="Less-（Leaner-Style-Sheets-的缩写）-是一门CSS-扩展语言-并且兼容CSS。"><a href="#Less-（Leaner-Style-Sheets-的缩写）-是一门CSS-扩展语言-并且兼容CSS。" class="headerlink" title="Less （Leaner Style Sheets 的缩写） 是一门CSS 扩展语言, 并且兼容CSS。"></a>Less （Leaner Style Sheets 的缩写） 是一门CSS 扩展语言, 并且兼容CSS。</h3><ul><li>Less增加了很多相比于CSS更好用的特性;</li><li>比如定义变量、混入、嵌套、计算等等； </li><li>Less最终需要被编译成CSS运行于浏览器中（包括部署到服务器中）；</li></ul><h3 id="less代码的编译"><a href="#less代码的编译" class="headerlink" title="less代码的编译"></a>less代码的编译</h3><ul><li><p>引入CDN的less编译代码，对less进行实时的处理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet/less&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./css/page_right_nav.less&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/less@4&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>把<a href="https://cdn.jsdelivr.net/npm/less@4%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%96%B0%E5%BB%BA%E7%9A%84.less%E6%96%87%E4%BB%B6%E9%87%8C">https://cdn.jsdelivr.net/npm/less@4里面的代码复制到本地新建的.less文件里</a></p></li></ul><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><ul><li>可以@变量名 : 变量</li><li>然后要使用时直接**@变量名**就可以了</li><li>可以使用关键字，测试@color可以使用</li></ul><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><ul><li><p>给class定义样式时，因为要规范，清晰，往往在写一个class时前面还会拖家带口的</p></li><li><p>less就解决了这个烦恼</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">  &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;<br>    我是box<br>    &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;pel&quot;</span>&gt;<br>      我不是box<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>  <br>  <br>@color : <span class="hljs-comment">#080808;</span><br>@maincolor: <span class="hljs-comment">#f3c258;</span><br>.box &#123;<br>  color: @color;<br><br>  .pel &#123;<br>    background-color: @color;<br>    color: @maincolor;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以在选择器里套后代选择器超方便的.</p></li><li><p>做hover时也有语法糖</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">9</span>, <span class="hljs-number">163</span>, <span class="hljs-number">42</span>);<br>  <br>  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在里面添加一个&amp;:hover就可以设置hover样式了</p></li><li><p>&amp;后面也可以加其他的伪类</p></li></ul><h2 id="运算-很少用"><a href="#运算-很少用" class="headerlink" title="运算(很少用)"></a>运算(很少用)</h2><h3 id="在less中-算术运算符可以对任何数字颜色或变量进行运算"><a href="#在less中-算术运算符可以对任何数字颜色或变量进行运算" class="headerlink" title="在less中,算术运算符可以对任何数字颜色或变量进行运算"></a>在less中,算术运算符可以对任何数字颜色或变量进行运算</h3><ul><li><p>算术运算符在加减或比较前会进行单位换算，计算的结果以最左侧操作数的单位类型为准</p></li><li><p>如果单位换算无效或失去意义，则忽略单位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span> + <span class="hljs-number">10em</span>;<br>这样的话得到的结果是<span class="hljs-number">110px</span>,直接将后面的单位忽略.<br></code></pre></td></tr></table></figure></li></ul><h2 id="混合mixins"><a href="#混合mixins" class="headerlink" title="混合mixins"></a>混合mixins</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: aqua;<br><br>  <span class="hljs-selector-class">.noewrap_ellipsis</span>()<br>&#125;<br><br><span class="hljs-selector-class">.box2</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff5</span>;<br>&#125;<br><br><span class="hljs-selector-class">.noewrap_ellipsis</span> &#123;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将类之间塞进另一个类里,方便了很多.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.box_border</span>(<span class="hljs-variable">@Width</span>: <span class="hljs-number">5px</span>, <span class="hljs-variable">@border</span>: blue) &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-variable">@Width</span> solid <span class="hljs-variable">@border</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以给里面设置变量,这样在引入时可以在小括号里更改参数.</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">上面box2的宽度还可以这样设置<br><span class="hljs-built_in">width</span>: .<span class="hljs-built_in">box</span>()[<span class="hljs-built_in">width</span>]<br></code></pre></td></tr></table></figure><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Uncaught</span> (<span class="hljs-keyword">in</span> promise) <span class="hljs-title class_">TypeError</span>: <span class="hljs-title class_">Cannot</span> read properties <span class="hljs-keyword">of</span> <span class="hljs-literal">undefined</span> (reading <span class="hljs-string">&#x27;href&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>大概是这样的，解决办法很奇怪</li><li>在VScode里启用本地服务器，就是右键Open with Live Server（好像是个插件来着）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFC</title>
    <link href="/2022/07/10/BFC/"/>
    <url>/2022/07/10/BFC/</url>
    
    <content type="html"><![CDATA[<h2 id="FC"><a href="#FC" class="headerlink" title="FC"></a>FC</h2><p>formatting context</p><ul><li>感觉就是布局元素</li></ul><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>Block Formatting Context</p><ul><li>块级元素布局环境</li><li>在以下情况会创建一个bfc</li><li><ul><li>根元素 （<html>)   </li><li>浮动元素</li><li>弹性元素</li><li>绝对定位元素</li><li>行内块元素</li><li>表格单元格</li><li>overflow</li><li>网格元素</li><li>display值为flow-root的元素</li></ul></li><li>影响布局的都会创建一个BFC</li><li>在BFC中，盒子会从顶部开始垂直方向上一个接一个排布</li><li>margin属性是由BFC定义</li></ul><h3 id="在同一个BFC中相邻的两个块级元素margin会折叠"><a href="#在同一个BFC中相邻的两个块级元素margin会折叠" class="headerlink" title="在同一个BFC中相邻的两个块级元素margin会折叠"></a>在同一个BFC中相邻的两个块级元素margin会折叠</h3><h3 id="盒子在默认情况下左边缘会紧挨着BFC左边缘"><a href="#盒子在默认情况下左边缘会紧挨着BFC左边缘" class="headerlink" title="盒子在默认情况下左边缘会紧挨着BFC左边缘"></a>盒子在默认情况下左边缘会紧挨着BFC左边缘</h3><h3 id="在高度是auto的情况下，计算高度"><a href="#在高度是auto的情况下，计算高度" class="headerlink" title="在高度是auto的情况下，计算高度"></a>在高度是auto的情况下，计算高度</h3><ul><li>忽略绝对元素</li><li>增加高度去适应浮动元素</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片模糊</title>
    <link href="/2022/07/10/%E5%9B%BE%E7%89%87%E6%A8%A1%E7%B3%8A/"/>
    <url>/2022/07/10/%E5%9B%BE%E7%89%87%E6%A8%A1%E7%B3%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="blur"><a href="#blur" class="headerlink" title="blur"></a>blur</h2><ul><li><p>将高斯模糊应用于输出图片或者元素</p></li><li><p>such as 给img元素添加模糊效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>像素越大内容越模糊</p></li></ul><h2 id="添加有透明效果的模糊"><a href="#添加有透明效果的模糊" class="headerlink" title="添加有透明效果的模糊"></a>添加有透明效果的模糊</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,.<span class="hljs-number">5</span>);<br> backdrop-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">10px</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>calc</title>
    <link href="/2022/07/10/calc/"/>
    <url>/2022/07/10/calc/</url>
    
    <content type="html"><![CDATA[<h2 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h2><ul><li><p>一个计算属性，常用于变量计算。</p></li><li><pre><code class="hljs">width: calc(100% - 100px)</code></pre></li><li><p>减号左右两边要有空格</p></li><li><p>其中100%是相对于包含块</p></li><li><p>像这样可以计算动态宽度</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>meta</title>
    <link href="/2022/07/10/meta/"/>
    <url>/2022/07/10/meta/</url>
    
    <content type="html"><![CDATA[<h3 id="meta元素用于定义元数据"><a href="#meta元素用于定义元数据" class="headerlink" title="meta元素用于定义元数据"></a>meta元素用于定义元数据</h3><ul><li>比如标签title，样式style，link外部资源等</li></ul><h4 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h4><ul><li>meta是一个字符集声明，告诉文档使用哪种字符编码</li></ul><h4 id="http-equiv"><a href="#http-equiv" class="headerlink" title="http-equiv"></a>http-equiv</h4><ul><li>meta是编译指令</li><li>主要是用于适配浏览器</li></ul><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><ul><li>提供文档级别的元数据，应用于整个页面</li><li>robots</li><li><ul><li>告诉爬虫哪些可以爬</li></ul></li><li>author</li><li><ul><li>文档作者</li></ul></li><li>copyright</li><li><ul><li>版权声明</li></ul></li><li>description</li><li><ul><li>网站描述</li></ul></li><li>keywords</li><li><ul><li>关键字，主要用于SEO优化</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文字前加小图标</title>
    <link href="/2022/07/07/%E6%96%87%E5%AD%97%E5%89%8D%E5%8A%A0%E5%B0%8F%E5%9B%BE%E6%A0%87/"/>
    <url>/2022/07/07/%E6%96%87%E5%AD%97%E5%89%8D%E5%8A%A0%E5%B0%8F%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<ul><li><p>w</p></li><li><p>有时候会有要在一行文字的前面加一个小图片的需求。</p></li><li><p>一般有两种方法，一种是添加一个:hover样式。还有一种就是添加个<i>。</p></li></ul><h3 id="i"><a href="#i" class="headerlink" title="i"></a>i</h3><ul><li><p>在文字前加个i标签，并给i标签设置样式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon_type icon_type_hot&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 游戏介绍<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.icon_type</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">24px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">24px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">2px</span>;</span><br><span class="language-css">  <span class="hljs-comment">/* vertical-align: middle; */</span></span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">../../img/main_sprite.png</span>) no-repeat;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.icon_type_hot</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background-position</span>: -<span class="hljs-number">161px</span> -<span class="hljs-number">67px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><ul><li><p>先给i设置个块级元素以便设置宽高，给右边距和文字有间隔。用background引入图片。要是只有只有一张图片且只用一部分可以直接在background里面设置位置。上面是因为在这个精灵图中要引用几个不同的图标所有才位置分开设置。</p></li><li><p>设置后可能会发现图片没有垂直居中显示。这是因为图片默认设置为基线对齐，基线为文字的底部。这时候我们可以给图片加个vertical-align: middle来改变他的基线对齐。</p></li><li><p>也可以不设置vertical-align: middle。这时候我们可以给a标签加个flex布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<br>      <span class="hljs-attribute">display</span>: flex;<br>      <span class="hljs-attribute">align-items</span>: center;<br>      <span class="hljs-comment">/* justify-content: center; */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这样也可以做到图片垂直居中对齐，不过可能会影响相同class的布局，使他们的居中对齐失效。那我们可以给他加个 justify-content: center;使他们恢复居中对齐</p></li></ul></li></ul><h2 id="after"><a href="#after" class="headerlink" title="::after"></a>::after</h2><h3 id="必须先设置一个content-39-39"><a href="#必须先设置一个content-39-39" class="headerlink" title="必须先设置一个content: &#39;&#39;;"></a>必须先设置一个<code>content: &#39;&#39;;</code></h3><ul><li>给父元素加个相对定位，因为这个要设置绝对定位</li><li>设置宽高，给上下和左或右为0，要对齐那边就哪边为0.</li><li>设置margin：auto 0；来居中</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图层覆盖</title>
    <link href="/2022/07/06/%E5%9B%BE%E5%B1%82%E8%A6%86%E7%9B%96/"/>
    <url>/2022/07/06/%E5%9B%BE%E5%B1%82%E8%A6%86%E7%9B%96/</url>
    
    <content type="html"><![CDATA[<p>- </p><h2 id="图片的层叠性"><a href="#图片的层叠性" class="headerlink" title="图片的层叠性"></a>图片的层叠性</h2><ul><li><p>一般要一个图片在另一个图片之上我们可以给他加z-index</p></li><li><p>当加了z-index无效时查看是否有加定位元素</p></li></ul><h3 id="加了定位元素z-index才会生效"><a href="#加了定位元素z-index才会生效" class="headerlink" title="加了定位元素z-index才会生效"></a>加了定位元素z-index才会生效</h3><ul><li>当双方都没加z-index时，在后面的覆盖前面的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vant组件库</title>
    <link href="/2022/07/04/vant%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    <url>/2022/07/04/vant%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="小程序安装"><a href="#小程序安装" class="headerlink" title="小程序安装"></a>小程序安装</h2><ul><li><p>!()[<a href="https://vant-contrib.gitee.io/vant-weapp/#/home">介绍 - Vant Weapp (gitee.io)</a>]</p></li><li><p>npm安装  是在你使用项目的根目录</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">先安装依赖<br><span class="hljs-built_in">npm</span> init -y<br>然后就可以安装了<br><span class="hljs-built_in">npm</span> i @vant/weapp -S --production<br><br></code></pre></td></tr></table></figure></li><li><p>安装完后会多出两个文件，package.json和node文件夹</p></li><li><p>之后将app.json 中的 “style”: “v2” 删了</p></li><li><p>找到 project.config.json 添加代码</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">&#123;<br>  <span class="hljs-string">...</span><br>  <span class="hljs-string">&quot;setting&quot;</span>: &#123;<br>    <span class="hljs-string">...</span><br>    <span class="hljs-string">&quot;packNpmManually&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;packNpmRelationList&quot;</span>: [<br>      &#123;<br>        <span class="hljs-string">&quot;packageJsonPath&quot;</span>: <span class="hljs-string">&quot;./package.json&quot;</span>,<br>        <span class="hljs-string">&quot;miniprogramNpmDistDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加代码后</p></li><li><p><img src="https://img.yzcdn.cn/public_files/2019/08/15/fa0549210055976cb63798503611ce3d.png" alt="构建npm包"></p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>使用他要现在json中进行配置</p></li><li><p>如要全局使用，则在app.json中配置.只在特定页面中使用则在对应页面的json中配置</p></li></ul><h3 id="引入Button"><a href="#引入Button" class="headerlink" title="引入Button"></a>引入Button</h3>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;usingComponents&quot;: &#123;<br>  &quot;van-<span class="hljs-selector-tag">button</span>&quot;: <span class="hljs-string">&quot;@vant/weapp/dist/button/index&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  引入后,直接在wxml中使用组件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">van-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">van-button</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小程序循环</title>
    <link href="/2022/07/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BE%AA%E7%8E%AF/"/>
    <url>/2022/07/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="简简单单的循环"><a href="#简简单单的循环" class="headerlink" title="简简单单的循环"></a>简简单单的循环</h2><ul><li><p>先在js的data中建立一个数组来存放请求来的数据或是自己定义的数据。</p></li><li><p>然后定义请求方法，定义完后在onLoad函数中调用。</p></li><li><p>在盒子中使用wx:for 用</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-template-variable">&#123;&#123;&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>包裹在data中定义的数组 wx:key，默认为数组的键。</p></li><li><p>data-自定义值   &#x3D;  要传递的值 主要用于事件？</p></li></ul><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-item&quot;</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">product</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;pid&quot;</span> <span class="hljs-attr">data-pid</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.pid</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-coffee&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;widthFix&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.largeImg</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.name</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-enname&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.enname</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-price&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.price</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml"> js</span><br><span class="language-xml"> data: &#123;</span><br><span class="language-xml">    banner: [],</span><br><span class="language-xml">    product: []</span><br><span class="language-xml">  &#125;,</span><br><span class="language-xml">  getProduct()&#123;</span><br><span class="language-xml">    wx.request(&#123;</span><br><span class="language-xml">      url: &#x27;http://www.kangliuyong.com:10002/banner&#x27;, //仅为示例，并非真实的接口地址</span><br><span class="language-xml">      data: &#123;</span><br><span class="language-xml">        appkey: &#x27;U2FsdGVkX19WSQ59Cg+Fj9jNZPxRC5y0xB1iV06BeNA=&#x27;</span><br><span class="language-xml">      &#125;,</span><br><span class="language-xml">      header: &#123;</span><br><span class="language-xml">        &#x27;content-type&#x27;: &#x27;application/json&#x27; // 默认值</span><br><span class="language-xml">      &#125;,</span><br><span class="language-xml">      success:(res)=&gt;&#123;</span><br><span class="language-xml">        console.log(res.data.result);</span><br><span class="language-xml">        this.setData(&#123;</span><br><span class="language-xml">          banner:res.data.result</span><br><span class="language-xml">        &#125;)</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    &#125;)</span><br><span class="language-xml">  &#125;,</span><br><span class="language-xml">  /**</span><br><span class="language-xml">   * 生命周期函数--监听页面加载</span><br><span class="language-xml">   */</span><br><span class="language-xml">  onLoad: function (options) &#123;</span><br><span class="language-xml">    console.log();</span><br><span class="language-xml">    this.getProduct();</span><br><span class="language-xml">  &#125;,</span><br><span class="language-xml">  </span><br></code></pre></td></tr></table></figure><h2 id="双层循环"><a href="#双层循环" class="headerlink" title="双层循环"></a>双层循环</h2><ul><li>在datailData.handler中存在一个数组arr</li><li>在遍历了datailData.handler数组中再遍历arr数组</li><li>wx:for中填写的是item.该数组，后要跟wx:for-item&#x3D;自定义值，之后在盒子内填写 </li></ul><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;choose-type&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;type-box&quot;</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">datailData.handler</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tem&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.type</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-val&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;val&quot;</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.arr</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;count&quot;</span> <span class="hljs-attr">wx:for-index</span>=<span class="hljs-string">&quot;count&quot;</span>  <span class="hljs-attr">wx:for-item</span>=<span class="hljs-string">&quot;val&quot;</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">index</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">data-count</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">count</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">val</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后代选择器</title>
    <link href="/2022/07/02/%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2022/07/02/%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="施工中"><a href="#施工中" class="headerlink" title="施工中"></a>施工中</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VScode快捷键</title>
    <link href="/2022/07/02/VScode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2022/07/02/VScode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="选择相同"><a href="#选择相同" class="headerlink" title="选择相同"></a>选择相同</h2><ul><li><p>依次选择</p></li><li><pre><code class="hljs">Ctrl + D<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>一次选择所有<br><br><span class="hljs-bullet">- </span><span class="hljs-code">```</span><br><span class="hljs-code">  Ctrl + Shift + L</span><br></code></pre></td></tr></table></figure></code></pre></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>border动画</title>
    <link href="/2022/07/01/border%E5%8A%A8%E7%94%BB/"/>
    <url>/2022/07/01/border%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<ul><li><p>给标签加border动画的代码很简单</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transition</span>: border-bottom <span class="hljs-number">150ms</span> ease-in;<br></code></pre></td></tr></table></figure><ul><li>当然前提得是你有个：hover之类得border变化</li></ul></li><li><p>这样一般动画效果都是从上往下加</p></li><li><p>而在你给标签加个</p></li><li><pre><code class="hljs">box-sizing: border-box;</code></pre></li><li><p>这样动画效果就会从下往上了</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂项</title>
    <link href="/2022/06/28/%E6%9D%82%E9%A1%B9/"/>
    <url>/2022/06/28/%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="6月28日"><a href="#6月28日" class="headerlink" title="6月28日"></a>6月28日</h2><p>​在制作样式时，要制作两行文字，一行a标签，一行span。</p><p>​在给a标签添加display：block后，发现他直接把一个盒子行占据了，把span挤出了盒子。给a添加16px的高度后，因为两行文字里的太近了，想添加些中间空隙。给a直接加margin没用，span元素又不支持margin-top。后面发现鼠标放a上不变形状。开F12检查，发现a在盒子最上面。百思不得其解，怎么跑那里去了。就在随便点点的时候把line-height点掉才发现a标签里的字回去了。</p><ul><li>line-height会影响block后的a标签，使其文字和a本身身首异处。</li><li>line-height是<strong>行高</strong>，而a在block后自成一行，所以会受影响。最好line-height别随便加</li></ul><h2 id="文字布局"><a href="#文字布局" class="headerlink" title="文字布局"></a>文字布局</h2><h3 id="使文字在超过两行的内容显示出。。。"><a href="#使文字在超过两行的内容显示出。。。" class="headerlink" title="使文字在超过两行的内容显示出。。。"></a>使文字在超过两行的内容显示出。。。</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-attribute">text-overflow</span>: ellipsis;<br><span class="hljs-attribute">display</span>: -webkit-box;<br>-webkit-line-clamp: <span class="hljs-number">2</span>;<br>-webkit-box-orient: vertical;<br></code></pre></td></tr></table></figure><h3 id="使文字垂直显示"><a href="#使文字垂直显示" class="headerlink" title="使文字垂直显示"></a>使文字垂直显示</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">writing-mode</span>: vertical-lr;<br></code></pre></td></tr></table></figure><h3 id="文字偏移"><a href="#文字偏移" class="headerlink" title="文字偏移"></a>文字偏移</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">text</span>-indent: Xpx<br></code></pre></td></tr></table></figure><ul><li><p>text-indent 属性规定文本块中首行文本的缩进。</p></li><li><p>负值是允许的。如果值是负数，将第一行左缩进。</p></li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="边框合并"><a href="#边框合并" class="headerlink" title="边框合并"></a>边框合并</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">border</span>-<span class="hljs-built_in">collapse</span>: <span class="hljs-built_in">collapse</span><br></code></pre></td></tr></table></figure><ul><li>在设置背景色后可以使格子与格子的间隙消除</li></ul><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">input</span> v-model=<span class="hljs-string">&quot;sth&quot;</span> /&gt;  <span class="hljs-comment">//这一行等于下一行</span><br>    &lt;<span class="hljs-keyword">input</span> v-bind:value=<span class="hljs-string">&quot;sth&quot;</span> v-<span class="hljs-keyword">on</span>:<span class="hljs-keyword">input</span>=<span class="hljs-string">&quot;sth = $event.target.value&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h2 id="hash和history"><a href="#hash和history" class="headerlink" title="hash和history"></a>hash和history</h2><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><ul><li>会改变url，但不会刷新页面。只是在客户端进行的页面跳转</li></ul><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>- </p><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><ul><li><p>我们先用:value绑定数据，再用v-on绑定方法，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">methods: &#123;<br><span class="hljs-built_in">valueChange</span>(event) &#123;<br>this<span class="hljs-selector-class">.message</span> = event<span class="hljs-selector-class">.tarfet</span><span class="hljs-selector-class">.value</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>event是本来就有的。event.target.value就是在input里输入的值。</p></li><li><p>也可以直接</p></li><li><pre><code class="hljs">:value=&quot;message&quot; @input=&quot; message = $event.target.value &quot;</code></pre><p>这就是v-model</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>认识精灵图</title>
    <link href="/2022/06/24/%E8%AE%A4%E8%AF%86%E7%B2%BE%E7%81%B5%E5%9B%BE/"/>
    <url>/2022/06/24/%E8%AE%A4%E8%AF%86%E7%B2%BE%E7%81%B5%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="WHAT-IT"><a href="#WHAT-IT" class="headerlink" title="WHAT IT"></a>WHAT IT</h2><ul><li>是一种CSS图像合成技术，将各种小图片合并到一张图片上，然后利用网站获取代码来显示指定小图片</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>减少网页的HTTP请求数量，加快网页响应速度，减轻服务器压力</li><li>减小图片总大小</li><li>解决了图片命名困扰，一张图片集合了许多小图片</li></ul><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><ul><li><p><a href="http://www.spritecow.com/">方便</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.sprite</span> &#123;<br><span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;imgs/top_sprite.png&#x27;</span>) no-repeat -<span class="hljs-number">36px</span> -<span class="hljs-number">6px</span>;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">18px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">18px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>直接复制就完事了</p></li><li><p>小图标可以用伪元素解决</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.X</span><span class="hljs-selector-pseudo">::after</span> &#123;<br><span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attribute">position</span>:absoluta<br><span class="hljs-attribute">width</span>: X<br><span class="hljs-attribute">height</span>: Y<br><span class="hljs-attribute">right</span>: <span class="hljs-number">0</span><br><span class="hljs-attribute">top</span>: <span class="hljs-number">0</span><br><span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span><br><span class="hljs-attribute">margin</span>: auto <span class="hljs-number">0</span><br><span class="hljs-attribute">background</span>: url(<span class="hljs-string"></span>) no-repeat <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>官方文档</title>
    <link href="/2022/06/24/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    <url>/2022/06/24/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="W3"><a href="#W3" class="headerlink" title="W3"></a>W3</h2><p>[跳转](<a href="https://www.w3.org/">World Wide Web Consortium (W3C)</a>)</p><h2 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h2><p><a href="https://developer.mozilla.org/zh-CN/">MDN Web Docs (mozilla.org)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS编写顺序</title>
    <link href="/2022/06/24/CSS%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F/"/>
    <url>/2022/06/24/CSS%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ul><li>凹凸实验室</li><li><a href="https://guide.aotu.io/">跳转</a></li></ul><h3 id="属性书写顺序"><a href="#属性书写顺序" class="headerlink" title="属性书写顺序"></a>属性书写顺序</h3><ol><li>布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow</li><li>自身属性：width &#x2F; height &#x2F; box-sizing &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</li><li>文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word</li><li>其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient …</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vertical-align</title>
    <link href="/2022/06/23/vertical-align/"/>
    <url>/2022/06/23/vertical-align/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>影响行内块元素在行盒内的对齐方式</li></ul><h3 id="行盒"><a href="#行盒" class="headerlink" title="行盒"></a>行盒</h3><ul><li>一行内所有内容的高撑起来的盒子（图片和行内块元素的高度）</li></ul><h3 id="行内默认基线对齐"><a href="#行内默认基线对齐" class="headerlink" title="行内默认基线对齐"></a>行内默认基线对齐</h3><ul><li><p>没有盒子时，默认的基线是盒子的margin-bottom的底部</p></li><li><p>基线对齐，基线为最后一行文本的底部</p></li><li><p>如一个空盒子，内部没有文字时他的底部会和文字的底部对齐</p></li><li><p>而当盒子内有文字时，则会使盒子内的文字于基线对齐，因为默认底部对齐，而当处于盒子顶部的文字和基线对齐时，会将盒子挤下去</p></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>baseline: (默认值)基线对齐</li><li>top：行内级盒子的顶部更line boxes顶部对齐</li><li>middle：行内级盒子的中心点与父盒基线加上X-height一半的线对齐</li><li>bottom：把行内级盒子的底部跟line box底部对齐</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transition动画</title>
    <link href="/2022/06/23/transition%E5%8A%A8%E7%94%BB/"/>
    <url>/2022/06/23/transition%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="WHAT-IT"><a href="#WHAT-IT" class="headerlink" title="WHAT IT"></a>WHAT IT</h2><ul><li><p>提供了一种在更改CSS属性时控制动画速度的方法。</p></li><li><p>可以让CSS属性变化成为一个持续一段时间的过程，而不是立即生效；</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">transition-property</span>: transform, left; <span class="hljs-comment">//指定动画的元素 设置为all时所有属性都执行动画</span><br><span class="hljs-attribute">transition-duration</span>: ; <span class="hljs-comment">// 时间</span><br><span class="hljs-attribute">transition-timing-function</span>: ease-in; <span class="hljs-comment">//指向速率</span><br><span class="hljs-attribute">transition-delay</span>: ; <span class="hljs-comment">//延迟</span><br><span class="hljs-attribute">transition</span>： <span class="hljs-attribute">all</span> <span class="hljs-number">1s</span> ease-in <span class="hljs-number">1s</span> <span class="hljs-comment">//简写属性</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>水平居中和垂直居中方案</title>
    <link href="/2022/06/23/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/"/>
    <url>/2022/06/23/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h4 id="行内级元素"><a href="#行内级元素" class="headerlink" title="行内级元素"></a>行内级元素</h4><ul><li>设置父元素的text-align: center</li></ul><h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><ul><li>设置当前margin：0 auto</li></ul><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><ul><li>元素有宽度的情况下，left0&#x2F;right0&#x2F;margin：0 auto;</li></ul><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><ul><li>justift-content: center</li></ul><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h4 id="绝对定位-1"><a href="#绝对定位-1" class="headerlink" title="绝对定位"></a>绝对定位</h4><ul><li>在元素有高度的情况下， top0&#x2F;bottom0&#x2F;margin：auto X；</li></ul><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">position:</span> relative<br><span class="hljs-symbol">top:</span> <span class="hljs-number">50</span>%<br><span class="hljs-symbol">transform:</span> translateY(<span class="hljs-number">-50</span>%)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transform</title>
    <link href="/2022/06/23/transform/"/>
    <url>/2022/06/23/transform/</url>
    
    <content type="html"><![CDATA[<h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ul><li>对某些元素进行形变，如旋转，缩放，平移（通常行内级元素不能形变）</li></ul><h3 id="行内级元素无法形变"><a href="#行内级元素无法形变" class="headerlink" title="行内级元素无法形变"></a>行内级元素无法形变</h3><h3 id="常见的有"><a href="#常见的有" class="headerlink" title="常见的有"></a>常见的有</h3><ul><li>平移： translate（x ,y) &#x2F;&#x2F;可以用%参照为自身宽高</li><li>缩放：scale(x ,y)</li><li>旋转：rotate( x ,y)</li><li>倾斜：skew (deg ,deg)</li></ul><h3 id="缩放-scale"><a href="#缩放-scale" class="headerlink" title="缩放 - scale"></a>缩放 - scale</h3><ul><li>改变大小，不影响布局</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">transform</span>: scale(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) //<span class="hljs-number">1</span>为自身大小<br></code></pre></td></tr></table></figure><p>设置为数字的时候从左上角开始计算，只设一个值时就是X轴</p><h3 id="旋转-rotate"><a href="#旋转-rotate" class="headerlink" title="旋转 - rotate"></a>旋转 - rotate</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">90deg</span>)<br></code></pre></td></tr></table></figure><h2 id="形变起点"><a href="#形变起点" class="headerlink" title="形变起点"></a>形变起点</h2><ul><li>transform-origin：</li><li>默认为center center</li></ul><h2 id="倾斜-skew"><a href="#倾斜-skew" class="headerlink" title="倾斜 - skew"></a>倾斜 - skew</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">skew</span>(Xdge,Ydge)<br></code></pre></td></tr></table></figure><h2 id="transform设置多个值"><a href="#transform设置多个值" class="headerlink" title="transform设置多个值"></a>transform设置多个值</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">skew</span>(Xdge,Ydge)<br>transform: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">90deg</span>)<br>transform: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这样写的话后面的会覆盖前面，使前两行代码无效</p><p>正确的是</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">transform</span>: translate(<span class="hljs-number">50</span>px) scale(<span class="hljs-number">1</span>.<span class="hljs-number">2</span>) rotate(<span class="hljs-number">4</span>.<span class="hljs-number">5</span>deg)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的错误</title>
    <link href="/2022/06/21/hexo%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <url>/2022/06/21/hexo%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p> err: YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key (4:1)</p><p>可能是开头的title之类的 : 后面要加空格</p><h3 id="加本地图片"><a href="#加本地图片" class="headerlink" title="加本地图片"></a>加本地图片</h3><ul><li><p>要在source文件夹下创建一个images文件夹，把图片放在里面，在引用图片时</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">![](<span class="hljs-regexp">/images/</span>图片名称)<br></code></pre></td></tr></table></figure><p>在本地文本中不显示图片，但在服务器上会显示</p></li></ul><h2 id="err-Error-Spawn-failed"><a href="#err-Error-Spawn-failed" class="headerlink" title="err: Error: Spawn failed"></a>err: Error: Spawn failed</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">##进入站点根目录</span><br>cd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/src/</span>hexo<span class="hljs-regexp">/hanyubolg/</span><br><br><span class="hljs-comment">##删除git提交内容文件夹</span><br>rm -rf .deploy_git/<br><br><span class="hljs-comment">##执行</span><br>git config --global core.autocrlf false<br><br><span class="hljs-comment">##最后</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br>————————————————<br>版权声明：本文为CSDN博主「wei-xiansen」的原创文章，遵循CC <span class="hljs-number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/weixin_41256398/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">117994899</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex</title>
    <link href="/2022/06/21/flex/"/>
    <url>/2022/06/21/flex/</url>
    
    <content type="html"><![CDATA[<h2 id="flex基本特性"><a href="#flex基本特性" class="headerlink" title="flex基本特性"></a>flex基本特性</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">display: flex;<br>display: <span class="hljs-keyword">inline</span>-flex <span class="hljs-comment">//行内元素</span><br></code></pre></td></tr></table></figure><h3 id="排列布局"><a href="#排列布局" class="headerlink" title="排列布局"></a>排列布局</h3><ul><li><p>在里面的块级元素会按照主轴方向排列一排，在添加换行代码前不会换行，目前已知内部的块级元素宽度相同时，在内部宽度超过当前元素的宽度时，内部元素的宽度会改变成适应当前元素均等宽度</p></li><li><p>主轴方向默认左到右，可以上到下，也可以将主轴头尾置换</p></li></ul><h3 id="改变主轴方向"><a href="#改变主轴方向" class="headerlink" title="改变主轴方向"></a>改变主轴方向</h3>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">flex-direction: <span class="hljs-keyword">row</span> | <span class="hljs-keyword">row</span>-<span class="hljs-keyword">reverse</span> | <span class="hljs-keyword">column</span> | <span class="hljs-keyword">column</span>-<span class="hljs-keyword">reverse</span><br></code></pre></td></tr></table></figure><p>  reverse是将主轴头尾置换</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">flex-<span class="hljs-built_in">wrap</span>: newrap | <span class="hljs-built_in">wrap</span> | <span class="hljs-built_in">wrap</span>-<span class="hljs-built_in">reverse</span>;<br></code></pre></td></tr></table></figure><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">justify-content: flex-start | <span class="hljs-type">flex</span>-<span class="hljs-keyword">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">space</span>-between | <span class="hljs-type">space_around</span><br></code></pre></td></tr></table></figure><p>start ： 左对齐(头)</p><p>end ： 右对齐(尾)</p><p>center： 居中对齐</p><p>between：两边对齐</p><h2 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h2><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sml">flex-flow: &lt; <span class="hljs-symbol">&#x27;flex</span>-direction&#x27; &gt; || &lt; <span class="hljs-symbol">&#x27;flex</span>-wrap&#x27; &gt;<br></code></pre></td></tr></table></figure><ul><li>顺序任意，且都可以省略</li></ul><h3 id="Y轴对齐"><a href="#Y轴对齐" class="headerlink" title="Y轴对齐"></a>Y轴对齐</h3><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">align-items: stretch | <span class="hljs-type">flex</span>-start | <span class="hljs-type">flex</span>-<span class="hljs-keyword">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">baseline</span><br></code></pre></td></tr></table></figure><ul><li>stretch： 在元素高度为auto的情况下，该元素会被拉伸</li><li>start: 顶端对齐</li><li>end：低端对齐</li><li>center：居中对齐</li><li>baseline：基线对齐（文本底部？）</li></ul><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p><img src="/images/content.jpg" alt="content"></p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><ul><li>在子元素的宽度总和未达到父元素宽度时，给flex的子元素设置</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span>: X<br></code></pre></td></tr></table></figure><p>X为数字，会将父元素剩余的宽度分给子元素，分配机制为，子元素的X加起来，将剩余宽度分为X份，在根据子元素的X在分配宽度。当所有子元素X一样时，均分。</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><ul><li><p>在子元素宽度总和超过父元素宽度时使用，默认为1，所以在不设置的情况下会出现子元素被压缩的情景。当设置为0时，子元素可以溢出父元素宽度，不在压缩。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-shrink</span>: X<br></code></pre></td></tr></table></figure><p>分配机制和grow一样。</p><p>flex itmes 压缩后的最终size不能小于min-width\min-height</p></li></ul><h3 id="少用"><a href="#少用" class="headerlink" title="少用"></a>少用</h3><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-basis</span>:X<br></code></pre></td></tr></table></figure><p>在内容不多时和width一样，但当内容超出宽度是，可以将盒子的宽度延申。</p><h2 id="flex简写"><a href="#flex简写" class="headerlink" title="flex简写"></a>flex简写</h2><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sml">flex: none | &lt;<span class="hljs-symbol">&#x27;flex</span>-grow&#x27;&gt; &lt; <span class="hljs-symbol">&#x27;flex</span>-shrink&#x27;&gt;? || &lt;<span class="hljs-symbol">&#x27;flex</span>-basis&#x27;&gt;<br></code></pre></td></tr></table></figure><p>无单位的值就是gorw或shrink，且输入的第一个无单位值默认为gorw</p><h2 id="也许有用"><a href="#也许有用" class="headerlink" title="也许有用"></a>也许有用</h2><ul><li><p>在flex布局中使用 </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">display</span><span class="hljs-punctuation">: </span>flex<br><span class="hljs-attribute">flex-wrap</span><span class="hljs-punctuation">: </span>wrap<br><span class="hljs-attribute">justify-conent</span><span class="hljs-punctuation">: </span>space-between<br></code></pre></td></tr></table></figure><p>的情况下，最后一行元素不够时，会两端对齐，这样中间就没有内容，不够雅观。为了最后一行也可以按顺序排列，我们可以这样做</p><ul><li>在flex盒子的最下层添加个数为（列数-2）的span（i也可以），并将赋予他们宽度，宽度可以为flex内盒子的宽度，这样，span就会将最后一行剩余的盒子数填充，而且不显示，在视图中，则是最后一行是按顺序排列的，达到了我们想要的效果。因为span并没有设置高度和内容，所以他不会破坏flex结构。</li></ul></li></ul><h2 id="当flex设为0时"><a href="#当flex设为0时" class="headerlink" title="当flex设为0时"></a>当flex设为0时</h2><ul><li><p>会发现盒子的宽度变得很小</p></li><li><p>当给flex一个自然数时，flex-basis的值会变为0.而flex的值为1时，盒子的宽度还会增长，就没有问题。当flex为0时就出现了问题</p></li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3>  <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">flex:</span> <span class="hljs-number">0</span> <span class="hljs-keyword">auto</span><br></code></pre></td></tr></table></figure><h2 id="内容溢出盒子"><a href="#内容溢出盒子" class="headerlink" title="内容溢出盒子"></a>内容溢出盒子</h2><ul><li><p>有时会出现给盒子设置文本时会溢出盒子，此时设置宽度也无效。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.father</span> &#123;<br>dusplay: <span class="hljs-attribute">flex</span><br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br><span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时无效的话可给子元素加个</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.son</span> &#123;<br><span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">width</span>: <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在网上看到第二个解决办法，是加个overf：hidden 但我那个本来也要加，就不知道有没有效果。还有在检查样式时发现用外部引入的样式可能会用不了，在浏览器的检查模式中是灰的。不知道什么问题，不过只要在style里添加就可以了</p><ul><li><p>第二种办法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.son</span> &#123;<br><span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">overflow</span>: hidden<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>emmet语法</title>
    <link href="/2022/06/20/emmet%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/06/20/emmet%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/emmet1.jpg" alt="avatar"></p><p><img src="/images/emmet2.jpg" alt="avatar"></p><p><img src="/images/emmet3.jpg" alt="avatar"></p><p><img src="/images/emmet4.jpg" alt="avatar"></p><p><img src="/images/emmet5.jpg" alt="avatar"></p><p><img src="/images/emmet6.jpg" alt="avatar"></p><p>![avatar](&#x2F;images&#x2F;css emmet.jpg)</p>]]></content>
    
    
    
    <tags>
      
      <tag>ccs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础</title>
    <link href="/2022/06/20/CSS%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/06/20/CSS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="margin元素的传递"><a href="#margin元素的传递" class="headerlink" title="margin元素的传递"></a>margin元素的传递</h3><ul><li>当块级子元素和父元素的顶端对齐时，对子元素的margin-top会生效到父元素上</li></ul><h4 id="防止"><a href="#防止" class="headerlink" title="防止"></a>防止</h4><ul><li><p>不使用margin而是使用padding</p></li><li><p>给父元素设置border</p></li><li><p>触发BFC： 设置overflow为auto</p></li></ul><h2 id="快速均等排列"><a href="#快速均等排列" class="headerlink" title="快速均等排列"></a>快速均等排列</h2><ul><li>在父盒子输入display flex属性时在子盒子添加一个相同的类，并在类中添加flex：1的属性便会实现盒子平均横向排列</li></ul><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><ul><li>clear属性可以指定一个元素是否必须移动（清除浮动后）到在它之前的浮动元素下面；</li><li>left：顶部低于左浮动元素底部</li><li>right：右浮动</li><li>both： 所有</li></ul><h3 id="BFC解决高度塌陷"><a href="#BFC解决高度塌陷" class="headerlink" title="BFC解决高度塌陷"></a>BFC解决高度塌陷</h3><ul><li>给父元素一个BFC和height：auto，可以给父元素一个overflow: auto;以创建一个BFC</li></ul><h3 id="伪元素清除浮动"><a href="#伪元素清除浮动" class="headerlink" title="伪元素清除浮动"></a>伪元素清除浮动</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.X</span><span class="hljs-selector-pseudo">::after</span> &#123;<br><span class="hljs-attribute">display</span>: block;<br><span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span><br>clear: both<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><ul><li>align-items 属性为弹性容器内的项目指定默认对齐方式。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p>将弹性 <div> 元素的所有项目的居中对齐</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">align-items: stretch|<span class="hljs-type">center</span>|<span class="hljs-type">flex</span>-start|<span class="hljs-type">flex</span>-<span class="hljs-keyword">end</span>|<span class="hljs-type">baseline</span>|<span class="hljs-type">initial</span>|<span class="hljs-type">inherit</span>;<br></code></pre></td></tr></table></figure><ul><li>stretch  默认。项目被拉伸以适合容器。</li><li>center  项目位于容器中央</li><li>flex-start 开头</li><li>flex-end  末端</li><li>baseline   基线</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定位</title>
    <link href="/2022/06/20/%E5%AE%9A%E4%BD%8D/"/>
    <url>/2022/06/20/%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">position: relative<br></code></pre></td></tr></table></figure><ul><li>依旧在文档流占据位置</li><li>移动时参照自身原本的位置</li></ul><h4 id="保持图片在中心位置"><a href="#保持图片在中心位置" class="headerlink" title="保持图片在中心位置"></a>保持图片在中心位置</h4><ul><li><p>在改变浏览器宽度时，让图片的中心跟随浏览器中心的改变而改变</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">position: relative<br>left: -(图片一半)px<br>margin-left: 50%<br></code></pre></td></tr></table></figure><p>上面的margin-left继承于父元素</p></li></ul><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">position: absolute<br></code></pre></td></tr></table></figure><ul><li>不占据文档流的位置</li><li>移动时参照最近的定位祖先元素</li></ul><h2 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">position: fixed<br></code></pre></td></tr></table></figure><ul><li>不占据文档流位置</li><li>参照为浏览器视口</li></ul><h2 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">position: sticky<br></code></pre></td></tr></table></figure><ul><li>在移动到某个阈值点前和相对定位表现一样</li><li>在达到阈值点后便固定于视口</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS注意事项</title>
    <link href="/2022/06/20/CSS%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2022/06/20/CSS%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h1><h2 id="nth-child"><a href="#nth-child" class="headerlink" title="nth-child"></a>nth-child</h2><ul><li>nth-child(2n) 选择所有偶数后代  </li><li>可以使用::after并在里面添加</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">.<span class="hljs-literal">right</span>-area <span class="hljs-keyword">a</span>:<span class="hljs-keyword">first</span>-child<br></code></pre></td></tr></table></figure><ul><li>用的时候请精确到具体元素</li></ul><h2 id="margin-top"><a href="#margin-top" class="headerlink" title="margin-top"></a>margin-top</h2><p>百分比是相对于父元素的<code>**宽度**</code></p><h3 id="行内级元素无法用transform"><a href="#行内级元素无法用transform" class="headerlink" title="行内级元素无法用transform"></a>行内级元素无法用transform</h3><p>标签与标签之间换行的话中间有个空格，会占据宽度，影响布局</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/19/hello-world/"/>
    <url>/2022/06/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
